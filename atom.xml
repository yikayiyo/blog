<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misbehavior</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yikayiyo.github.io/"/>
  <updated>2020-06-30T04:14:52.323Z</updated>
  <id>https://yikayiyo.github.io/</id>
  
  <author>
    <name>yikayiyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网站性能提升最佳实践四</title>
    <link href="https://yikayiyo.github.io/2020/06/30/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%9B%9B/"/>
    <id>https://yikayiyo.github.io/2020/06/30/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%9B%9B/</id>
    <published>2020-06-30T03:08:45.000Z</published>
    <updated>2020-06-30T04:14:52.323Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink</a></p><ul><li>Content</li><li>Server</li><li>Cookie</li><li>CSS</li><li>JavaScript</li><li>Images</li><li>Mobile</li></ul><p>原文从七个方面总结网站性能提升。</p><p>本篇总结Javascript、Images方面。</p><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h3 id="Put-Scripts-at-Bottom-脚本放在底部"><a href="#Put-Scripts-at-Bottom-脚本放在底部" class="headerlink" title="Put Scripts at Bottom 脚本放在底部"></a><a href="https://developer.yahoo.com/performance/rules.html#js_bottom" target="_blank" rel="noopener">Put Scripts at Bottom</a> 脚本放在底部</h3><p>脚本会阻塞并行下载</p><p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4" target="_blank" rel="noopener">HTTP / 1.1规范</a>建议浏览器每个主机名并行下载最多两个组件</p><p>如果有多个主机名提供<strong>图像</strong>，则可以并行进行两个以上的下载，但是在下载<strong>脚本</strong>时，即使使用不同的主机名，浏览器也不会启动任何其他下载</p><p>defer脚本表示脚本不包含document.write，浏览器可以继续渲染</p><p>通常一个脚本如果可以defered，那它也可以移动到页面底部</p><h3 id="Make-JavaScript-and-CSS-External-从外部引用js脚本和css文件"><a href="#Make-JavaScript-and-CSS-External-从外部引用js脚本和css文件" class="headerlink" title="Make JavaScript and CSS External 从外部引用js脚本和css文件"></a><a href="https://developer.yahoo.com/performance/rules.html#external" target="_blank" rel="noopener">Make JavaScript and CSS External</a> 从外部引用js脚本和css文件</h3><p>在HTML文档中内嵌的JavaScript和CSS会在每次请求HTML文档时被下载</p><p>使用外部文件通常会产生更快的页面，因为JavaScript和CSS文件被浏览器缓存</p><p>如果JavaScript和CSS在外部文件中，并且被浏览器缓存，则在不增加HTTP请求次数的情况下减小了HTML文档的大小</p><p>如果用户每次会话都有多个页面浏览，并且许多页面重复使用相同的脚本和样式表，那么缓存外部文件的潜在好处就更大</p><p>对于主页，这种每次会话只访问一次的页面，将js和css内联可能更好</p><p>一个样例：</p><p>对于许多浏览页面的第一个页面，内联js和css（减少请求次数，该页面<strong>加载完后动态下载</strong>外部文件，随后访问的页面会使用这些<strong>缓存</strong></p><h3 id="Minify-JavaScript-and-CSS-压缩JavaScript和CSS"><a href="#Minify-JavaScript-and-CSS-压缩JavaScript和CSS" class="headerlink" title="Minify JavaScript and CSS 压缩JavaScript和CSS"></a><a href="https://developer.yahoo.com/performance/rules.html#minify" target="_blank" rel="noopener">Minify JavaScript and CSS</a> 压缩JavaScript和CSS</h3><p>压缩代码指的是删除不必要的代码，减小代码体积（因此可以提升响应性能</p><p>混淆代码也是减小代码体积的方法，但是is more risky</p><p>除了压缩外部脚本和样式之外，可以并且也应该压缩内联的<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>块。</p><p>即使脚本和css文件已经被gzip了，压缩还能让它们的体积减少5%以上</p><p><a href="https://tool.oschina.net/jscompress" target="_blank" rel="noopener">在线压缩工具</a></p><a id="more"></a><h3 id="Remove-Duplicate-Scripts-删除重复脚本"><a href="#Remove-Duplicate-Scripts-删除重复脚本" class="headerlink" title="Remove Duplicate Scripts 删除重复脚本"></a><a href="https://developer.yahoo.com/performance/rules.html#js_dupes" target="_blank" rel="noopener">Remove Duplicate Scripts</a> 删除重复脚本</h3><p>重复脚本出现的两个关键因素：</p><ul><li>脚本数量太多</li><li>团队人数太多</li></ul><p>重复脚本因为浪费HTTP请求和Js执行而损害性能</p><p>避免方法：</p><ul><li><p>使用script标签引入js脚本（不都是这么做的吗？</p></li><li><p>php代码</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> insertScript(<span class="string">"menu.js"</span>) <span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="Minimize-DOM-Access-最小化DOM访问"><a href="#Minimize-DOM-Access-最小化DOM访问" class="headerlink" title="Minimize DOM Access 最小化DOM访问"></a><a href="https://developer.yahoo.com/performance/rules.html#dom_access" target="_blank" rel="noopener">Minimize DOM Access</a> 最小化DOM访问</h3><p>使用JavaScript访问DOM元素的速度很慢，因此，为了使页面更具响应性，应该：</p><ul><li><p>缓存对已访问元素的引用</p></li><li><p>“离线”更新节点，然后将其添加到树中</p></li><li><p>避免使用JavaScript修复布局</p></li></ul><h3 id="Develop-Smart-Event-Handlers-开发聪明的事件处理程序"><a href="#Develop-Smart-Event-Handlers-开发聪明的事件处理程序" class="headerlink" title="Develop Smart Event Handlers 开发聪明的事件处理程序"></a><a href="https://developer.yahoo.com/performance/rules.html#events" target="_blank" rel="noopener">Develop Smart Event Handlers</a> 开发聪明的事件处理程序</h3><p>如果div中有10个按钮，则仅将一个事件处理程序附加到div包装器上，而不是为每个按钮附加一个处理程序</p><p>无需等待onload事件即可开始对DOM树进行操作</p><p>DOMContentLoaded可能更适合使用</p><h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><h3 id="Optimize-Images-优化图片"><a href="#Optimize-Images-优化图片" class="headerlink" title="Optimize Images 优化图片"></a><a href="https://developer.yahoo.com/performance/rules.html#opt_images" target="_blank" rel="noopener">Optimize Images</a> 优化图片</h3><p>检查GIF，看看它们是否使用了与图像中颜色数量相对应的调色板大小</p><p>尝试将GIFs转换为PNGs</p><p>使用<a href="https://pmt.sourceforge.io/pngcrush/" target="_blank" rel="noopener">pngcrush</a>压缩PNG</p><p>使用<a href="https://jpegclub.org/" target="_blank" rel="noopener">jpegtran</a>处理JPEG</p><h3 id="Optimize-CSS-Sprites-优化CSS-Sprites"><a href="#Optimize-CSS-Sprites-优化CSS-Sprites" class="headerlink" title="Optimize CSS Sprites 优化CSS Sprites"></a><a href="https://developer.yahoo.com/performance/rules.html#opt_sprites" target="_blank" rel="noopener">Optimize CSS Sprites</a> 优化CSS Sprites</h3><p>将sprite中的图像水平排列，而不是垂直排列，通常会生成较小的文件</p><p>将sprite中相近的颜色组合，有助于保持较低的颜色数量</p><p>“要mobile-friendly”，不要在sprite中的图像之间留下大的空隙</p><h3 id="Do-Not-Scale-Images-in-HTML-不在HTML中缩放图片"><a href="#Do-Not-Scale-Images-in-HTML-不在HTML中缩放图片" class="headerlink" title="Do Not Scale Images in HTML 不在HTML中缩放图片"></a><a href="https://developer.yahoo.com/performance/rules.html#no_scale" target="_blank" rel="noopener">Do Not Scale Images in HTML</a> 不在HTML中缩放图片</h3><p>需要多大的图片就使用多大的图片</p><p>例子：</p><p>需要一个100x100的图片，不要来个500x500的图片然后去压缩它</p><h3 id="Make-favicon-ico-Small-and-Cacheable-图标要小、可缓存"><a href="#Make-favicon-ico-Small-and-Cacheable-图标要小、可缓存" class="headerlink" title="Make favicon.ico Small and Cacheable 图标要小、可缓存"></a><a href="https://developer.yahoo.com/performance/rules.html#favicon" target="_blank" rel="noopener">Make favicon.ico Small and Cacheable</a> 图标要小、可缓存</h3><p>favicon.ico 即使你不关心它，浏览器也会请求它，最好不要使用404响应它</p><p>由于它在同一台服务器上，因此每次请求时都会发送cookie</p><p>它还会干扰下载顺序</p><p>为了克服弊端：</p><ul><li>保证它尽可能小，最好小于1K</li><li>根据需要设置Expires过期头（图标的名字不能改</li></ul><p><a href="http://www.imagemagick.org/" target="_blank" rel="noopener">Imagemagick</a> 可以帮助你创建小图标</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Content&lt;/li&gt;
&lt;li&gt;Server&lt;/li&gt;
&lt;li&gt;Cookie&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;Images&lt;/li&gt;
&lt;li&gt;Mobile&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原文从七个方面总结网站性能提升。&lt;/p&gt;
&lt;p&gt;本篇总结Javascript、Images方面。&lt;/p&gt;
&lt;h2 id=&quot;Javascript&quot;&gt;&lt;a href=&quot;#Javascript&quot; class=&quot;headerlink&quot; title=&quot;Javascript&quot;&gt;&lt;/a&gt;Javascript&lt;/h2&gt;&lt;h3 id=&quot;Put-Scripts-at-Bottom-脚本放在底部&quot;&gt;&lt;a href=&quot;#Put-Scripts-at-Bottom-脚本放在底部&quot; class=&quot;headerlink&quot; title=&quot;Put Scripts at Bottom 脚本放在底部&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#js_bottom&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Put Scripts at Bottom&lt;/a&gt; 脚本放在底部&lt;/h3&gt;&lt;p&gt;脚本会阻塞并行下载&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP / 1.1规范&lt;/a&gt;建议浏览器每个主机名并行下载最多两个组件&lt;/p&gt;
&lt;p&gt;如果有多个主机名提供&lt;strong&gt;图像&lt;/strong&gt;，则可以并行进行两个以上的下载，但是在下载&lt;strong&gt;脚本&lt;/strong&gt;时，即使使用不同的主机名，浏览器也不会启动任何其他下载&lt;/p&gt;
&lt;p&gt;defer脚本表示脚本不包含document.write，浏览器可以继续渲染&lt;/p&gt;
&lt;p&gt;通常一个脚本如果可以defered，那它也可以移动到页面底部&lt;/p&gt;
&lt;h3 id=&quot;Make-JavaScript-and-CSS-External-从外部引用js脚本和css文件&quot;&gt;&lt;a href=&quot;#Make-JavaScript-and-CSS-External-从外部引用js脚本和css文件&quot; class=&quot;headerlink&quot; title=&quot;Make JavaScript and CSS External 从外部引用js脚本和css文件&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#external&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Make JavaScript and CSS External&lt;/a&gt; 从外部引用js脚本和css文件&lt;/h3&gt;&lt;p&gt;在HTML文档中内嵌的JavaScript和CSS会在每次请求HTML文档时被下载&lt;/p&gt;
&lt;p&gt;使用外部文件通常会产生更快的页面，因为JavaScript和CSS文件被浏览器缓存&lt;/p&gt;
&lt;p&gt;如果JavaScript和CSS在外部文件中，并且被浏览器缓存，则在不增加HTTP请求次数的情况下减小了HTML文档的大小&lt;/p&gt;
&lt;p&gt;如果用户每次会话都有多个页面浏览，并且许多页面重复使用相同的脚本和样式表，那么缓存外部文件的潜在好处就更大&lt;/p&gt;
&lt;p&gt;对于主页，这种每次会话只访问一次的页面，将js和css内联可能更好&lt;/p&gt;
&lt;p&gt;一个样例：&lt;/p&gt;
&lt;p&gt;对于许多浏览页面的第一个页面，内联js和css（减少请求次数，该页面&lt;strong&gt;加载完后动态下载&lt;/strong&gt;外部文件，随后访问的页面会使用这些&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Minify-JavaScript-and-CSS-压缩JavaScript和CSS&quot;&gt;&lt;a href=&quot;#Minify-JavaScript-and-CSS-压缩JavaScript和CSS&quot; class=&quot;headerlink&quot; title=&quot;Minify JavaScript and CSS 压缩JavaScript和CSS&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#minify&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Minify JavaScript and CSS&lt;/a&gt; 压缩JavaScript和CSS&lt;/h3&gt;&lt;p&gt;压缩代码指的是删除不必要的代码，减小代码体积（因此可以提升响应性能&lt;/p&gt;
&lt;p&gt;混淆代码也是减小代码体积的方法，但是is more risky&lt;/p&gt;
&lt;p&gt;除了压缩外部脚本和样式之外，可以并且也应该压缩内联的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;块。&lt;/p&gt;
&lt;p&gt;即使脚本和css文件已经被gzip了，压缩还能让它们的体积减少5%以上&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tool.oschina.net/jscompress&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在线压缩工具&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://yikayiyo.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="翻译" scheme="https://yikayiyo.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>网站性能提升最佳实践三</title>
    <link href="https://yikayiyo.github.io/2020/06/30/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%89/"/>
    <id>https://yikayiyo.github.io/2020/06/30/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%89/</id>
    <published>2020-06-30T02:08:46.000Z</published>
    <updated>2020-06-30T03:06:10.584Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink</a></p><ul><li>Content</li><li>Server</li><li>Cookie</li><li>CSS</li><li>JavaScript</li><li>Images</li><li>Mobile</li></ul><p>原文从七个方面总结网站性能提升。</p><p>本篇总结Cookie、CSS、Mobile方面。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Reduce-Cookie-Size-减小cookie大小"><a href="#Reduce-Cookie-Size-减小cookie大小" class="headerlink" title="Reduce Cookie Size 减小cookie大小"></a><a href="https://developer.yahoo.com/performance/rules.html#cookie_size" target="_blank" rel="noopener">Reduce Cookie Size</a> 减小cookie大小</h3><p>使用HTTP cookie的原因有多种，例如身份验证和个性化</p><p>服务器和浏览器通过HTTP headers交换有关cookie的信息</p><p>尽可能减小cookie的大小，有助于减少对用户响应时间的影响</p><h3 id="Use-Cookie-Free-Domains-for-Components-尽可能不使用cookie"><a href="#Use-Cookie-Free-Domains-for-Components-尽可能不使用cookie" class="headerlink" title="Use Cookie-Free Domains for Components 尽可能不使用cookie"></a><a href="https://developer.yahoo.com/performance/rules.html#cookie_free" target="_blank" rel="noopener">Use Cookie-Free Domains for Components</a> 尽可能不使用cookie</h3><p>确保使用无Cookie的请求来请求静态组件</p><p>创建一个子域并在其中托管所有静态组件</p><p>一些代理可能拒绝缓存带cookie的请求得到的组件</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="Put-Stylesheets-at-Top-样式文件放到顶部"><a href="#Put-Stylesheets-at-Top-样式文件放到顶部" class="headerlink" title="Put Stylesheets at Top 样式文件放到顶部"></a><a href="https://developer.yahoo.com/performance/rules.html#css_top" target="_blank" rel="noopener">Put Stylesheets at Top</a> 样式文件放到顶部</h3><p>将样式表放到HEAD可以让页面逐步呈现</p><h3 id="Avoid-CSS-Expressions-避免使用CSS表达式"><a href="#Avoid-CSS-Expressions-避免使用CSS表达式" class="headerlink" title="Avoid CSS Expressions 避免使用CSS表达式"></a><a href="https://developer.yahoo.com/performance/rules.html#css_expressions" target="_blank" rel="noopener">Avoid CSS Expressions</a> 避免使用CSS表达式</h3><p>css表达式可以动态的设置css属性</p><a id="more"></a><p>但是其调用次数过多，例如鼠标在页面上移动、放大缩小了窗口、页面滚动等</p><p>可以使用event handlers作为替代</p><h3 id="Choose-lt-link-gt-Over-import-使用link而不是-import"><a href="#Choose-lt-link-gt-Over-import-使用link而不是-import" class="headerlink" title="Choose <link> Over @import 使用link而不是@import"></a><a href="https://developer.yahoo.com/performance/rules.html#csslink" target="_blank" rel="noopener">Choose <code>&lt;link&gt;</code> Over @import</a> 使用link而不是@import</h3><p>In IE <code>@import</code> behaves the same as using <code>&lt;link&gt;</code> at the bottom of the page, so it’s best not to use it.</p><h3 id="Avoid-Filters-避免使用Filters"><a href="#Avoid-Filters-避免使用Filters" class="headerlink" title="Avoid Filters 避免使用Filters"></a><a href="https://developer.yahoo.com/performance/rules.html#no_filters" target="_blank" rel="noopener">Avoid Filters</a> 避免使用Filters</h3><p>IE专有的AlphaImageLoader过滤器旨在解决IE版本&lt;7的半透明真彩色PNG的问题。该过滤器的问题是，当图像被下载时，它会阻止渲染并冻结浏览器。它还会增加内存消耗，而且是按每个元素应用，而不是按每张图片应用，所以问题会成倍增加。</p><p>最好的办法是完全避免使用AlphaImageLoader，而使用优雅降级的PNG8代替，这些在IE中都是可以的。如果你实在需要AlphaImageLoader，请使用<code>_filter</code>，以免影响IE7以上用户。</p><h2 id="Mobile"><a href="#Mobile" class="headerlink" title="Mobile"></a>Mobile</h2><h3 id="Keep-Components-Under-25-KB-组件不超过25KB"><a href="#Keep-Components-Under-25-KB-组件不超过25KB" class="headerlink" title="Keep Components Under 25 KB 组件不超过25KB"></a><a href="https://developer.yahoo.com/performance/rules.html#under25" target="_blank" rel="noopener">Keep Components Under 25 KB</a> 组件不超过25KB</h3><p>此限制与以下事实有关：iPhone不会缓存大于25K的组件。</p><p>请注意，这是<strong>未压缩的大小</strong>。</p><p>缩小在这里非常重要，因为仅使用gzip可能还不够。</p><h3 id="Pack-Components-Into-a-Multipart-Document-打包组件"><a href="#Pack-Components-Into-a-Multipart-Document-打包组件" class="headerlink" title="Pack Components Into a Multipart Document 打包组件"></a><a href="https://developer.yahoo.com/performance/rules.html#multipart" target="_blank" rel="noopener">Pack Components Into a Multipart Document</a> 打包组件</h3><p>将组件打包到一个多部分的文档中，就像一封带有附件的电子邮件，它可以帮助你<strong>用一个HTTP请求获取多个组件</strong></p><p>HTTP requests are expensive！</p><p>使用这项技术时，首先检查用户代理是否支持（iphone就不支持</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Content&lt;/li&gt;
&lt;li&gt;Server&lt;/li&gt;
&lt;li&gt;Cookie&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;Images&lt;/li&gt;
&lt;li&gt;Mobile&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原文从七个方面总结网站性能提升。&lt;/p&gt;
&lt;p&gt;本篇总结Cookie、CSS、Mobile方面。&lt;/p&gt;
&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;h3 id=&quot;Reduce-Cookie-Size-减小cookie大小&quot;&gt;&lt;a href=&quot;#Reduce-Cookie-Size-减小cookie大小&quot; class=&quot;headerlink&quot; title=&quot;Reduce Cookie Size 减小cookie大小&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#cookie_size&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reduce Cookie Size&lt;/a&gt; 减小cookie大小&lt;/h3&gt;&lt;p&gt;使用HTTP cookie的原因有多种，例如身份验证和个性化&lt;/p&gt;
&lt;p&gt;服务器和浏览器通过HTTP headers交换有关cookie的信息&lt;/p&gt;
&lt;p&gt;尽可能减小cookie的大小，有助于减少对用户响应时间的影响&lt;/p&gt;
&lt;h3 id=&quot;Use-Cookie-Free-Domains-for-Components-尽可能不使用cookie&quot;&gt;&lt;a href=&quot;#Use-Cookie-Free-Domains-for-Components-尽可能不使用cookie&quot; class=&quot;headerlink&quot; title=&quot;Use Cookie-Free Domains for Components 尽可能不使用cookie&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#cookie_free&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Use Cookie-Free Domains for Components&lt;/a&gt; 尽可能不使用cookie&lt;/h3&gt;&lt;p&gt;确保使用无Cookie的请求来请求静态组件&lt;/p&gt;
&lt;p&gt;创建一个子域并在其中托管所有静态组件&lt;/p&gt;
&lt;p&gt;一些代理可能拒绝缓存带cookie的请求得到的组件&lt;/p&gt;
&lt;h2 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h2&gt;&lt;h3 id=&quot;Put-Stylesheets-at-Top-样式文件放到顶部&quot;&gt;&lt;a href=&quot;#Put-Stylesheets-at-Top-样式文件放到顶部&quot; class=&quot;headerlink&quot; title=&quot;Put Stylesheets at Top 样式文件放到顶部&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#css_top&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Put Stylesheets at Top&lt;/a&gt; 样式文件放到顶部&lt;/h3&gt;&lt;p&gt;将样式表放到HEAD可以让页面逐步呈现&lt;/p&gt;
&lt;h3 id=&quot;Avoid-CSS-Expressions-避免使用CSS表达式&quot;&gt;&lt;a href=&quot;#Avoid-CSS-Expressions-避免使用CSS表达式&quot; class=&quot;headerlink&quot; title=&quot;Avoid CSS Expressions 避免使用CSS表达式&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#css_expressions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Avoid CSS Expressions&lt;/a&gt; 避免使用CSS表达式&lt;/h3&gt;&lt;p&gt;css表达式可以动态的设置css属性&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://yikayiyo.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="翻译" scheme="https://yikayiyo.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>网站性能提升最佳实践二</title>
    <link href="https://yikayiyo.github.io/2020/06/29/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%BA%8C/"/>
    <id>https://yikayiyo.github.io/2020/06/29/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%BA%8C/</id>
    <published>2020-06-29T07:33:05.000Z</published>
    <updated>2020-06-29T09:25:34.061Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink</a></p><ul><li>Content</li><li>Server</li><li>Cookie</li><li>CSS</li><li>JavaScript</li><li>Images</li><li>Mobile</li></ul><p>原文从七个方面总结网站性能提升。</p><p>本篇总结Server方面。</p><h3 id="Use-a-Content-Delivery-Network-CDN-使用内容分发网络"><a href="#Use-a-Content-Delivery-Network-CDN-使用内容分发网络" class="headerlink" title="Use a Content Delivery Network (CDN)使用内容分发网络"></a><a href="https://developer.yahoo.com/performance/rules.html#cdn" target="_blank" rel="noopener">Use a Content Delivery Network (CDN)</a>使用内容分发网络</h3><p>用户到服务器的距离会影响响应时间，比如当我们访问美国的服务器和中国的服务器<br>用户80%-90%的<strong>响应时间</strong>用来下载页面上的内容<br>为了加速这个：</p><ul><li><p>不要轻易尝试将web应用改为分布式架构</p></li><li><p>可以尝试使用CDN，将静态内容分散（切换到CDN是个相对简单的代码变化，将极大地提高网站速度</p></li></ul><p>一个内容分发网络是<strong>分布在多地的服务器集合</strong>，可以更有效地向用户提供内容</p><h3 id="Add-Expires-or-Cache-Control-Header添加Expires或Cache-Control头"><a href="#Add-Expires-or-Cache-Control-Header添加Expires或Cache-Control头" class="headerlink" title="Add Expires or Cache-Control Header添加Expires或Cache-Control头"></a><a href="https://developer.yahoo.com/performance/rules.html#expires" target="_blank" rel="noopener">Add Expires or Cache-Control Header</a>添加Expires或Cache-Control头</h3><ol><li>对于静态组件，设置一个长期的Expires头，表示该请求“永不过期”</li><li>对于动态组件，使用适当的Cache-Control头，来帮助浏览器有条件的进行请求</li></ol><p>网页被首次访问时需要大量的HTTP请求，通过使用Expires头，可以使请求过的组件<u>可缓存</u>，避免后续访问时的重复请求。也就是说，这个操作是对后续的请求有影响</p><p>对于性能的提升，取决你对这个网站的访问频率</p><p>Web服务器在<strong>HTTP响应</strong>中添加的Expires头告诉客户端可以将组件缓存多长时间</p><p>如果使用了长期的Expires头，当组件发生改变时，组件名应该改变（构建阶段处理：将组件版本号加到组件名中</p><h3 id="Gzip-Components压缩组件"><a href="#Gzip-Components压缩组件" class="headerlink" title="Gzip Components压缩组件"></a><a href="https://developer.yahoo.com/performance/rules.html#gzip" target="_blank" rel="noopener">Gzip Components</a>压缩组件</h3><p>通过<strong>压缩HTTP响应</strong>来减少响应时间</p><a id="more"></a><p>HTTP请求头中要添加</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br></pre></td></tr></tbody></table></figure><p>服务器根据上面列出的方法之一压缩响应，并在响应头中添加下面的字段提醒客户端</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br></pre></td></tr></tbody></table></figure><p>服务器根据文件类型选择要压缩的内容，但通常非常有限</p><p>任何文本类型的响应都值得压缩</p><p>图片和PDF不应该压缩（因为已经压缩过了</p><p>压缩尽可能多的文件类型是减少页面重量page weight，加速用户体验的简单方法</p><h3 id="Configure-ETags配置实体标签"><a href="#Configure-ETags配置实体标签" class="headerlink" title="Configure ETags配置实体标签"></a><a href="https://developer.yahoo.com/performance/rules.html#etags" target="_blank" rel="noopener">Configure ETags</a>配置实体标签</h3><p>当要确定缓存的内容和服务器中的内容是否一致时，实体标签是比最后修改时间（last-modified date）更完备的机制</p><p>实体标签是唯一标识特定版本组件的字符串，唯一格式限制是要使用引号引起来</p><p>一个例子：</p><p>服务器发回响应如下</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Last-Modified</span>: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line"><span class="attribute">ETag</span>: "10c24bc-4ab-457e1c1f"</span><br><span class="line"><span class="attribute">Content-Length</span>: 12195</span><br></pre></td></tr></tbody></table></figure><p>过一会客户端要验证内容，就发送下面的请求，其中If-None-Match中就是要验证的实体标签</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/i/yahoo.gif</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: us.yimg.com</span><br><span class="line"><span class="attribute">If-Modified-Since</span>: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line"><span class="attribute">If-None-Match</span>: "10c24bc-4ab-457e1c1f"</span><br></pre></td></tr></tbody></table></figure><p>如果标签得到匹配，服务器会返回一个304响应，表示Not Modified</p><p>网站服务器是集群的情况，这项技术不推荐使用，因为：</p><blockquote><p>The problem with ETags is that they typically are constructed using attributes that make them unique to a specific server hosting a site. ETags won’t match when a browser gets the original component from one server and later tries to validate that component on a different server, a situation that is all too common on Web sites that use a cluster of servers to handle requests. By default, both Apache and IIS embed data in the ETag that dramatically reduces the odds of the validity test succeeding on web sites with multiple servers.</p></blockquote><p>Apache服务器删除ETag的方法：</p><ul><li><p>在配置文件添加一行 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileETag none</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="Flush-Buffer-Early尽早刷新输出缓存"><a href="#Flush-Buffer-Early尽早刷新输出缓存" class="headerlink" title="Flush Buffer Early尽早刷新输出缓存"></a><a href="https://developer.yahoo.com/performance/rules.html#flush" target="_blank" rel="noopener">Flush Buffer Early</a>尽早刷新输出缓存</h3><p><a href="https://www.php.net/flush" target="_blank" rel="noopener">flush()</a> 函数允许将部分就绪的HTML响应发送回浏览器，以便浏览器可以在服务器忙于处理其它HTML时就开始获取组件</p><p>flushing的最佳位置是head标签之后，如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  ... &lt;!-- css, js --&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;?php flush(); ?&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  ... &lt;!-- content --&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="Use-GET-for-Ajax-Requests-使用GET处理Ajax请求"><a href="#Use-GET-for-Ajax-Requests-使用GET处理Ajax请求" class="headerlink" title="Use GET for Ajax Requests 使用GET处理Ajax请求"></a><a href="https://developer.yahoo.com/performance/rules.html#ajax_get" target="_blank" rel="noopener">Use GET for Ajax Requests</a> 使用GET处理Ajax请求</h3><p>在使用XMLHttpRequest时，POST在浏览器中的实现分为两步：先发送头文件，再发送数据。</p><p>因此最好使用GET请求，它只使用一个TCP包就可以发送（除非有很多cookie</p><p>POST without posting any data behaves like GET.</p><h3 id="Avoid-Empty-Image-src-避免空src属性"><a href="#Avoid-Empty-Image-src-避免空src属性" class="headerlink" title="Avoid Empty Image src 避免空src属性"></a><a href="https://developer.yahoo.com/performance/rules.html#emptysrc" target="_blank" rel="noopener">Avoid Empty Image src</a> 避免空src属性</h3><p>两种形式的空src属性</p><ol><li><p>html</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="string">""</span>;</span><br></pre></td></tr></tbody></table></figure></li></ol><p>都会导致：浏览器再次向服务器发送一次请求</p><p>造成这个行为的根本原因是：在浏览器中执行URI解析的方式，浏览器会将空字符串视为一条相对URI，然后进行解析</p><p>HTML5增加了约束，src属性必须非空</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Content&lt;/li&gt;
&lt;li&gt;Server&lt;/li&gt;
&lt;li&gt;Cookie&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;Images&lt;/li&gt;
&lt;li&gt;Mobile&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原文从七个方面总结网站性能提升。&lt;/p&gt;
&lt;p&gt;本篇总结Server方面。&lt;/p&gt;
&lt;h3 id=&quot;Use-a-Content-Delivery-Network-CDN-使用内容分发网络&quot;&gt;&lt;a href=&quot;#Use-a-Content-Delivery-Network-CDN-使用内容分发网络&quot; class=&quot;headerlink&quot; title=&quot;Use a Content Delivery Network (CDN)使用内容分发网络&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#cdn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Use a Content Delivery Network (CDN)&lt;/a&gt;使用内容分发网络&lt;/h3&gt;&lt;p&gt;用户到服务器的距离会影响响应时间，比如当我们访问美国的服务器和中国的服务器&lt;br&gt;用户80%-90%的&lt;strong&gt;响应时间&lt;/strong&gt;用来下载页面上的内容&lt;br&gt;为了加速这个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不要轻易尝试将web应用改为分布式架构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以尝试使用CDN，将静态内容分散（切换到CDN是个相对简单的代码变化，将极大地提高网站速度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个内容分发网络是&lt;strong&gt;分布在多地的服务器集合&lt;/strong&gt;，可以更有效地向用户提供内容&lt;/p&gt;
&lt;h3 id=&quot;Add-Expires-or-Cache-Control-Header添加Expires或Cache-Control头&quot;&gt;&lt;a href=&quot;#Add-Expires-or-Cache-Control-Header添加Expires或Cache-Control头&quot; class=&quot;headerlink&quot; title=&quot;Add Expires or Cache-Control Header添加Expires或Cache-Control头&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#expires&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Add Expires or Cache-Control Header&lt;/a&gt;添加Expires或Cache-Control头&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;对于静态组件，设置一个长期的Expires头，表示该请求“永不过期”&lt;/li&gt;
&lt;li&gt;对于动态组件，使用适当的Cache-Control头，来帮助浏览器有条件的进行请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网页被首次访问时需要大量的HTTP请求，通过使用Expires头，可以使请求过的组件&lt;u&gt;可缓存&lt;/u&gt;，避免后续访问时的重复请求。也就是说，这个操作是对后续的请求有影响&lt;/p&gt;
&lt;p&gt;对于性能的提升，取决你对这个网站的访问频率&lt;/p&gt;
&lt;p&gt;Web服务器在&lt;strong&gt;HTTP响应&lt;/strong&gt;中添加的Expires头告诉客户端可以将组件缓存多长时间&lt;/p&gt;
&lt;p&gt;如果使用了长期的Expires头，当组件发生改变时，组件名应该改变（构建阶段处理：将组件版本号加到组件名中&lt;/p&gt;
&lt;h3 id=&quot;Gzip-Components压缩组件&quot;&gt;&lt;a href=&quot;#Gzip-Components压缩组件&quot; class=&quot;headerlink&quot; title=&quot;Gzip Components压缩组件&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#gzip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gzip Components&lt;/a&gt;压缩组件&lt;/h3&gt;&lt;p&gt;通过&lt;strong&gt;压缩HTTP响应&lt;/strong&gt;来减少响应时间&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://yikayiyo.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="翻译" scheme="https://yikayiyo.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>网站性能提升最佳实践一</title>
    <link href="https://yikayiyo.github.io/2020/06/22/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%80/"/>
    <id>https://yikayiyo.github.io/2020/06/22/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%80/</id>
    <published>2020-06-22T14:51:53.000Z</published>
    <updated>2020-06-29T07:30:35.886Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink</a></p><ul><li>Content</li><li>Server</li><li>Cookie</li><li>CSS</li><li>JavaScript</li><li>Images</li><li>Mobile</li></ul><p>原文从七个方面总结网站性能提升。</p><p>本篇总结Content方面。</p><h3 id="Make-Fewer-HTTP-Requests-减少HTTP请求"><a href="#Make-Fewer-HTTP-Requests-减少HTTP请求" class="headerlink" title="Make Fewer HTTP Requests 减少HTTP请求"></a><a href="https://developer.yahoo.com/performance/rules.html#num_http" target="_blank" rel="noopener">Make Fewer HTTP Requests</a> 减少HTTP请求</h3><p>减少页面的组件数量，可以减少HTTP请求数量。</p><p>减少页面组件的方法：</p><ul><li><p>精简页面设计</p></li><li><p>不简化设计的情况下：</p><ul><li>文件组合（js文件放到一个里面，css文件放到一个里面）</li></ul></li><li><p><a href="https://css-tricks.com/css-sprites/" target="_blank" rel="noopener">CSS Sprites</a>：背景图片合并成一张，利用css属性设置各个部分到相对应的页面</p><ul><li><a href="https://css-tricks.com/examples/CSSClip/" target="_blank" rel="noopener">CSS Sprites with Inline Images</a> 也可以用来处理图片</li></ul></li><li><p>将内联图片放到css文件中（ Combining inline images into your cached stylesheets is a way to reduce HTTP requests and avoid increasing the size of your pages ？How ? ( Todo: find demo</p></li></ul><h3 id="Reduce-DNS-Lookups-减少DNS查询"><a href="#Reduce-DNS-Lookups-减少DNS查询" class="headerlink" title="Reduce DNS Lookups 减少DNS查询"></a><a href="https://developer.yahoo.com/performance/rules.html#dns_lookups" target="_blank" rel="noopener">Reduce DNS Lookups</a> 减少DNS查询</h3><p>减少网站的主机名（hostnames），可以减少DNS查询次数</p><p>但是减少网站主机名会减少页面的并发下载量</p><blockquote><p>Trade-off：Avoiding DNS lookups cuts response times, but reducing parallel downloads may increase response times. </p></blockquote><p> Guide：Split components across <strong>at least two but no more than four</strong> hostnames.</p><h3 id="Avoid-Redirects-避免网站重定向"><a href="#Avoid-Redirects-避免网站重定向" class="headerlink" title="Avoid Redirects 避免网站重定向"></a><a href="https://developer.yahoo.com/performance/rules.html#redirects" target="_blank" rel="noopener">Avoid Redirects</a> 避免网站重定向</h3><p>最经常发生的重定向：应该加/的地方没有加/</p><p>重定向可以用来从旧网站跳转到新网站</p><p>重定向也可以用来连接网站的不同部分、根据特定情况让用户跳转</p><p>解决办法：</p><ul><li><p>如果两个网站在同一个服务器，使用 <code>Alias and mod_rewrite</code></p></li><li><p>如果是网站换了个新域名，创建一个CNAME (a DNS record that creates an alias pointing from one domain name to another)，结合<code>Alias or mod_rewrite</code></p></li></ul><h3 id="Make-Ajax-Cacheable-缓存Ajax请求"><a href="#Make-Ajax-Cacheable-缓存Ajax请求" class="headerlink" title="Make Ajax Cacheable 缓存Ajax请求"></a><a href="https://developer.yahoo.com/performance/rules.html#cacheajax" target="_blank" rel="noopener">Make Ajax Cacheable</a> 缓存Ajax请求</h3><p><strong>异步不等于即时</strong></p><p>优化异步请求：</p><ul><li>缓存Ajax请求</li></ul><a id="more"></a><h4 id="何时使用旧的响应，何时发送新的请求？"><a href="#何时使用旧的响应，何时发送新的请求？" class="headerlink" title="何时使用旧的响应，何时发送新的请求？"></a>何时使用旧的响应，何时发送新的请求？</h4><blockquote><p>This could be done by adding a timestamp to the address book Ajax URL indicating the last time the user modified her address book, for example, &amp;t=1190241612. If the address book hasn’t been modified since the last download, the timestamp will be the same and the address book will be read from the browser’s cache eliminating an extra HTTP roundtrip. If the user has modified her address book, the timestamp ensures the new URL doesn’t match the cached response, and the browser will request the updated address book entries.</p></blockquote><h3 id="Postload-Components"><a href="#Postload-Components" class="headerlink" title="Postload Components"></a><a href="https://developer.yahoo.com/performance/rules.html#postload" target="_blank" rel="noopener">Postload Components</a></h3><p>非必须的组件延迟加载，比如一些js代码、用户点击后才显示的内容、文件夹里面的图片</p><p>确保页面正常工作，然后通过一些延迟加载的脚本增强页面上的体验，比如动画、拖放</p><h3 id="Preload-Components"><a href="#Preload-Components" class="headerlink" title="Preload Components"></a><a href="https://developer.yahoo.com/performance/rules.html#preload" target="_blank" rel="noopener">Preload Components</a></h3><p>利用计算机的闲置时间，预加载将来需要的内容</p><ol><li><p>无条件的</p><p>只要打开某网站就加载一些额外的组件。</p><p>打开google.com，总会预加载之后搜索界面的图片</p></li><li><p>有条件的</p><p>搜索框输入内容就会预加载内容</p></li><li><p>预期中的</p><p>上线网站新设计时预加载可以不影响用户体验</p></li></ol><h3 id="Reduce-the-Number-of-DOM-Elements"><a href="#Reduce-the-Number-of-DOM-Elements" class="headerlink" title="Reduce the Number of DOM Elements"></a><a href="https://developer.yahoo.com/performance/rules.html#min_dom" target="_blank" rel="noopener">Reduce the Number of DOM Elements</a></h3><p>页面tag数量</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>).length</span><br></pre></td></tr></tbody></table></figure><p>只有在语义上有意义时，才使用<code>&lt;div&gt;</code>（ 因为它总会添加一行</p><h4 id="有多少个DOM元素才算多呢？"><a href="#有多少个DOM元素才算多呢？" class="headerlink" title="有多少个DOM元素才算多呢？"></a>有多少个DOM元素才算多呢？</h4><p>检查其他类似的页面，然后比较。</p><h3 id="Split-Components-Across-Domains"><a href="#Split-Components-Across-Domains" class="headerlink" title="Split Components Across Domains"></a><a href="https://developer.yahoo.com/performance/rules.html#split" target="_blank" rel="noopener">Split Components Across Domains</a></h3><p>拆分组件可以最大限度地实现并行下载</p><p>确保使用的域名数量不超过2-4个，因为DNS查询惩罚</p><p>例子：</p><p>将HTML文件和动态内容托管在<a href="http://www.example.org，并在static1.example.org和static2.example.org上拆分部署静态组件" target="_blank" rel="noopener">www.example.org，并在static1.example.org和static2.example.org上拆分部署静态组件</a></p><h3 id="Minimize-Number-of-iframes"><a href="#Minimize-Number-of-iframes" class="headerlink" title="Minimize Number of iframes"></a><a href="https://developer.yahoo.com/performance/rules.html#iframes" target="_blank" rel="noopener">Minimize Number of iframes</a></h3><p><code>&lt;iframe&gt;</code> 优点：</p><ul><li>Helps with slow third-party content like badges and ads</li><li>Security sandbox</li><li>Download scripts in parallel</li></ul><p><code>&lt;iframe&gt;</code> 缺点：</p><ul><li>Costly even if blank</li><li>Blocks page onload</li><li>Non-semantic</li></ul><h3 id="Avoid-404s"><a href="#Avoid-404s" class="headerlink" title="Avoid 404s"></a><a href="https://developer.yahoo.com/performance/rules.html#no404" target="_blank" rel="noopener">Avoid 404s</a></h3><p>HTTP请求是很昂贵的，提出HTTP请求，得到一个无用的响应（即404 Not Found）是完全没有必要的，而且会拖慢用户体验，没有任何好处。</p><p><strong>Particularly bad</strong> is when the link to an external JavaScript is wrong and the result is a 404. First, this download will block parallel downloads. Next the browser may try to parse the 404 response body as if it were JavaScript code, trying to find something usable in it.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Content&lt;/li&gt;
&lt;li&gt;Server&lt;/li&gt;
&lt;li&gt;Cookie&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;Images&lt;/li&gt;
&lt;li&gt;Mobile&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原文从七个方面总结网站性能提升。&lt;/p&gt;
&lt;p&gt;本篇总结Content方面。&lt;/p&gt;
&lt;h3 id=&quot;Make-Fewer-HTTP-Requests-减少HTTP请求&quot;&gt;&lt;a href=&quot;#Make-Fewer-HTTP-Requests-减少HTTP请求&quot; class=&quot;headerlink&quot; title=&quot;Make Fewer HTTP Requests 减少HTTP请求&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#num_http&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Make Fewer HTTP Requests&lt;/a&gt; 减少HTTP请求&lt;/h3&gt;&lt;p&gt;减少页面的组件数量，可以减少HTTP请求数量。&lt;/p&gt;
&lt;p&gt;减少页面组件的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;精简页面设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不简化设计的情况下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件组合（js文件放到一个里面，css文件放到一个里面）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://css-tricks.com/css-sprites/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSS Sprites&lt;/a&gt;：背景图片合并成一张，利用css属性设置各个部分到相对应的页面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/examples/CSSClip/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSS Sprites with Inline Images&lt;/a&gt; 也可以用来处理图片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将内联图片放到css文件中（ Combining inline images into your cached stylesheets is a way to reduce HTTP requests and avoid increasing the size of your pages ？How ? ( Todo: find demo&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Reduce-DNS-Lookups-减少DNS查询&quot;&gt;&lt;a href=&quot;#Reduce-DNS-Lookups-减少DNS查询&quot; class=&quot;headerlink&quot; title=&quot;Reduce DNS Lookups 减少DNS查询&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#dns_lookups&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reduce DNS Lookups&lt;/a&gt; 减少DNS查询&lt;/h3&gt;&lt;p&gt;减少网站的主机名（hostnames），可以减少DNS查询次数&lt;/p&gt;
&lt;p&gt;但是减少网站主机名会减少页面的并发下载量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Trade-off：Avoiding DNS lookups cuts response times, but reducing parallel downloads may increase response times. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; Guide：Split components across &lt;strong&gt;at least two but no more than four&lt;/strong&gt; hostnames.&lt;/p&gt;
&lt;h3 id=&quot;Avoid-Redirects-避免网站重定向&quot;&gt;&lt;a href=&quot;#Avoid-Redirects-避免网站重定向&quot; class=&quot;headerlink&quot; title=&quot;Avoid Redirects 避免网站重定向&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#redirects&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Avoid Redirects&lt;/a&gt; 避免网站重定向&lt;/h3&gt;&lt;p&gt;最经常发生的重定向：应该加/的地方没有加/&lt;/p&gt;
&lt;p&gt;重定向可以用来从旧网站跳转到新网站&lt;/p&gt;
&lt;p&gt;重定向也可以用来连接网站的不同部分、根据特定情况让用户跳转&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果两个网站在同一个服务器，使用 &lt;code&gt;Alias and mod_rewrite&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果是网站换了个新域名，创建一个CNAME (a DNS record that creates an alias pointing from one domain name to another)，结合&lt;code&gt;Alias or mod_rewrite&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Make-Ajax-Cacheable-缓存Ajax请求&quot;&gt;&lt;a href=&quot;#Make-Ajax-Cacheable-缓存Ajax请求&quot; class=&quot;headerlink&quot; title=&quot;Make Ajax Cacheable 缓存Ajax请求&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#cacheajax&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Make Ajax Cacheable&lt;/a&gt; 缓存Ajax请求&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;异步不等于即时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优化异步请求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存Ajax请求&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://yikayiyo.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="翻译" scheme="https://yikayiyo.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>surface测试</title>
    <link href="https://yikayiyo.github.io/2020/06/18/surface%E6%B5%8B%E8%AF%95/"/>
    <id>https://yikayiyo.github.io/2020/06/18/surface%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-18T09:21:24.000Z</published>
    <updated>2020-06-18T09:25:42.976Z</updated>
    
    <content type="html"><![CDATA[<p>surface上写博客，完事之后各端同步测试。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;surface上写博客，完事之后各端同步测试。&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.da
      
    
    </summary>
    
    
    
      <category term="杂" scheme="https://yikayiyo.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>git修改最近一次commit的信息</title>
    <link href="https://yikayiyo.github.io/2020/06/18/git%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
    <id>https://yikayiyo.github.io/2020/06/18/git%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%E7%9A%84%E4%BF%A1%E6%81%AF/</id>
    <published>2020-06-18T05:29:00.000Z</published>
    <updated>2020-06-18T05:40:50.201Z</updated>
    
    <content type="html"><![CDATA[<p>最近一次提交的信息不太对，已经push到远端。</p><img src="/2020/06/18/git%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%E7%9A%84%E4%BF%A1%E6%81%AF/xiugaiqian.png" class="" title="修改前"><p>修改步骤：</p><ol><li><p>输入命令，会进入编辑器</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改commit信息，退出编辑器</p></li><li><p>强制推送</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></tbody></table></figure></li></ol><p>修改后：</p><img src="/2020/06/18/git%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%E7%9A%84%E4%BF%A1%E6%81%AF/xiugaihou.png" class="" title="修改后"><p>注意到：<strong>commit号改变了</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一次提交的信息不太对，已经push到远端。&lt;/p&gt;
&lt;img src=&quot;/2020/06/18/git%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%E7%9A%84%E4%BF%A1%E6%81
      
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git" scheme="https://yikayiyo.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>几则笑话</title>
    <link href="https://yikayiyo.github.io/2020/02/22/%E5%87%A0%E5%88%99%E7%AC%91%E8%AF%9D/"/>
    <id>https://yikayiyo.github.io/2020/02/22/%E5%87%A0%E5%88%99%E7%AC%91%E8%AF%9D/</id>
    <published>2020-02-22T12:41:23.000Z</published>
    <updated>2020-06-22T12:49:57.606Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/02/22/%E5%87%A0%E5%88%99%E7%AC%91%E8%AF%9D/0222fig1.png" class="" title="weibo"><img src="/2020/02/22/%E5%87%A0%E5%88%99%E7%AC%91%E8%AF%9D/0222fig2.png" class="" title="weiboJinggao"><p>看到这则信息，下面有人举了几个前苏联的笑话，感觉很有意思，于是就去找了几个，笑得肚子疼。</p><blockquote><p>有个人在红场散发传单，被克格勃逮住了。那人辩解，我发的都是白纸。克格勃冷笑道，你以为我不知道你什么意思？</p></blockquote><blockquote><p>在苏共二十三次代表大会上，勃列日涅夫作报告，他问：“我们这里有没有敌人？”一个人回答：“有一个，他坐在第四排第十八号位子上。”勃问：“为什么他是敌人？”回答：“列宁说过敌人是不会打瞌睡的，我发现全场只有他一个人没有打瞌睡！”</p></blockquote><blockquote><p>“在苏联是否可以存在两党制？”“不，不可能，因为我们养不起。”</p></blockquote><blockquote><p>苏联特工对美国特工夸口道：“我们知道你们国家所有核导弹发射井的位置。”美国特工说：“那又有什么，我们知道你们未来20年全体政治局委员名单。”</p></blockquote><blockquote><p>一天戈尔巴乔夫到一个农场视察，看到有几头猪，就到猪旁边拍了一张照片。随行人员在照片上写上：戈尔巴乔夫和猪在一起，但又感到不妥。于是改成：猪和戈尔巴乔夫在一起，可还是感觉不对。最后把照片上的字改成：左起第三位是戈尔巴乔夫。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/02/22/%E5%87%A0%E5%88%99%E7%AC%91%E8%AF%9D/0222fig1.png&quot; class=&quot;&quot; title=&quot;weibo&quot;&gt;

&lt;img src=&quot;/2020/02/22/%E5%87%A0%E5%88%99%E
      
    
    </summary>
    
    
    
      <category term="杂" scheme="https://yikayiyo.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>健康的武汉</title>
    <link href="https://yikayiyo.github.io/2020/02/11/%E5%81%A5%E5%BA%B7%E7%9A%84%E6%AD%A6%E6%B1%89/"/>
    <id>https://yikayiyo.github.io/2020/02/11/%E5%81%A5%E5%BA%B7%E7%9A%84%E6%AD%A6%E6%B1%89/</id>
    <published>2020-02-11T12:35:30.000Z</published>
    <updated>2020-06-22T12:37:37.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个健康的社会不该只有一种声音。</p></blockquote><p>哪里也去不了，就不停地刷屏。</p><p>医护人员在医院休息室嚎啕大哭，火化工人在殡仪馆唱歌给自己打气，主妇在阳台上绝望地哭喊救命，电话里快要崩溃的发自党性的咆哮…</p><p>房间的门被焊被锁被堵，外出的车队在高速上排成长龙，为了活命想偷渡到隔壁省却发现河对岸一排一排的人在围追堵截…</p><p>和新闻里的完全不一样。</p><p>我听到了两种声音。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一个健康的社会不该只有一种声音。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;哪里也去不了，就不停地刷屏。&lt;/p&gt;
&lt;p&gt;医护人员在医院休息室嚎啕大哭，火化工人在殡仪馆唱歌给自己打气，主妇在阳台上绝望地哭喊救命，电话里快要崩溃的发自党性的咆哮…&lt;/p
      
    
    </summary>
    
    
    
      <category term="杂" scheme="https://yikayiyo.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>Data flow Synchronization and Pipelining</title>
    <link href="https://yikayiyo.github.io/2020/01/16/Pipelining/"/>
    <id>https://yikayiyo.github.io/2020/01/16/Pipelining/</id>
    <published>2020-01-16T04:02:58.000Z</published>
    <updated>2020-01-16T06:04:22.838Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.coursera.org/learn/parallel-programming-in-java/" target="_blank" rel="noopener">https://www.coursera.org/learn/parallel-programming-in-java/</a></p><h3 id="Split-phase-Barriers-with-Java-Phasers"><a href="#Split-phase-Barriers-with-Java-Phasers" class="headerlink" title="Split-phase Barriers with Java Phasers"></a>Split-phase Barriers with Java Phasers</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/parallel-programming-in-java/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.coursera.org/learn/para
      
    
    </summary>
    
    
    
      <category term="java" scheme="https://yikayiyo.github.io/tags/java/"/>
    
      <category term="并行编程" scheme="https://yikayiyo.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="学习" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Loop Parallelism</title>
    <link href="https://yikayiyo.github.io/2020/01/13/Loop%20Parallelism/"/>
    <id>https://yikayiyo.github.io/2020/01/13/Loop%20Parallelism/</id>
    <published>2020-01-13T05:49:17.000Z</published>
    <updated>2020-01-19T08:10:19.891Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Parallel-Loops"><a href="#Parallel-Loops" class="headerlink" title="Parallel Loops"></a>Parallel Loops</h3><p>未知循环次数，利用了指针的for循环<br>每一个迭代当作一个子任务，<code>finish</code>约束整个循环</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finish {</span><br><span class="line">    <span class="keyword">for</span> (p = head; p != <span class="keyword">null</span> ; p = p.next) </span><br><span class="line">        <span class="function">async <span class="title">compute</span><span class="params">(p)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>已知循环次数n，可以利用<code>forall</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector addition</span></span><br><span class="line">forall (i : [<span class="number">0</span>:n-<span class="number">1</span>]) </span><br><span class="line">    a[i] = b[i] + c[i]</span><br></pre></td></tr></tbody></table></figure><p>利用 Java streams，上述功能有更加简洁的表达方式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">a = IntStream.rangeClosed(<span class="number">0</span>, N-<span class="number">1</span>).parallel().toArray(i -&gt; b[i] + c[i]);</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h3 id="Parallel-Matrix-Multiplication"><a href="#Parallel-Matrix-Multiplication" class="headerlink" title="Parallel Matrix Multiplication"></a>Parallel Matrix Multiplication</h3><p>假设两个<code>n*n</code>的矩阵相乘，有</p><p>$$<br>c[i][j] = \sum_{k=0}^{n-1} a[i][k] * b[k][j]<br>$$<br>伪代码表示为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i : [<span class="number">0</span>:n-<span class="number">1</span>]) {</span><br><span class="line">  <span class="keyword">for</span>(j : [<span class="number">0</span>:n-<span class="number">1</span>]) { c[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(k : [<span class="number">0</span>:n-<span class="number">1</span>]) {</span><br><span class="line">      c[i][j] = c[i][j] + a[i][k]*b[k][j]</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>要替换成并行计算，可以简单地将外两层的for循环改成<code>forall</code></p><p>for-k 必须是线性的，因为这里有写数据（data race</p><h3 id="Barriers-in-Parallel-Loops"><a href="#Barriers-in-Parallel-Loops" class="headerlink" title="Barriers in Parallel Loops"></a>Barriers in Parallel Loops</h3><p>下面有一个简单的并行任务</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forall (i : [<span class="number">0</span>:n-<span class="number">1</span>]) {</span><br><span class="line">    myId = lookup(i); <span class="comment">// convert int to a string </span></span><br><span class="line">    print HELLO, myId;</span><br><span class="line">    print BYE, myId;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在不同的执行下会有不同顺序的结果（相同myId对应的HELLO一定在BYE之前</p><p>barriers可以将一个parallel loop分为不同的阶段</p><p>在两个print之间插入一个barrier，可以保证所有的HELLO出现在BYE之前</p><p>两种写法：</p><ul><li><p>在一个<code>forall</code>循环中插入barriers分为不同的阶段 (两个对应的print共享myId</p></li><li><p>为每个阶段写自己的<code>forall</code>循环 (借助 intermediate data structure  to communicate the myId values from one <em>forall</em> to another <em>forall</em> </p></li></ul><h3 id="Parallel-One-Dimensional-Iterative-Averaging"><a href="#Parallel-One-Dimensional-Iterative-Averaging" class="headerlink" title="Parallel One-Dimensional Iterative Averaging"></a>Parallel One-Dimensional Iterative Averaging</h3><p>Solve the recurrence<br>$$<br>X_i=\frac{X_{i-1}+X_{i+1}}2<br>$$</p><p>with boundary conditions<br>$$<br>X_0=0\ and\ X_n=1<br>$$</p><p><a href="https://en.wikipedia.org/wiki/Jacobi_method" target="_blank" rel="noopener">Jacobi method</a>利用两个数组oldX[] and newX[]迭代求解该问题，并行伪代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (iter: [<span class="number">0</span>:nsteps-<span class="number">1</span>]) {</span><br><span class="line">  forall (i: [<span class="number">1</span>:n-<span class="number">1</span>]) {</span><br><span class="line">    newX[i] = (oldX[i-<span class="number">1</span>] + oldX[i+<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">  }</span><br><span class="line">  swap pointers newX and oldX;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述方法创建了 <em>nsteps</em> <em>×</em> (<em>n</em> <em>−</em> 1) 个任务</p><p><strong>使用Barriers可以减少需要创建的任务个数</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">forall ( i: [<span class="number">1</span>:n-<span class="number">1</span>]) {</span><br><span class="line">  <span class="keyword">for</span> (iter: [<span class="number">0</span>:nsteps-<span class="number">1</span>]) {</span><br><span class="line">    newX[i] = (oldX[i-<span class="number">1</span>] + oldX[i+<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">    NEXT; <span class="comment">// Barrier</span></span><br><span class="line">    swap pointers newX and oldX;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述方法只需要创建 <em>(n-1)</em> 个任务</p><p>This is a significant improvement since creating tasks is usually more expensive than performing barrier operations.</p><h3 id="Iteration-Grouping-Chunking-in-Parallel-Loops"><a href="#Iteration-Grouping-Chunking-in-Parallel-Loops" class="headerlink" title="Iteration Grouping/Chunking in Parallel Loops"></a>Iteration Grouping/Chunking in Parallel Loops</h3><p>对于向量相加问题</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forall (i : [<span class="number">0</span>:n-<span class="number">1</span>]) a[i] = b[i] + c[i]</span><br></pre></td></tr></tbody></table></figure><p>上述方法创建了n个任务，当n很大时overheads也会很大</p><p>解决方法</p><p><strong>分组</strong>（<em>loop</em> <em>chunking</em> or <em>iteration grouping</em></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forall (g:[<span class="number">0</span>:ng-<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">for</span> (i : mygroup(g, ng, [<span class="number">0</span>:n-<span class="number">1</span>])) a[i] = b[i] + c[i]</span><br></pre></td></tr></tbody></table></figure><p>上述方法将任务个数从 <strong>n</strong> 降到了 <strong>ng</strong>（分组个数</p><p>分组方法有两种：</p><ul><li>block<ul><li>将连续的迭代分为一组</li></ul></li><li>cyclic<ul><li>将同余类迭代（ iterations in the same congruence class，分为一组</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Parallel-Loops&quot;&gt;&lt;a href=&quot;#Parallel-Loops&quot; class=&quot;headerlink&quot; title=&quot;Parallel Loops&quot;&gt;&lt;/a&gt;Parallel Loops&lt;/h3&gt;&lt;p&gt;未知循环次数，利用了指针的for循环&lt;br&gt;每一个迭代当作一个子任务，&lt;code&gt;finish&lt;/code&gt;约束整个循环&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;finish {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (p = head; p != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ; p = p.next) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;async &lt;span class=&quot;title&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(p)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;已知循环次数n，可以利用&lt;code&gt;forall&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// vector addition&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;forall (i : [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a[i] = b[i] + c[i]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;利用 Java streams，上述功能有更加简洁的表达方式&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = IntStream.rangeClosed(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, N-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;).parallel().toArray(i -&amp;gt; b[i] + c[i]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://yikayiyo.github.io/tags/java/"/>
    
      <category term="并行编程" scheme="https://yikayiyo.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Functional Parallelism</title>
    <link href="https://yikayiyo.github.io/2020/01/10/Functional-Parallelism/"/>
    <id>https://yikayiyo.github.io/2020/01/10/Functional-Parallelism/</id>
    <published>2020-01-10T06:20:46.000Z</published>
    <updated>2020-01-19T07:38:55.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Future-Tasks"><a href="#Future-Tasks" class="headerlink" title="Future Tasks"></a><strong>Future Tasks</strong></h3><p><code>future tasks</code></p><ul><li>tasks with <strong>return values</strong></li></ul><p><code>future objects</code>（also known as <code>promise objects</code></p><ul><li><p>a “handle” for accessing a task’s return value</p></li><li><p>两个主要操作：</p><ul><li><p>Assignment，形式如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = future { </span><br><span class="line">    ⟨ task-with-<span class="keyword">return</span>-value ⟩ </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>future object 被限制为只能一次赋值（<em>single assignment</em>，类似于final变量</p><p>future task 完成后 future object就不能修改了</p></li><li><p>Blocking read</p><ul><li>A.get() 读操作会等待，直到与 future object 关联的 task 完成，将该任务的返回值作为 A.get() 的值</li><li>A.get() 之后的任何statement S 开始执行时与A关联的任务已经完成</li></ul></li></ul></li></ul><a id="more"></a><h3 id="Creating-Future-Tasks-in-Java’s-Fork-Join-Framework"><a href="#Creating-Future-Tasks-in-Java’s-Fork-Join-Framework" class="headerlink" title="Creating Future Tasks in Java’s Fork/Join Framework"></a><strong>Creating Future Tasks in Java’s Fork/Join Framework</strong></h3><p>future tasks和regular tasks的一些关键不同：</p><ol><li>future tasks 继承自FJ框架的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html" target="_blank" rel="noopener">RecursiveTask</a> 类，regular tasks 继承自 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveAction.html" target="_blank" rel="noopener">RecursiveAction</a> 类</li><li>future task 的 <strong>compute()</strong> 方法必须有 non-void 的返回值</li><li>*<em>left.join() *</em>这样的方法调用都会等left指向的任务执行，只是future task 有返回值</li></ol><h3 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a><strong>Memoization</strong></h3><p>记录f(x)的执行结果，防止重复计算</p><ol><li><p>创建特定的数据结构，记录<br>$$<br>{(x_1,y_1=f(x_1)),(x_2,y_2=f(x_2)),…}<br>$$</p></li><li><p>当出现 f 的调用时先在记录中查找</p></li></ol><p>future task在这里非常适合，记录的形式变为了<br>$$<br>{(x_1,y_1=future(f(x_1))),(x_2,y_2=future(f(x_2))),…}<br>$$</p><p>对于输入x，如果对应的future对象已经创建，则可以调用该对象的 get() 方法</p><h3 id="Java-Streams"><a href="#Java-Streams" class="headerlink" title="Java Streams"></a><strong>Java Streams</strong></h3><p>操作集合对象除了<code>for loop</code>还可以利用<code>Java streams</code>提供的API</p><p>下面的例子求注册学生的平均年龄</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">students.stream()</span><br><span class="line">    .filter(s -&gt; s.getStatus() == Student.ACTIVE)</span><br><span class="line">    .mapToInt(a -&gt; a.getAge())</span><br><span class="line">    .average();</span><br></pre></td></tr></tbody></table></figure><p>Java streams 提供了并行编程的API</p><p>上面代码的 <em>students.stream()</em> 替换为 <em>students.parallelStream()</em> 或者 <em>Stream.of(students).parallel()</em> 就可以了</p><h3 id="Determinism-and-Data-Races"><a href="#Determinism-and-Data-Races" class="headerlink" title="Determinism and Data Races"></a><strong>Determinism and Data Races</strong></h3><p><em>functionally deterministic</em></p><ul><li>A parallel program is said to be <em>functionally deterministic</em> if it always computes the same answer when given the same input</li></ul><p><em>structurally deterministic</em></p><ul><li>It always computes the same computation graph, when given the same input. </li></ul><p>没有数据竞争不足以保证确定性</p><p>有数据竞争也不意味着程序的不确定性</p><p>带有数据竞争的不确定程序，每次产生的结果不同，但是可能每个结果都是可接受的！！e.g., different locations for a search pattern in a target string</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Future-Tasks&quot;&gt;&lt;a href=&quot;#Future-Tasks&quot; class=&quot;headerlink&quot; title=&quot;Future Tasks&quot;&gt;&lt;/a&gt;&lt;strong&gt;Future Tasks&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;future tasks&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tasks with &lt;strong&gt;return values&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;future objects&lt;/code&gt;（also known as &lt;code&gt;promise objects&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a “handle” for accessing a task’s return value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个主要操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Assignment，形式如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A = future { &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ⟨ task-with-&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;-value ⟩ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;future object 被限制为只能一次赋值（&lt;em&gt;single assignment&lt;/em&gt;，类似于final变量&lt;/p&gt;
&lt;p&gt;future task 完成后 future object就不能修改了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Blocking read&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A.get() 读操作会等待，直到与 future object 关联的 task 完成，将该任务的返回值作为 A.get() 的值&lt;/li&gt;
&lt;li&gt;A.get() 之后的任何statement S 开始执行时与A关联的任务已经完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://yikayiyo.github.io/tags/java/"/>
    
      <category term="并行编程" scheme="https://yikayiyo.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Task Parallelism</title>
    <link href="https://yikayiyo.github.io/2020/01/08/Task%20Parallelism/"/>
    <id>https://yikayiyo.github.io/2020/01/08/Task%20Parallelism/</id>
    <published>2020-01-08T10:59:19.000Z</published>
    <updated>2020-01-09T11:58:58.049Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.coursera.org/learn/parallel-programming-in-java/" target="_blank" rel="noopener">https://www.coursera.org/learn/parallel-programming-in-java/</a></p><h3 id="Task-Creation-and-Termination-Async-Finish"><a href="#Task-Creation-and-Termination-Async-Finish" class="headerlink" title="Task Creation and Termination (Async, Finish)"></a>Task Creation and Termination (Async, Finish)</h3><p>以数组求和作为例子</p><p>为了求得数组的和，可以将数组分为前后两个部分。两部分的求和可以并行执行，但是在求总和之前要保证两个子任务已经完成。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">finish {</span><br><span class="line">  async SUM1;  <span class="comment">// asynchronously compute sum of the lower half of the array</span></span><br><span class="line">  SUM2;  <span class="comment">// compute sum of the upper half of the array in parallel with SUM1</span></span><br><span class="line">}</span><br><span class="line">SUM;  <span class="comment">// combine the two partial sums after both SUM1 and SUM2 have finished</span></span><br></pre></td></tr></tbody></table></figure><p><code>async &lt;stmt1&gt;</code> ：父任务创建子任务执行<code>&lt;stmt1&gt;</code>，并且是并行于父任务的其余部分执行</p><p>上面的伪代码中，<code>async SUM1;</code>创建子任务SUM1，和SUM2并行执行</p><p><code>finish &lt;stmt2&gt;</code>：父任务执行<code>&lt;stmt2&gt;</code>，并且等待<code>&lt;stmt2&gt;以及其中创建的异步任务</code>完成</p><p>上例中，父任务等待SUM1和SUM2完成，才能执行SUM</p><h3 id="Tasks-in-Java’s-Fork-Join-Framework"><a href="#Tasks-in-Java’s-Fork-Join-Framework" class="headerlink" title="Tasks in Java’s Fork/Join Framework"></a>Tasks in Java’s Fork/Join Framework</h3><p>数组求和的<strong>分治</strong>写法<a id="more"></a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ASum</span></span>{</span><br><span class="line">  <span class="keyword">int</span>[] A; <span class="comment">// input array</span></span><br><span class="line">  <span class="keyword">int</span> LO, HI; <span class="comment">// subrange</span></span><br><span class="line">  <span class="keyword">int</span> SUM; <span class="comment">// return value</span></span><br><span class="line">  ASum(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high){</span><br><span class="line">    <span class="keyword">this</span>.A = array;</span><br><span class="line">    <span class="keyword">this</span>.LO = low;</span><br><span class="line">    <span class="keyword">this</span>.HI = high;</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (LO==HI) SUM = A[LO];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LO&gt;HI) SUM = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">int</span> MID = (LO+HI)/<span class="number">2</span>;</span><br><span class="line">      L = <span class="keyword">new</span> ASum(A, LO, MID);</span><br><span class="line">      R = <span class="keyword">new</span> ASum(A, MID, HI);</span><br><span class="line">      L.compute();</span><br><span class="line">      R.compute();</span><br><span class="line">      SUM = L.SUM + R.SUM;</span><br><span class="line">    }</span><br><span class="line">  } <span class="comment">// compute()</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并行写法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASum</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>{  <span class="comment">//没有返回值的继承RecursiveAction，比如对数组排序</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> seqThreshold = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">int</span> lo, hi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ASum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.lo = low;</span><br><span class="line">        <span class="keyword">this</span>.hi = high;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((hi - lo) &lt;= seqThreshold) {  <span class="comment">//不再切分为子任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i++)</span><br><span class="line">                res += array[i];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            ASum L = <span class="keyword">new</span> ASum(array, lo, mid);</span><br><span class="line">            ASum R = <span class="keyword">new</span> ASum(array, mid, hi);</span><br><span class="line">            <span class="comment">// L.fork();</span></span><br><span class="line">            <span class="comment">// R.fork();</span></span><br><span class="line">            invokeAll(L, R);  <span class="comment">//和上面的两句等价</span></span><br><span class="line">            res += L.join() + R.join();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumOfInts</span><span class="params">(ForkJoinPool pool, <span class="keyword">int</span>[] array)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        ASum a = <span class="keyword">new</span> ASum(array, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> pool.invoke(a);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] nums = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> };</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        System.out.println(sumOfInts(pool, nums));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Computation-Graphs-Work-Span"><a href="#Computation-Graphs-Work-Span" class="headerlink" title="Computation Graphs, Work, Span"></a>Computation Graphs, Work, Span</h3><h4 id="Computation-Graphs"><a href="#Computation-Graphs" class="headerlink" title="Computation Graphs"></a>Computation Graphs</h4><p>Computation Graphs (CGs) model the execution of a parallel program as a <a href="http://en.wikipedia.org/wiki/Partially_ordered_set" target="_blank" rel="noopener">partially ordered set</a>.</p><p>A CG consist of:</p><ul><li>A set of <em>vertices</em> or <em>nodes</em>, in which each node represents a <em>step</em> consisting of an <strong>arbitrary sequential computation</strong>.</li><li>A set of <em>directed</em> <em>edges</em> that represent <strong>ordering constraints</strong> among steps.</li></ul><p>对于fork-join框架，可以将这些有向边分为三类：</p><ul><li><em>Continue</em> edges，连接任务中顺序执行的步骤</li><li>Fork edges，将fork操作连接到子任务的第一个步骤</li><li>join edges connect the last step of a task to all <em>join</em> operations on that task</li></ul><p>一个小例子</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S1</span><br><span class="line">fork S2</span><br><span class="line">S3</span><br><span class="line">join S2  <span class="comment">// 这里join S2发生在S4之前</span></span><br><span class="line">S4</span><br><span class="line"><span class="comment">// S5 如果有的话，连接到S4之后</span></span><br></pre></td></tr></tbody></table></figure><p>对应的CG为</p><img src="/2020/01/08/Task%20Parallelism/image-20200108094903279.png" class=""><h4 id="CGs上的data-race"><a href="#CGs上的data-race" class="headerlink" title="CGs上的data race"></a>CGs上的data race</h4><p>没有边连接的两个节点同时写或者读写相同的位置时发生data race</p><h4 id="CGs上的理想并行程度-（ideal-parallelism）"><a href="#CGs上的理想并行程度-（ideal-parallelism）" class="headerlink" title="CGs上的理想并行程度 （ideal parallelism）"></a>CGs上的理想并行程度 （<em>ideal parallelism</em>）</h4><p>与计算机的实际并行性无关<br>$$<br>ideal,parallelism = \frac{WORK(G)}{SPAN(G)} \tag{1}<br>$$</p><p>其中：</p><ul><li>WORK(G)为G中所有节点执行时间之和</li><li>SPAN(G)为G中关键路径上节点的执行时间之和，上例中SPAN(G)为 <strong>max((S1,S3,S4), (S1,S2,S4))</strong></li></ul><h3 id="Multiprocessor-Scheduling-Parallel-Speedup"><a href="#Multiprocessor-Scheduling-Parallel-Speedup" class="headerlink" title="Multiprocessor Scheduling, Parallel Speedup"></a>Multiprocessor Scheduling, Parallel Speedup</h3><h4 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h4><p>有P个处理器，每个处理器都相同，每一个节点的执行时间都是固定的（不管在那个处理器上），处理器都是<strong>贪心</strong>地执行任务<br>T_p表示在p个处理器上执行一个CG所花的时间,<br>相同的P个处理器，相同的CG，不同的调度算法也可能对应不同的T_p</p><p>$$<br>T_{\infty} \le T_p \le T_1<br>$$</p><h4 id="Speedup-P"><a href="#Speedup-P" class="headerlink" title="Speedup(P)"></a>Speedup(P)</h4><p>the parallel speedup for a given schedule of a CG on <em>P</em> processors，满足下面：<br>$$<br>Speedup(P) = \frac{T_1}{T_P} \tag{2}<br>$$</p><p>$$<br>Speedup(P) \le P \tag{3}<br>$$</p><p>$$<br>Speedup(P) \le \frac {WORK}{SPAN} \tag{4}<br>$$</p><p>（3）表示P个处理器不能带来P倍的加速</p><p>（4）表示现实骨感，理想丰满</p><h3 id="Amdahl’s-Law"><a href="#Amdahl’s-Law" class="headerlink" title="Amdahl’s Law"></a><strong>Amdahl’s Law</strong></h3><p>if <em>q</em> <em>≤</em> 1 is the fraction of <em>WORK</em> in a parallel program that must be executed <em>sequentially</em>, then the best speedup that can be obtained for that program for any number of processors, <em>P</em> , is <em>Speedup(P)</em> <em>≤</em> 1<em>/q</em>.</p><p>例如，如果线性工作占比为0.5，则不管处理器个数再多，有<em>Speedup(P)</em> <em>≤</em> 2</p><p>因为有<br>$$<br>WORK(G)*q \leq SPAN(G) \tag{5}\<br>==&gt;  \frac{WORK(G)}{SPAN(G)} \leq \frac{1}{q}<br>$$<br>上式表示关键路径用时不小于任务中线性部分的用时</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/parallel-programming-in-java/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.coursera.org/learn/parallel-programming-in-java/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Task-Creation-and-Termination-Async-Finish&quot;&gt;&lt;a href=&quot;#Task-Creation-and-Termination-Async-Finish&quot; class=&quot;headerlink&quot; title=&quot;Task Creation and Termination (Async, Finish)&quot;&gt;&lt;/a&gt;Task Creation and Termination (Async, Finish)&lt;/h3&gt;&lt;p&gt;以数组求和作为例子&lt;/p&gt;
&lt;p&gt;为了求得数组的和，可以将数组分为前后两个部分。两部分的求和可以并行执行，但是在求总和之前要保证两个子任务已经完成。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;finish {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  async SUM1;  &lt;span class=&quot;comment&quot;&gt;// asynchronously compute sum of the lower half of the array&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  SUM2;  &lt;span class=&quot;comment&quot;&gt;// compute sum of the upper half of the array in parallel with SUM1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SUM;  &lt;span class=&quot;comment&quot;&gt;// combine the two partial sums after both SUM1 and SUM2 have finished&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;async &amp;lt;stmt1&amp;gt;&lt;/code&gt; ：父任务创建子任务执行&lt;code&gt;&amp;lt;stmt1&amp;gt;&lt;/code&gt;，并且是并行于父任务的其余部分执行&lt;/p&gt;
&lt;p&gt;上面的伪代码中，&lt;code&gt;async SUM1;&lt;/code&gt;创建子任务SUM1，和SUM2并行执行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finish &amp;lt;stmt2&amp;gt;&lt;/code&gt;：父任务执行&lt;code&gt;&amp;lt;stmt2&amp;gt;&lt;/code&gt;，并且等待&lt;code&gt;&amp;lt;stmt2&amp;gt;以及其中创建的异步任务&lt;/code&gt;完成&lt;/p&gt;
&lt;p&gt;上例中，父任务等待SUM1和SUM2完成，才能执行SUM&lt;/p&gt;
&lt;h3 id=&quot;Tasks-in-Java’s-Fork-Join-Framework&quot;&gt;&lt;a href=&quot;#Tasks-in-Java’s-Fork-Join-Framework&quot; class=&quot;headerlink&quot; title=&quot;Tasks in Java’s Fork/Join Framework&quot;&gt;&lt;/a&gt;Tasks in Java’s Fork/Join Framework&lt;/h3&gt;&lt;p&gt;数组求和的&lt;strong&gt;分治&lt;/strong&gt;写法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://yikayiyo.github.io/tags/java/"/>
    
      <category term="并行编程" scheme="https://yikayiyo.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Markdown显示__init__.py</title>
    <link href="https://yikayiyo.github.io/2019/12/25/Markdown%E6%98%BE%E7%A4%BA__/"/>
    <id>https://yikayiyo.github.io/2019/12/25/Markdown%E6%98%BE%E7%A4%BA__/</id>
    <published>2019-12-25T04:59:36.000Z</published>
    <updated>2020-06-18T08:17:51.406Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown语法中双下划线 <code>__</code> 和双星 <code>**</code> 都是强调作用<br>python中的 <strong>init</strong>.py就显示成这个样子了 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f612.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f612.png?v8">😒</span></p><p>可以使用反引号将其包含，显示效果: <code>__init__.py</code> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8">😋</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Markdown语法中双下划线 &lt;code&gt;__&lt;/code&gt; 和双星 &lt;code&gt;**&lt;/code&gt; 都是强调作用&lt;br&gt;python中的 &lt;strong&gt;init&lt;/strong&gt;.py就显示成这个样子了 &lt;span class=&quot;github-emoji&quot; style
      
    
    </summary>
    
    
    
      <category term="杂" scheme="https://yikayiyo.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>记录一次源码阅读</title>
    <link href="https://yikayiyo.github.io/2019/05/12/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://yikayiyo.github.io/2019/05/12/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2019-05-12T08:14:00.000Z</published>
    <updated>2019-05-21T10:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/12/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.svg" class="" title="记录一次源码阅读"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/12/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.svg&quot; class=&quot;&quot; title=&quot;记录一次源码阅
      
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python，读书笔记" scheme="https://yikayiyo.github.io/tags/python%EF%BC%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>DevOps for dummies</title>
    <link href="https://yikayiyo.github.io/2019/02/25/devops/"/>
    <id>https://yikayiyo.github.io/2019/02/25/devops/</id>
    <published>2019-02-25T09:19:00.000Z</published>
    <updated>2019-03-05T14:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>business-driven, people, practice, tools</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>Develop and test against production-like systems </li><li>Deploy with repeatable, reliable processes</li><li>Monitor and validate operational quality</li><li>Amplify feedback loops<a id="more"></a><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3></li></ul><img src="/2019/02/25/devops/devops.png" class="" title="devops"><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ul><li>DevOps isn’t the goal. It helps you reach your goals</li><li>Any kind of system that needs <strong>rapid</strong> delivery of <strong>innovation</strong> requires DevOps</li></ul><ul><li><p>In broad terms, DevOps is an approach based on <strong>lean and agile principles</strong> in which business owners and the development, operations, and quality assurance departments collaborate to deliver software <strong>in a continuous manner</strong> that enables the business to more quickly seize market opportunities and reduce the time to include customer feedback</p></li><li><p>A true DevOps approach includes lines of business, practitioners, executives, partners, suppliers, and so on</p></li><li><p><strong>Continuous testing</strong> is facilitated by adopting capabilities like <strong>automated testing</strong> and <strong>service virtualization</strong></p></li><li><p>software-defined environments enable you to capture infrastructure as a kind of programmable and repeatable pattern, thereby accelerating deployments</p></li><li><p>Collaboration and communication across stakeholders — that’s the culture of DevOps.</p></li><li><p>Giving all stakeholders <strong>visibility</strong> into a project’s goals and status is crucial for building a DevOps culture based on trust and collaboration.</p></li><li><p>Processes define what those people do. Your organization can have a great culture of collaboration, but if people are doing the wrong things or doing the right things in the wrong way, failure is still likely.</p></li><li><p>Adopting continuous delivery typically is the most critical part of adopting DevOps.</p></li><li><p>From a process perspective, you need to adopt processes in three areas to enable <strong>continuous testing</strong>:</p><p>✓ Test environment provisioning and configuration</p><p>✓ Test data management</p><p>✓ Test integration, function, performance, and security</p></li><li><p>If an organization is building or maintaining multiple applications, everything it does has to be repeatable, in a reliable manner, to ensure quality across all applications</p></li><li><p>Start by focusing on the critical parts of organization — not everything all at once — and then gradually broaden to include all stages</p></li><li><p>The build stage is where the code is compiled to create and unit test the binaries to be deployed. Multiple build tools may be used in this stage, based on cross-platform and cross-technology needs</p></li><li><p>Development organizations typically use <strong>build servers</strong> to facilitate the large number of builds required on an ongoing basis to enable continuous integration</p></li><li><p>For any organization that wants to enable <strong>continuous testing</strong>, <strong>managing test data</strong> is an essential function</p></li><li><p>end-to-end Develop/Test environments =  cloud environments + deployment automation + service virtualization</p></li><li><p>Cloud without DevOps means not leveraging all the benefits of cloud</p></li><li><p>When adopting cloud, you first want to decide on the scope of responsibility that you plan to hand over to the cloud platform and what responsibility you want to take on yourself</p></li><li><p>two primary service models for cloud: Infrastructure as a Service (<strong>IaaS</strong>) and Platform as a Service (<strong>PaaS</strong>)</p></li><li><p>treats infrastructure as code best practices：</p><ul><li>Treat pattern definitions, script packages, and services as code</li><li>version everything</li><li>Automate deployment of topology patterns to the cloud</li><li>Manage versions of patterns across multiple cloud environments</li><li>Automate the testing of patterns</li><li>Cleanup catalog resources to avoid sprawl</li></ul></li><li><p>Ten DevOps myths:</p><ul><li>DevOps Is Only for “Born on the Web” Shops</li><li>DevOps Is Operations Learning How to Code</li><li>DevOps Is Just for Development and Operations</li><li>DevOps Isn’t for ITIL Shops</li><li>DevOps Isn’t for Regulated Industries</li><li>DevOps Isn’t for Outsourced Development</li><li>No Cloud Means No DevOps</li><li>DevOps Isn’t for Large, Complex Systems</li><li>DevOps Is Only about Communication</li><li>DevOps Means Continuous Change Deployment</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关键词&quot;&gt;&lt;a href=&quot;#关键词&quot; class=&quot;headerlink&quot; title=&quot;关键词&quot;&gt;&lt;/a&gt;关键词&lt;/h3&gt;&lt;p&gt;business-driven, people, practice, tools&lt;/p&gt;
&lt;h3 id=&quot;原则&quot;&gt;&lt;a href=&quot;#原则&quot; class=&quot;headerlink&quot; title=&quot;原则&quot;&gt;&lt;/a&gt;原则&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Develop and test against production-like systems &lt;/li&gt;
&lt;li&gt;Deploy with repeatable, reliable processes&lt;/li&gt;
&lt;li&gt;Monitor and validate operational quality&lt;/li&gt;
&lt;li&gt;Amplify feedback loops&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="https://yikayiyo.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>异步网络编程</title>
    <link href="https://yikayiyo.github.io/2018/11/25/python%E5%BC%82%E6%AD%A5/"/>
    <id>https://yikayiyo.github.io/2018/11/25/python%E5%BC%82%E6%AD%A5/</id>
    <published>2018-11-25T08:14:00.000Z</published>
    <updated>2019-05-18T09:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>协程、生成器</p><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p>协程：又称作Coroutine。从字面上来理解，即协同运行的例程，它是比是线程（thread）更细量级的用户态线程，特点是允许用户的主动调用和主动退出，挂起当前的例程然后返回值或去执行其他任务，接着返回到原来停下的点继续执行</p></li><li><p>有时间再写。。。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关键词&quot;&gt;&lt;a href=&quot;#关键词&quot; class=&quot;headerlink&quot; title=&quot;关键词&quot;&gt;&lt;/a&gt;关键词&lt;/h3&gt;&lt;p&gt;协程、生成器&lt;/p&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;
      
    
    </summary>
    
    
    
      <category term="python" scheme="https://yikayiyo.github.io/tags/python/"/>
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>遍历二叉树</title>
    <link href="https://yikayiyo.github.io/2018/06/19/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://yikayiyo.github.io/2018/06/19/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2018-06-19T01:47:01.000Z</published>
    <updated>2020-06-19T06:05:03.130Z</updated>
    
    <content type="html"><![CDATA[<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span>非递归实现</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        cur = root  <span class="comment">#借助临时的cur，不要修改root</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:  <span class="comment"># 一直往左走，全部入栈</span></span><br><span class="line">                stack.append(cur) </span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 取出栈顶节点，处理，再处理该节点的右子树   </span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)  </span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>写法一</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        cur = root</span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)  <span class="comment"># 每一个节点都放入栈中</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()  <span class="comment"># 这里pop出来的是已经访问过的节点</span></span><br><span class="line">                cur = cur.right  <span class="comment"># 还需要指向右子树</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8">❤</span>写法二：<a id="more"></a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        cur = root</span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur.right)  <span class="comment"># 栈中直接放入已访问节点的右子树</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()  <span class="comment"># 取到的就是右子树根节点</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><p> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f610.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f610.png?v8">😐</span>写法三：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack, output = [root], []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                output.append(root.val)</span><br><span class="line">                <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment">#右子树先入栈，左子树后入栈</span></span><br><span class="line">                    stack.append(root.right)</span><br><span class="line">                <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    stack.append(root.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></tbody></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p><p>对于当前节点，只有其<strong>右子树已经处理</strong>或<strong>没有右子树</strong>时，才能处理它。</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f440.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f440.png?v8">👀</span>这里要记录一个last_visited节点​​</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        cur = root</span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        last_visited = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = stack[<span class="number">-1</span>]  <span class="comment"># 定位根节点，这个地方不能pop(),因为可能有右子树</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tmp.right <span class="keyword">or</span> tmp.right == last_visited:  </span><br><span class="line">                    <span class="comment"># 没有右子树或者已经访问过了，处理当前根节点</span></span><br><span class="line">                    res.append(tmp.val)</span><br><span class="line">                    last_visited = tmp</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur = tmp.right  <span class="comment"># 右子树未访问，处理右子树</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8">❤</span>后序遍历可以借前序遍历的一个变体实现，<strong>先根右左,再倒置</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        cur = root</span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur.left)  <span class="comment"># 栈中直接放入已访问节点的左子树</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()  <span class="comment"># 取到的就是左子树根节点</span></span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span class=&quot;github-emoji&quot; style=&quot;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain&quot; data-src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8&quot;&gt;⭐&lt;/span&gt;非递归实现&lt;/p&gt;
&lt;h3 id=&quot;中序遍历&quot;&gt;&lt;a href=&quot;#中序遍历&quot; class=&quot;headerlink&quot; title=&quot;中序遍历&quot;&gt;&lt;/a&gt;中序遍历&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inorderTraversal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, root: TreeNode)&lt;/span&gt; -&amp;gt; List[int]:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cur = root  &lt;span class=&quot;comment&quot;&gt;#借助临时的cur，不要修改root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stack = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; cur &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; stack:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cur:  &lt;span class=&quot;comment&quot;&gt;# 一直往左走，全部入栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stack.append(cur) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = cur.left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:  &lt;span class=&quot;comment&quot;&gt;# 取出栈顶节点，处理，再处理该节点的右子树   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = stack.pop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res.append(cur.val)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = cur.right&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;前序遍历&quot;&gt;&lt;a href=&quot;#前序遍历&quot; class=&quot;headerlink&quot; title=&quot;前序遍历&quot;&gt;&lt;/a&gt;前序遍历&lt;/h3&gt;&lt;p&gt;写法一&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;preorderTraversal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, root: TreeNode)&lt;/span&gt; -&amp;gt; List[int]:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cur = root&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stack = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; cur &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; stack:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cur:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stack.append(cur)  &lt;span class=&quot;comment&quot;&gt;# 每一个节点都放入栈中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res.append(cur.val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = cur.left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = stack.pop()  &lt;span class=&quot;comment&quot;&gt;# 这里pop出来的是已经访问过的节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = cur.right  &lt;span class=&quot;comment&quot;&gt;# 还需要指向右子树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;span class=&quot;github-emoji&quot; style=&quot;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8) center/contain&quot; data-src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8&quot;&gt;❤&lt;/span&gt;写法二：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记，二叉树" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>word2vec + manage experiments</title>
    <link href="https://yikayiyo.github.io/2018/04/05/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    <id>https://yikayiyo.github.io/2018/04/05/%E8%AF%8D%E5%90%91%E9%87%8F/</id>
    <published>2018-04-05T14:30:10.000Z</published>
    <updated>2018-07-25T06:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键词：model base, variable sharing, model sharing</p><h4 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h4><ul><li>文本的分布式表示是许多自然语言处理任务的基础</li><li>word2vec是用来生成词语分布式表示的一组模型</li><li>主要有两种模型：skip-gram和CBOW</li><li>算法角度：CBOW模型从上下文词预测目标词，skip-gram模型从目标词预测上下文词<a id="more"></a></li><li>统计角度：CBOW模型将an entire context as one observation，这样做smoothes over了许多分布信息，适合小一些的数据集上；skip-gram模型则是将<strong>each</strong> context-target pair as a new observation，在larger datasets上表现更好</li><li>训练词向量：定义一个单层网络，任务是给定中心词预测词典中的词作为上下文词的概率，我们最后要的是隐含层的权重参数</li><li>使用 softmax 来获得可能的目标词的分布，分母要对字典中的所有词取指数再求和，计算是瓶颈</li><li>规避瓶颈的方法：层次化的softmax 和基于采样的 softmax </li><li>文章*<em>Distributed Representations of Words and Phrases and their Compositionality *</em>指出，训练skip-gram模型时，与更复杂的分层softmax相比，负采样可以加快训练速度，为频繁词汇提供更好的向量表示</li><li>负采样实际上是一种称为噪声对比估计（NCE）的简化模型，基于假设，如噪声样本的数量k和噪声样本的分布Q满足kQ(w) = 1，来简化计算；理论上不能保证其导数和softmax梯度一致</li><li>NCE则随着noise样本增多，提供了这种保证</li><li>负采样和NCE只在训练时有用</li></ul><h4 id="Implementing"><a href="#Implementing" class="headerlink" title="Implementing"></a>Implementing</h4><ul><li>词的indices作为输入（一个scalar），</li><li>BATCH_SIZE的样本，输入维度为[BATCH_SIZE]，输出维度为[BATCH_SIZE,1]</li><li>词向量矩阵维度为[VOCAB_SIZE,EMBED_SIZE]，每一行代表一个词向量</li><li>利用tf.nn.embedding_lookup()找中心词对应的向量，免去了不必要的计算（matrix and onehot vector）</li><li>loss使用tf.nn.nce_loss()，optimizer使用GradientDescentOptimizer</li></ul><h4 id="Structure-TF-models"><a href="#Structure-TF-models" class="headerlink" title="Structure TF models"></a>Structure TF models</h4><p>定义图</p><ul><li>导入数据（placeholder or tf.data）</li><li>定义权重</li><li>定义模型</li><li>定义损失函数</li><li>定义优化器</li></ul><p>执行图</p><ul><li>初始化所有变量</li><li>初始化迭代器或者feed in训练数据</li><li>数据经过模型得到结果</li><li>计算cost</li><li>调整模型参数使得cost最小或者最大</li></ul><p>build model as a class in order to reuse easily.</p><h4 id="Variable-sharing"><a href="#Variable-sharing" class="headerlink" title="Variable sharing"></a>Variable sharing</h4><p>Name scope</p><p>将相关的ops放在一个name_scope下，这样得到的图在TensorBoard上是一块一块的，更加整洁。<br>TensorBoard图中三种边：</p><ol><li>灰实边：数据流</li><li>橙实边：参考边，op_lest影响op_right</li><li>灰虚边：控制依赖边，op_left依赖于op_right</li></ol><p>Variable scope</p><p>和Name scope一样都创建了namespace，调用tf.variable_scope(“name”)会隐式地调用tf.name_scope(“name”)，Variable scope主要功能是促进变量共享（facilitate variable sharing)<br>为实现变量共享:</p><ol><li>使用 <strong>tf.get_variable()</strong>,它会在创建变量之前检查其是否存在</li><li>将所用到的变量放到一个VarScope，将这个VarScope设置为可复用的（reusable）</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fully_connected</span><span class="params">(x,output_dim,scope_name)</span>:</span> <span class="comment">#基础组件：全连接层</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(scope_name):</span><br><span class="line">        w = tf.get_variable(<span class="string">"weights"</span>,[x.shape[<span class="number">1</span>],output_dim],initializer=tf.random_normal_initializer())</span><br><span class="line">        b = tf.get_variable(<span class="string">"bias"</span>,[output_dim],initializer= tf.constant_initializer(<span class="number">0.0</span>))</span><br><span class="line">        <span class="keyword">return</span> tf.matmul(x,w) + b</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_hidden_layer</span><span class="params">(x)</span>:</span>  <span class="comment">#网络结构：两个全连接层</span></span><br><span class="line">    h1 = fully_connected(x,<span class="number">50</span>,<span class="string">'h1'</span>)</span><br><span class="line">    h2 = fully_connected(h1,<span class="number">10</span>,<span class="string">'h2'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">'two_layers'</span>) <span class="keyword">as</span> scope: <span class="comment">#调用网络，输入x1，x2</span></span><br><span class="line">    logits1 = two_hidden_layer(x1)</span><br><span class="line">    scope.reuse_variables()</span><br><span class="line">    logits2 = two_hidden_layer(x2）</span><br></pre></td></tr></tbody></table></figure><p>以上代码模式，基础组件可以定义更多，比如conv，relu，网络结构可以更复杂，比如放一个ResNet，非常容易scale。<br>由于使用了变量共享，多次传入x，网络TensorBoard图的复杂程度不会爆炸式增加。</p><p>Graph collections</p><p>使用这个，可以获取满足一定条件的所有变量，tf.get_collection(key,scope=None)<br>比如执行optimizer的时候，默认情况下它会获取key=tf.GraphKeys.TRAINABLE_VARIABLES的变量，即所有可训练的变量（当然也可以传入指定的、要训练的变量<br>获取某个scope下的所有变量，tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES,scope=’scope_name’)<br>key还有许多其它的值，见官网。</p><h4 id="Manage-experiments"><a href="#Manage-experiments" class="headerlink" title="Manage experiments"></a>Manage experiments</h4><p>实验总是很久，中断随时发生，因此训练可以随时随地停止、像没事一样恢复，非常重要。<br>另外一个问题是论文结果复现，控制实验的随机因子对复现结果非常关键。</p><p>tf.train.Saver()</p><p><strong>周期性地保存模型参数</strong>是个好习惯<br>tf.train.Saver()类将图的<strong>变量保存</strong>（不是整张图）到二进制文件，也就是一个checkpoint（变量名到tensors的映射）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义模型</span></span><br><span class="line">...</span><br><span class="line">global_steps = tf.Variable(<span class="number">0</span>, trainable=<span class="literal">False</span>，name=<span class="string">'global_steps'</span>)</span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(lr).minimize(loss,global_step=global_steps)</span><br><span class="line"><span class="comment">#创建一个saver对象</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动一个会话来执行计算</span></span><br><span class="line"><span class="keyword">with</span> tf.session() <span class="keyword">as</span> sess:</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">1</span>,training_steps):</span><br><span class="line">        sess.run([optimizer]) <span class="comment">#global_step会在每一步训练后自加1</span></span><br><span class="line">        <span class="keyword">if</span> step%<span class="number">1000</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="comment">#这里传入step也差不多吧...默认保存图中所有变量</span></span><br><span class="line">            saver.save(sess,<span class="string">'checkpoints/model-name'</span>,global_step=global_steps)</span><br></pre></td></tr></tbody></table></figure><p>生成的checkpoint名，像这样，’checkpoints/skip-gram-10000’<br>在恢复模型时可以直接传入checkpoint名（如果有的话</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ckpt = tf.train.get_checkpoint_state(os.path.dirname(<span class="string">'checkpoints/model-name'</span>))</span><br><span class="line"><span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">    saver.restore(sess,ckpt.model_checkpoint_path) <span class="comment">#恢复的是最近的一个check point</span></span><br></pre></td></tr></tbody></table></figure><p>恢复的时候，网络图还得自己重新搭（still have to create the graph ourselves）之后再加载变量<br>当然，经常的做法是到目前为止表现最好的参数也保存下来（不止是最近的一次）</p><p>tf.summary</p><p>记录模型训练过程中指标变化，包括loss，accuracy等等</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建summaries</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"summaries"</span>):</span><br><span class="line">    tf.summary.scalar(<span class="string">"loss"</span>,loss)</span><br><span class="line">    tf.summary.histogram(<span class="string">"histogram loss"</span>,loss)</span><br><span class="line">    tf.summary.scalar(<span class="string">"accuracy"</span>,accuracy)</span><br><span class="line">    summary_op = tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行summary op</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(steps):</span><br><span class="line">        _loss,_,summary = sess.run([model.loss,model.optimizer,model.summary_op],feed_dict={...})</span><br><span class="line">        writer = tf.summary.FileWriter(<span class="string">'path'</span>+str(lr),sess.graph) <span class="comment">#将lr写入路径，方便tensorboard对比</span></span><br><span class="line">        writer.add(summary,global_step=step) <span class="comment">#记录每一个step的summary</span></span><br><span class="line">    writer.close()</span><br></pre></td></tr></tbody></table></figure><p>control randomization</p><p>为了使得别人在实验时结果会与你一致</p><ol><li><p>op级别<br>所有的tensor初始化时都传入seed参数<br>session记录了随机状态，每一个新的session都会重新start the random state</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>,seed=<span class="number">2</span>)</span><br><span class="line">d = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>,seed=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(c)) <span class="comment">#value: a</span></span><br><span class="line">    print(sess.run(d)) <span class="comment">#same value: a</span></span><br><span class="line">    print(sess.run(c)) <span class="comment">#value: b</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>graph级别<br>比如demo1.py和demo2.py代码相同，设置了tf.set_random_seed(seed)的话执行结果是相同的</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tf.set_random_seed(<span class="number">2</span>)</span><br><span class="line">c = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>)</span><br><span class="line">d = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(c)) <span class="comment"># 都是a</span></span><br><span class="line">    print(sess.run(d)) <span class="comment"># 都是b</span></span><br></pre></td></tr></tbody></table></figure></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键词：model base, variable sharing, model sharing&lt;/p&gt;
&lt;h4 id=&quot;word2vec&quot;&gt;&lt;a href=&quot;#word2vec&quot; class=&quot;headerlink&quot; title=&quot;word2vec&quot;&gt;&lt;/a&gt;word2vec&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;文本的分布式表示是许多自然语言处理任务的基础&lt;/li&gt;
&lt;li&gt;word2vec是用来生成词语分布式表示的一组模型&lt;/li&gt;
&lt;li&gt;主要有两种模型：skip-gram和CBOW&lt;/li&gt;
&lt;li&gt;算法角度：CBOW模型从上下文词预测目标词，skip-gram模型从目标词预测上下文词&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="machine learning" scheme="https://yikayiyo.github.io/tags/machine-learning/"/>
    
      <category term="TensorFlow" scheme="https://yikayiyo.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>linear and logistic regression in TensorFlow</title>
    <link href="https://yikayiyo.github.io/2018/03/29/TensorFlow02/"/>
    <id>https://yikayiyo.github.io/2018/03/29/TensorFlow02/</id>
    <published>2018-03-29T03:37:22.000Z</published>
    <updated>2018-05-31T08:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h3><h4 id="问题定义："><a href="#问题定义：" class="headerlink" title="问题定义："></a>问题定义：</h4><p>设X为生育率，Y为预期寿命，能否找到一个线性函数f使得Y = f(X)？</p><img src="/2018/03/29/TensorFlow02/f1.png" class=""><a id="more"></a><p>数据集描述：</p><p>名称: Birth rate - life expectancy in 2010<br>X = 生育率. Type: float.<br>Y = 预期寿命. Type: foat.<br>数据量: 190<br>数据形式: (X,Y)</p><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><p><strong>假设</strong>X和Y之间的关系是线性的，这意味着有w和b，满足：Y_pred = wX + b.<br>本例中w，b都是scalar，</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = tf.get_variable(<span class="string">'weights'</span>,initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line">b = tf.get_variable(<span class="string">'bias'</span>,initializer=tf.constant(<span class="number">0.0</span>))</span><br></pre></td></tr></tbody></table></figure><p>损失函数使用均方误差</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y_pred = w*X+b</span><br><span class="line">loss = tf.square(Y-Y_pred,name=<span class="string">'loss'</span>)</span><br></pre></td></tr></tbody></table></figure><p>完整代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> utils</span><br><span class="line"></span><br><span class="line">DATA_FILE = <span class="string">"data/birth_life_2010.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 1: 加载数据，形式为（190，2）的numpy数组，每一行代表一个点</span></span><br><span class="line">data, n_samples = utils.read_birth_life_data(DATA_FILE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2: 创建placeholders</span></span><br><span class="line">X = tf.placeholder(tf.float32, name=<span class="string">'X'</span>)</span><br><span class="line">Y = tf.placeholder(tf.float32, name=<span class="string">'Y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3: 创建变量，初始化为0</span></span><br><span class="line">w = tf.get_variable(<span class="string">'weights'</span>, initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line">b = tf.get_variable(<span class="string">'bias'</span>, initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4: 模型</span></span><br><span class="line">Y_predicted = w * X + b </span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 5: 损失函数</span></span><br><span class="line">loss = tf.square(Y - Y_predicted, name=<span class="string">'loss'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 6: GD最小化loss</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=<span class="number">0.001</span>).minimize(loss)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line"><span class="comment"># Step 7: 变量初始化</span></span><br><span class="line">sess.run(tf.global_variables_initializer()) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 8: 训练100回</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): <span class="comment"># run 100 epochs</span></span><br><span class="line"><span class="comment"># 每次传入一个数据点，事实上，使用batches of data更好一点。</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> data:</span><br><span class="line"><span class="comment"># Session runs train_op to minimize loss</span></span><br><span class="line">sess.run(optimizer, feed_dict={X: x, Y:y}) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 9: output the values of w and b</span></span><br><span class="line">w_out, b_out = sess.run([w, b])</span><br></pre></td></tr></tbody></table></figure><p>结论：<br>经过100次训练后，平均损失为30.04，w = -6.07，b = 84.93。<br>这证实了我们的假设，即出生率与一个国家人口的预期寿命之间存在负相关关系。 但是，这并不意味着多一个孩子会减少6年的寿命。</p><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>假设X和Y满足：Y_pred = wX^2 + uX + b</p><p>只需修改部分代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 3: 创建变量，初始化为0</span></span><br><span class="line">w = tf.get_variable(<span class="string">'weights_1'</span>, initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line">u = tf.get_variable(<span class="string">'weights_2'</span>, initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line">b = tf.get_variable(<span class="string">'bias'</span>, initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4: 模型</span></span><br><span class="line">Y_predicted = w * X * X + X * u + b</span><br></pre></td></tr></tbody></table></figure><p>由于平方损失会给离群点太多的权重，这里损失函数考虑使用Huber loss：</p><img src="/2018/03/29/TensorFlow02/f2.png" class=""><p>tensorflow提供了一些控制流操作：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">huber_loss</span><span class="params">(labels, predictions, delta=<span class="number">14.0</span>)</span>:</span></span><br><span class="line">    residual = tf.abs(labels - predictions)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">0.5</span> * tf.square(residual)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span> <span class="keyword">return</span> delta * residual - <span class="number">0.5</span> * tf.square(delta)</span><br><span class="line">    <span class="keyword">return</span> tf.cond(residual &lt; delta, f1, f2)</span><br></pre></td></tr></tbody></table></figure><p>最后结果为：<strong>w: -5.883589, b: 85.124306.</strong></p><h4 id="which-one-is-better？"><a href="#which-one-is-better？" class="headerlink" title="which one is better？"></a>which one is better？</h4><p>we do need test data set！！！</p><h3 id="tf-data"><a href="#tf-data" class="headerlink" title="tf.data"></a>tf.data</h3><p>使用placeholder和feed_dicts的好处是将数据处理与TensorFlow分离，使用python就可以轻松地shuffle, batch, generate arbitrary data. 不好的地方是，数据处理的线程很有可能是瓶颈，使整个程序slow down。</p><p>使用队列也是TF中处理数据的一个选项，队列允许pipelining、threading操作，减少了数据加载到placeholders的时间，但是难以使用且容易崩溃。</p><p>tf.data比placeholder更快，比队列更容易使用，而且不会crash。</p><p>数据存储在一个tf.data.Dataset对象中，而不是一个non-TensorFLow对象（numpy array）</p><h4 id="tf-data基操："><a href="#tf-data基操：" class="headerlink" title="tf.data基操："></a>tf.data基操：</h4><ol><li><p>创建DataSet</p><ol><li><p>从tensor创建</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># features,labels都是tensors，也可以是numpy arrays</span></span><br><span class="line">tf.data.DataSet.from_tensor_slice((features,labels))</span><br></pre></td></tr></tbody></table></figure></li><li><p>从file创建</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件每一行代表一个数据，例如csv文件</span></span><br><span class="line">tf.data.TextLineDataset(filenames)</span><br><span class="line"><span class="comment"># 每一个文件长度都固定，比如都是28*28的图片</span></span><br><span class="line">tf.data.FixedLengthRecordDataset([file1,file2,file3,file4,...])</span><br><span class="line"><span class="comment"># tfrecord格式，（还没用过</span></span><br><span class="line">tf.data.TFRecordDataset(filenames)</span><br></pre></td></tr></tbody></table></figure></li></ol></li><li><p>创建Iterator</p><p>取dataset中的数据需要用到迭代器</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只能遍历一遍</span></span><br><span class="line">iterator = dataset.make_one_shot_iterator()</span><br><span class="line"><span class="comment"># 多次初始化，多次遍历</span></span><br><span class="line">iterator = dataset.make_initializable_iterator()</span><br><span class="line"><span class="comment"># 返回一个或者一组样本</span></span><br><span class="line">iterator.get_next()</span><br></pre></td></tr></tbody></table></figure></li><li><p>训练</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iterator = dataset.make_initializable_iterator()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): </span><br><span class="line">        <span class="comment"># 每一个epoch都要初始化iterator</span></span><br><span class="line">        sess.run(iterator.initializer) </span><br><span class="line">        total_loss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                sess.run([optimizer]) </span><br><span class="line">        <span class="keyword">except</span> tf.errors.OutOfRangeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#简单的命令操作dataset</span></span><br><span class="line">dataset = dataset.shuffle(<span class="number">1000</span>)</span><br><span class="line">dataset = dataset.repeat(<span class="number">100</span>)</span><br><span class="line">dataset = dataset.batch(<span class="number">128</span>)</span><br><span class="line">dataset = dataset.map(<span class="keyword">lambda</span> x: tf.one_hot(x, <span class="number">10</span>)) </span><br><span class="line"><span class="comment"># convert each element of dataset to one_hot vector</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Logistic-Regression-with-MINIST"><a href="#Logistic-Regression-with-MINIST" class="headerlink" title="Logistic Regression with MINIST"></a>Logistic Regression with MINIST</h3><h4 id="一个问题："><a href="#一个问题：" class="headerlink" title="一个问题："></a>一个问题：</h4><p>这个实验有多个数据集，训练集、验证集和测试集，如果每个数据集都有各自的iterator，那我们就得为每一个iterator创建一个graph。</p><p> 不，可以用一个迭代器，用不同的数据初始化它</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iterator = tf.data.Iterator.from_structure(train_data.output_types,</span><br><span class="line">                                           train_data.output_shapes)</span><br><span class="line"><span class="comment"># 每一个epoch的训练前，都要sess.run(train_init)</span></span><br><span class="line">train_init = iterator.make_initializer(train_data)</span><br><span class="line">test_init = iterator.make_initializer(test_data)</span><br></pre></td></tr></tbody></table></figure><p><a href="https://github.com/yikayiyo/stanford-tensorflow-tutorials/blob/master/examples/03_logreg.py" target="_blank" rel="noopener">完整代码</a>, tensorboard图示如下：</p><img src="/2018/03/29/TensorFlow02/f3.png" class=""><p>下一步，尝试将这个graph改造得有条理一些。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linear-Regression&quot;&gt;&lt;a href=&quot;#Linear-Regression&quot; class=&quot;headerlink&quot; title=&quot;Linear Regression&quot;&gt;&lt;/a&gt;Linear Regression&lt;/h3&gt;&lt;h4 id=&quot;问题定义：&quot;&gt;&lt;a href=&quot;#问题定义：&quot; class=&quot;headerlink&quot; title=&quot;问题定义：&quot;&gt;&lt;/a&gt;问题定义：&lt;/h4&gt;&lt;p&gt;设X为生育率，Y为预期寿命，能否找到一个线性函数f使得Y = f(X)？&lt;/p&gt;
&lt;img src=&quot;/2018/03/29/TensorFlow02/f1.png&quot; class=&quot;&quot;&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="machine learning" scheme="https://yikayiyo.github.io/tags/machine-learning/"/>
    
      <category term="TensorFlow" scheme="https://yikayiyo.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow Ops</title>
    <link href="https://yikayiyo.github.io/2018/03/28/TensorFlow01/"/>
    <id>https://yikayiyo.github.io/2018/03/28/TensorFlow01/</id>
    <published>2018-03-28T01:37:22.000Z</published>
    <updated>2018-05-29T15:46:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一般流程："><a href="#一般流程：" class="headerlink" title="一般流程："></a>一般流程：</h4><h4 id="TFboy基操："><a href="#TFboy基操：" class="headerlink" title="TFboy基操："></a>TFboy基操：</h4><ul><li>定义图<a id="more"></a></li><li>创建writer，两种方式<ul><li>tf.get_default_graph()</li><li>sess.graph</li></ul></li><li>创建session执行图</li><li>关闭writer</li><li>TensorBoard可视化</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">a = tf.constant(<span class="number">2</span>, name=<span class="string">'a'</span>)</span><br><span class="line">b = tf.constant(<span class="number">3</span>, name=<span class="string">'b'</span>)</span><br><span class="line">x = tf.add(a, b, name=<span class="string">'add'</span>)</span><br><span class="line"><span class="comment"># 第一种</span></span><br><span class="line">writer = tf.summary.FileWriter(<span class="string">'./graphs/low'</span>, tf.get_default_graph()) </span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 第二种</span></span><br><span class="line">    <span class="comment"># writer = tf.summary.FileWriter('./graphs', sess.graph) </span></span><br><span class="line">    print(sess.run(x))</span><br><span class="line">writer.close() <span class="comment"># close the writer when you’re done using it</span></span><br></pre></td></tr></tbody></table></figure><p>writer会将图（包含的各种ops）以日志文件的形式写入指定目录，tensorboard可以将这些文件可视化出来</p><p>上面的程序每跑一次就会产生一个日志文件，不用的日志及时删除</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tensorboard --logdir=<span class="string">'./graphs/low'</span> --port=6006</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意路径不要搞错</span></span><br></pre></td></tr></tbody></table></figure><img src="/2018/03/28/TensorFlow01/ex1.png" class=""><h4 id="没记住的"><a href="#没记住的" class="headerlink" title="没记住的"></a>没记住的</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tf.fill([2,3],8) ===&gt; [[8,8,8],[8,8,8]]</span><br><span class="line">tf.lin_space(10.0,13.0,4,name=None) ===&gt;[10.0 11.0 12.0 13.0]</span><br><span class="line"><span class="comment">#各种分布</span></span><br><span class="line">tf.random_normal</span><br><span class="line">...</span><br><span class="line"><span class="comment">#add multiple tensors</span></span><br><span class="line">tf.add_n([a,b,b]) ====&gt; a+b+b</span><br></pre></td></tr></tbody></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h5><p>训练中需要更新的参数定义为变量</p><p>常量存储在图中，变量则可能在parameter server上</p><p>常量占了很多存储时，加载图会很慢</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># old way</span></span><br><span class="line">tf.Variable(&lt;initial-value&gt;,name=&lt;optional-name&gt;)</span><br><span class="line"><span class="comment"># now</span></span><br><span class="line">tf.get_variable(...)</span><br><span class="line"><span class="comment"># 当initializer时tf.constant时，不需要参数shape</span></span><br><span class="line">s = tf.get_variable(<span class="string">"scalar"</span>, initializer=tf.constant(<span class="number">2</span>)) </span><br><span class="line">m = tf.get_variable(<span class="string">"matrix"</span>, initializer=tf.constant([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]]))</span><br><span class="line">W = tf.get_variable(<span class="string">"big_matrix"</span>, shape=(<span class="number">784</span>, <span class="number">10</span>), initializer=tf.zeros_initializer())</span><br></pre></td></tr></tbody></table></figure><h5 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次性初始化所有变量</span></span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"><span class="comment">#初始化部分变量</span></span><br><span class="line">sess.run(tf.variables_initializer([a, b]))</span><br><span class="line"><span class="comment">#单独初始化</span></span><br><span class="line">sess.run(W.initializer)</span><br><span class="line"><span class="comment">#从文件加载</span></span><br><span class="line">Todo...</span><br></pre></td></tr></tbody></table></figure><h5 id="变量的值"><a href="#变量的值" class="headerlink" title="变量的值"></a>变量的值</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种方式</span></span><br><span class="line">print(sess.run(W))</span><br><span class="line">print(W.eval())</span><br></pre></td></tr></tbody></table></figure><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 赋值会完成初始化的工作</span></span><br><span class="line">W.assign(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 自增自减不会初始化变量</span></span><br><span class="line">W.assign_add(<span class="number">10</span>)</span><br><span class="line">W.assing_sub(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 变量依赖,使用initialized_value()保证用W的值来初始化V</span></span><br><span class="line">V = tf.Variable(W.initialized_value()*<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="控制依赖"><a href="#控制依赖" class="headerlink" title="控制依赖"></a>控制依赖</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># g has 5 ops: a,b,c,d,e</span></span><br><span class="line"><span class="comment"># 还没用到过</span></span><br><span class="line"><span class="keyword">with</span> g.control_dependencies([a,b,c]):</span><br><span class="line">    <span class="comment"># d,e only run after a,b,c have executed</span></span><br><span class="line">    d = ...</span><br><span class="line">    e = ...</span><br></pre></td></tr></tbody></table></figure><h4 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h4><ol><li><p>old way：placeholders and feed_dict</p><p>例如，对于f(x,y) = 2x + y，x y 就是真实值的占位符</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#shape=None 意味着接收任意shape的张量</span></span><br><span class="line">tf.placeholder(dtype,shape=<span class="literal">None</span>,name=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#any tensors that are feedable can be fed</span></span><br><span class="line">tf.Graph.is_feedable(tensor)</span><br><span class="line"><span class="comment">#feed_dict可以用来测试模型，</span></span><br><span class="line"><span class="comment">#直接传入某些值免去了大量的计算</span></span><br><span class="line">a = tf.add(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">b = tf.multiply(a, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(b))                                 <span class="comment"># &gt;&gt; 21</span></span><br><span class="line">    <span class="comment"># compute the value of b given the value of a is 15</span></span><br><span class="line">    print(sess.run(b, feed_dict={a: <span class="number">15</span>}))              <span class="comment"># &gt;&gt; 45</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>new way: tf.data</p><p>[ ] todo…</p></li></ol><h4 id="lazy-loading"><a href="#lazy-loading" class="headerlink" title="lazy loading"></a>lazy loading</h4><p>需要计算op的时候才创建</p><p>因为训练绝大数情况都要计算多次，所以lazy loading会产生大量的冗余节点</p><p>解决办法：</p><ol><li>尽可能的将ops的定义和计算分开（不要在计算的时候创建op</li><li>当你将相关ops组合在一起（比如，1中的步骤在一个类里面）可以使用python的@property机制确保某些功能只执行一次（!!!有待研究）</li></ol><p>相关博客<a href="http://danijar.com/structuring-your-tensorflow-models/" target="_blank" rel="noopener">http://danijar.com/structuring-your-tensorflow-models/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一般流程：&quot;&gt;&lt;a href=&quot;#一般流程：&quot; class=&quot;headerlink&quot; title=&quot;一般流程：&quot;&gt;&lt;/a&gt;一般流程：&lt;/h4&gt;&lt;h4 id=&quot;TFboy基操：&quot;&gt;&lt;a href=&quot;#TFboy基操：&quot; class=&quot;headerlink&quot; title=&quot;TFboy基操：&quot;&gt;&lt;/a&gt;TFboy基操：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;定义图&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="machine learning" scheme="https://yikayiyo.github.io/tags/machine-learning/"/>
    
      <category term="TensorFlow" scheme="https://yikayiyo.github.io/tags/TensorFlow/"/>
    
  </entry>
  
</feed>
