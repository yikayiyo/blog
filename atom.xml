<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misbehavior</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yikayiyo.github.io/"/>
  <updated>2020-06-22T15:56:39.404Z</updated>
  <id>https://yikayiyo.github.io/</id>
  
  <author>
    <name>yikayiyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网站性能提升最佳实践一</title>
    <link href="https://yikayiyo.github.io/2020/06/22/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%80/"/>
    <id>https://yikayiyo.github.io/2020/06/22/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%80/</id>
    <published>2020-06-22T14:51:53.000Z</published>
    <updated>2020-06-22T15:56:39.404Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink</a></p><ul><li>Content</li><li>Server</li><li>Cookie</li><li>CSS</li><li>JavaScript</li><li>Images</li><li>Mobile</li></ul><p>原文从七个方面总结网站性能提升。</p><p>本篇总结Content方面。</p><h3 id="Make-Fewer-HTTP-Requests-减少HTTP请求"><a href="#Make-Fewer-HTTP-Requests-减少HTTP请求" class="headerlink" title="Make Fewer HTTP Requests 减少HTTP请求"></a><a href="https://developer.yahoo.com/performance/rules.html#num_http" target="_blank" rel="noopener">Make Fewer HTTP Requests</a> 减少HTTP请求</h3><p>减少页面的组件数量，可以减少HTTP请求数量。</p><p>减少页面组件的方法：</p><ul><li><p>精简页面设计</p></li><li><p>不简化设计的情况下：</p><ul><li>文件组合（js文件放到一个里面，css文件放到一个里面）</li></ul></li><li><p><a href="https://css-tricks.com/css-sprites/" target="_blank" rel="noopener">CSS Sprites</a>：背景图片合并成一张，利用css属性设置各个部分到相对应的页面</p><ul><li><a href="https://css-tricks.com/examples/CSSClip/" target="_blank" rel="noopener">CSS Sprites with Inline Images</a> 也可以用来处理图片</li></ul></li><li><p>将内联图片放到css文件中（ Combining inline images into your cached stylesheets is a way to reduce HTTP requests and avoid increasing the size of your pages ？How ? ( Todo: find demo</p></li></ul><h3 id="Reduce-DNS-Lookups-减少DNS查询"><a href="#Reduce-DNS-Lookups-减少DNS查询" class="headerlink" title="Reduce DNS Lookups 减少DNS查询"></a><a href="https://developer.yahoo.com/performance/rules.html#dns_lookups" target="_blank" rel="noopener">Reduce DNS Lookups</a> 减少DNS查询</h3><p>减少网站的主机名（hostnames），可以减少DNS查询次数</p><p>但是减少网站主机名会减少页面的并发下载量</p><blockquote><p>Trade-off：Avoiding DNS lookups cuts response times, but reducing parallel downloads may increase response times. </p></blockquote><p> Guide：Split components across <strong>at least two but no more than four</strong> hostnames.</p><h3 id="Avoid-Redirects-避免网站重定向"><a href="#Avoid-Redirects-避免网站重定向" class="headerlink" title="Avoid Redirects 避免网站重定向"></a><a href="https://developer.yahoo.com/performance/rules.html#redirects" target="_blank" rel="noopener">Avoid Redirects</a> 避免网站重定向</h3><p>最经常发生的重定向：应该加/的地方没有加/</p><p>重定向可以用来从旧网站跳转到新网站</p><p>重定向也可以用来连接网站的不同部分、根据特定情况让用户跳转</p><p>解决办法：</p><ul><li><p>如果两个网站在同一个服务器，使用 <code>Alias and mod_rewrite</code></p></li><li><p>如果是网站换了个新域名，创建一个CNAME (a DNS record that creates an alias pointing from one domain name to another)，结合<code>Alias or mod_rewrite</code></p></li></ul><h3 id="Make-Ajax-Cacheable-缓存Ajax请求"><a href="#Make-Ajax-Cacheable-缓存Ajax请求" class="headerlink" title="Make Ajax Cacheable 缓存Ajax请求"></a><a href="https://developer.yahoo.com/performance/rules.html#cacheajax" target="_blank" rel="noopener">Make Ajax Cacheable</a> 缓存Ajax请求</h3><p><strong>异步不等于即时</strong></p><p>优化异步请求：</p><ul><li>缓存Ajax请求</li></ul><p>何时使用旧的响应，何时发送新的请求？</p><blockquote><p>This could be done by adding a timestamp to the address book Ajax URL indicating the last time the user modified her address book, for example, &amp;t=1190241612. If the address book hasn’t been modified since the last download, the timestamp will be the same and the address book will be read from the browser’s cache eliminating an extra HTTP roundtrip. If the user has modified her address book, the timestamp ensures the new URL doesn’t match the cached response, and the browser will request the updated address book entries.</p></blockquote><p>Todo</p><h3 id="Postload-Components"><a href="#Postload-Components" class="headerlink" title="Postload Components"></a><a href="https://developer.yahoo.com/performance/rules.html#postload" target="_blank" rel="noopener">Postload Components</a></h3><h3 id="Preload-Components"><a href="#Preload-Components" class="headerlink" title="Preload Components"></a><a href="https://developer.yahoo.com/performance/rules.html#preload" target="_blank" rel="noopener">Preload Components</a></h3><h3 id="Reduce-the-Number-of-DOM-Elements"><a href="#Reduce-the-Number-of-DOM-Elements" class="headerlink" title="Reduce the Number of DOM Elements"></a><a href="https://developer.yahoo.com/performance/rules.html#min_dom" target="_blank" rel="noopener">Reduce the Number of DOM Elements</a></h3><h3 id="Split-Components-Across-Domains"><a href="#Split-Components-Across-Domains" class="headerlink" title="Split Components Across Domains"></a><a href="https://developer.yahoo.com/performance/rules.html#split" target="_blank" rel="noopener">Split Components Across Domains</a></h3><h3 id="Minimize-Number-of-iframes"><a href="#Minimize-Number-of-iframes" class="headerlink" title="Minimize Number of iframes"></a><a href="https://developer.yahoo.com/performance/rules.html#iframes" target="_blank" rel="noopener">Minimize Number of iframes</a></h3><h3 id="Avoid-404s"><a href="#Avoid-404s" class="headerlink" title="Avoid 404s"></a><a href="https://developer.yahoo.com/performance/rules.html#no404" target="_blank" rel="noopener">Avoid 404s</a></h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html?guccounter=1#csslink&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.yahoo.
      
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://yikayiyo.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="翻译" scheme="https://yikayiyo.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>surface测试</title>
    <link href="https://yikayiyo.github.io/2020/06/18/surface%E6%B5%8B%E8%AF%95/"/>
    <id>https://yikayiyo.github.io/2020/06/18/surface%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-18T09:21:24.000Z</published>
    <updated>2020-06-18T09:25:42.976Z</updated>
    
    <content type="html"><![CDATA[<p>surface上写博客，完事之后各端同步测试。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;surface上写博客，完事之后各端同步测试。&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.da
      
    
    </summary>
    
    
    
      <category term="杂" scheme="https://yikayiyo.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>git修改最近一次commit的信息</title>
    <link href="https://yikayiyo.github.io/2020/06/18/git%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
    <id>https://yikayiyo.github.io/2020/06/18/git%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%E7%9A%84%E4%BF%A1%E6%81%AF/</id>
    <published>2020-06-18T05:29:00.000Z</published>
    <updated>2020-06-18T05:40:50.201Z</updated>
    
    <content type="html"><![CDATA[<p>最近一次提交的信息不太对，已经push到远端。</p><img src="/2020/06/18/git%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%E7%9A%84%E4%BF%A1%E6%81%AF/xiugaiqian.png" class="" title="修改前"><p>修改步骤：</p><ol><li><p>输入命令，会进入编辑器</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改commit信息，退出编辑器</p></li><li><p>强制推送</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></tbody></table></figure></li></ol><p>修改后：</p><img src="/2020/06/18/git%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%E7%9A%84%E4%BF%A1%E6%81%AF/xiugaihou.png" class="" title="修改后"><p>注意到：<strong>commit号改变了</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一次提交的信息不太对，已经push到远端。&lt;/p&gt;
&lt;img src=&quot;/2020/06/18/git%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%E7%9A%84%E4%BF%A1%E6%81
      
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git" scheme="https://yikayiyo.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>几则笑话</title>
    <link href="https://yikayiyo.github.io/2020/02/22/%E5%87%A0%E5%88%99%E7%AC%91%E8%AF%9D/"/>
    <id>https://yikayiyo.github.io/2020/02/22/%E5%87%A0%E5%88%99%E7%AC%91%E8%AF%9D/</id>
    <published>2020-02-22T12:41:23.000Z</published>
    <updated>2020-06-22T12:49:57.606Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/02/22/%E5%87%A0%E5%88%99%E7%AC%91%E8%AF%9D/0222fig1.png" class="" title="weibo"><img src="/2020/02/22/%E5%87%A0%E5%88%99%E7%AC%91%E8%AF%9D/0222fig2.png" class="" title="weiboJinggao"><p>看到这则信息，下面有人举了几个前苏联的笑话，感觉很有意思，于是就去找了几个，笑得肚子疼。</p><blockquote><p>有个人在红场散发传单，被克格勃逮住了。那人辩解，我发的都是白纸。克格勃冷笑道，你以为我不知道你什么意思？</p></blockquote><blockquote><p>在苏共二十三次代表大会上，勃列日涅夫作报告，他问：“我们这里有没有敌人？”一个人回答：“有一个，他坐在第四排第十八号位子上。”勃问：“为什么他是敌人？”回答：“列宁说过敌人是不会打瞌睡的，我发现全场只有他一个人没有打瞌睡！”</p></blockquote><blockquote><p>“在苏联是否可以存在两党制？”“不，不可能，因为我们养不起。”</p></blockquote><blockquote><p>苏联特工对美国特工夸口道：“我们知道你们国家所有核导弹发射井的位置。”美国特工说：“那又有什么，我们知道你们未来20年全体政治局委员名单。”</p></blockquote><blockquote><p>一天戈尔巴乔夫到一个农场视察，看到有几头猪，就到猪旁边拍了一张照片。随行人员在照片上写上：戈尔巴乔夫和猪在一起，但又感到不妥。于是改成：猪和戈尔巴乔夫在一起，可还是感觉不对。最后把照片上的字改成：左起第三位是戈尔巴乔夫。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/02/22/%E5%87%A0%E5%88%99%E7%AC%91%E8%AF%9D/0222fig1.png&quot; class=&quot;&quot; title=&quot;weibo&quot;&gt;

&lt;img src=&quot;/2020/02/22/%E5%87%A0%E5%88%99%E
      
    
    </summary>
    
    
    
      <category term="杂" scheme="https://yikayiyo.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>健康的武汉</title>
    <link href="https://yikayiyo.github.io/2020/02/11/%E5%81%A5%E5%BA%B7%E7%9A%84%E6%AD%A6%E6%B1%89/"/>
    <id>https://yikayiyo.github.io/2020/02/11/%E5%81%A5%E5%BA%B7%E7%9A%84%E6%AD%A6%E6%B1%89/</id>
    <published>2020-02-11T12:35:30.000Z</published>
    <updated>2020-06-22T12:37:37.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个健康的社会不该只有一种声音。</p></blockquote><p>哪里也去不了，就不停地刷屏。</p><p>医护人员在医院休息室嚎啕大哭，火化工人在殡仪馆唱歌给自己打气，主妇在阳台上绝望地哭喊救命，电话里快要崩溃的发自党性的咆哮…</p><p>房间的门被焊被锁被堵，外出的车队在高速上排成长龙，为了活命想偷渡到隔壁省却发现河对岸一排一排的人在围追堵截…</p><p>和新闻里的完全不一样。</p><p>我听到了两种声音。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一个健康的社会不该只有一种声音。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;哪里也去不了，就不停地刷屏。&lt;/p&gt;
&lt;p&gt;医护人员在医院休息室嚎啕大哭，火化工人在殡仪馆唱歌给自己打气，主妇在阳台上绝望地哭喊救命，电话里快要崩溃的发自党性的咆哮…&lt;/p
      
    
    </summary>
    
    
    
      <category term="杂" scheme="https://yikayiyo.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>Data flow Synchronization and Pipelining</title>
    <link href="https://yikayiyo.github.io/2020/01/16/Pipelining/"/>
    <id>https://yikayiyo.github.io/2020/01/16/Pipelining/</id>
    <published>2020-01-16T04:02:58.000Z</published>
    <updated>2020-01-16T06:04:22.838Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.coursera.org/learn/parallel-programming-in-java/" target="_blank" rel="noopener">https://www.coursera.org/learn/parallel-programming-in-java/</a></p><h3 id="Split-phase-Barriers-with-Java-Phasers"><a href="#Split-phase-Barriers-with-Java-Phasers" class="headerlink" title="Split-phase Barriers with Java Phasers"></a>Split-phase Barriers with Java Phasers</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/parallel-programming-in-java/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.coursera.org/learn/para
      
    
    </summary>
    
    
    
      <category term="java" scheme="https://yikayiyo.github.io/tags/java/"/>
    
      <category term="并行编程" scheme="https://yikayiyo.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="学习" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Loop Parallelism</title>
    <link href="https://yikayiyo.github.io/2020/01/13/Loop%20Parallelism/"/>
    <id>https://yikayiyo.github.io/2020/01/13/Loop%20Parallelism/</id>
    <published>2020-01-13T05:49:17.000Z</published>
    <updated>2020-01-19T08:10:19.891Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Parallel-Loops"><a href="#Parallel-Loops" class="headerlink" title="Parallel Loops"></a>Parallel Loops</h3><p>未知循环次数，利用了指针的for循环<br>每一个迭代当作一个子任务，<code>finish</code>约束整个循环</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finish {</span><br><span class="line">    <span class="keyword">for</span> (p = head; p != <span class="keyword">null</span> ; p = p.next) </span><br><span class="line">        <span class="function">async <span class="title">compute</span><span class="params">(p)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>已知循环次数n，可以利用<code>forall</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector addition</span></span><br><span class="line">forall (i : [<span class="number">0</span>:n-<span class="number">1</span>]) </span><br><span class="line">    a[i] = b[i] + c[i]</span><br></pre></td></tr></tbody></table></figure><p>利用 Java streams，上述功能有更加简洁的表达方式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">a = IntStream.rangeClosed(<span class="number">0</span>, N-<span class="number">1</span>).parallel().toArray(i -&gt; b[i] + c[i]);</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h3 id="Parallel-Matrix-Multiplication"><a href="#Parallel-Matrix-Multiplication" class="headerlink" title="Parallel Matrix Multiplication"></a>Parallel Matrix Multiplication</h3><p>假设两个<code>n*n</code>的矩阵相乘，有</p><p>$$<br>c[i][j] = \sum_{k=0}^{n-1} a[i][k] * b[k][j]<br>$$<br>伪代码表示为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i : [<span class="number">0</span>:n-<span class="number">1</span>]) {</span><br><span class="line">  <span class="keyword">for</span>(j : [<span class="number">0</span>:n-<span class="number">1</span>]) { c[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(k : [<span class="number">0</span>:n-<span class="number">1</span>]) {</span><br><span class="line">      c[i][j] = c[i][j] + a[i][k]*b[k][j]</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>要替换成并行计算，可以简单地将外两层的for循环改成<code>forall</code></p><p>for-k 必须是线性的，因为这里有写数据（data race</p><h3 id="Barriers-in-Parallel-Loops"><a href="#Barriers-in-Parallel-Loops" class="headerlink" title="Barriers in Parallel Loops"></a>Barriers in Parallel Loops</h3><p>下面有一个简单的并行任务</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forall (i : [<span class="number">0</span>:n-<span class="number">1</span>]) {</span><br><span class="line">    myId = lookup(i); <span class="comment">// convert int to a string </span></span><br><span class="line">    print HELLO, myId;</span><br><span class="line">    print BYE, myId;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在不同的执行下会有不同顺序的结果（相同myId对应的HELLO一定在BYE之前</p><p>barriers可以将一个parallel loop分为不同的阶段</p><p>在两个print之间插入一个barrier，可以保证所有的HELLO出现在BYE之前</p><p>两种写法：</p><ul><li><p>在一个<code>forall</code>循环中插入barriers分为不同的阶段 (两个对应的print共享myId</p></li><li><p>为每个阶段写自己的<code>forall</code>循环 (借助 intermediate data structure  to communicate the myId values from one <em>forall</em> to another <em>forall</em> </p></li></ul><h3 id="Parallel-One-Dimensional-Iterative-Averaging"><a href="#Parallel-One-Dimensional-Iterative-Averaging" class="headerlink" title="Parallel One-Dimensional Iterative Averaging"></a>Parallel One-Dimensional Iterative Averaging</h3><p>Solve the recurrence<br>$$<br>X_i=\frac{X_{i-1}+X_{i+1}}2<br>$$</p><p>with boundary conditions<br>$$<br>X_0=0\ and\ X_n=1<br>$$</p><p><a href="https://en.wikipedia.org/wiki/Jacobi_method" target="_blank" rel="noopener">Jacobi method</a>利用两个数组oldX[] and newX[]迭代求解该问题，并行伪代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (iter: [<span class="number">0</span>:nsteps-<span class="number">1</span>]) {</span><br><span class="line">  forall (i: [<span class="number">1</span>:n-<span class="number">1</span>]) {</span><br><span class="line">    newX[i] = (oldX[i-<span class="number">1</span>] + oldX[i+<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">  }</span><br><span class="line">  swap pointers newX and oldX;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述方法创建了 <em>nsteps</em> <em>×</em> (<em>n</em> <em>−</em> 1) 个任务</p><p><strong>使用Barriers可以减少需要创建的任务个数</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">forall ( i: [<span class="number">1</span>:n-<span class="number">1</span>]) {</span><br><span class="line">  <span class="keyword">for</span> (iter: [<span class="number">0</span>:nsteps-<span class="number">1</span>]) {</span><br><span class="line">    newX[i] = (oldX[i-<span class="number">1</span>] + oldX[i+<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">    NEXT; <span class="comment">// Barrier</span></span><br><span class="line">    swap pointers newX and oldX;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述方法只需要创建 <em>(n-1)</em> 个任务</p><p>This is a significant improvement since creating tasks is usually more expensive than performing barrier operations.</p><h3 id="Iteration-Grouping-Chunking-in-Parallel-Loops"><a href="#Iteration-Grouping-Chunking-in-Parallel-Loops" class="headerlink" title="Iteration Grouping/Chunking in Parallel Loops"></a>Iteration Grouping/Chunking in Parallel Loops</h3><p>对于向量相加问题</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forall (i : [<span class="number">0</span>:n-<span class="number">1</span>]) a[i] = b[i] + c[i]</span><br></pre></td></tr></tbody></table></figure><p>上述方法创建了n个任务，当n很大时overheads也会很大</p><p>解决方法</p><p><strong>分组</strong>（<em>loop</em> <em>chunking</em> or <em>iteration grouping</em></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forall (g:[<span class="number">0</span>:ng-<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">for</span> (i : mygroup(g, ng, [<span class="number">0</span>:n-<span class="number">1</span>])) a[i] = b[i] + c[i]</span><br></pre></td></tr></tbody></table></figure><p>上述方法将任务个数从 <strong>n</strong> 降到了 <strong>ng</strong>（分组个数</p><p>分组方法有两种：</p><ul><li>block<ul><li>将连续的迭代分为一组</li></ul></li><li>cyclic<ul><li>将同余类迭代（ iterations in the same congruence class，分为一组</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Parallel-Loops&quot;&gt;&lt;a href=&quot;#Parallel-Loops&quot; class=&quot;headerlink&quot; title=&quot;Parallel Loops&quot;&gt;&lt;/a&gt;Parallel Loops&lt;/h3&gt;&lt;p&gt;未知循环次数，利用了指针的for循环&lt;br&gt;每一个迭代当作一个子任务，&lt;code&gt;finish&lt;/code&gt;约束整个循环&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;finish {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (p = head; p != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ; p = p.next) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;async &lt;span class=&quot;title&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(p)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;已知循环次数n，可以利用&lt;code&gt;forall&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// vector addition&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;forall (i : [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a[i] = b[i] + c[i]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;利用 Java streams，上述功能有更加简洁的表达方式&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = IntStream.rangeClosed(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, N-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;).parallel().toArray(i -&amp;gt; b[i] + c[i]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://yikayiyo.github.io/tags/java/"/>
    
      <category term="并行编程" scheme="https://yikayiyo.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Functional Parallelism</title>
    <link href="https://yikayiyo.github.io/2020/01/10/Functional-Parallelism/"/>
    <id>https://yikayiyo.github.io/2020/01/10/Functional-Parallelism/</id>
    <published>2020-01-10T06:20:46.000Z</published>
    <updated>2020-01-19T07:38:55.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Future-Tasks"><a href="#Future-Tasks" class="headerlink" title="Future Tasks"></a><strong>Future Tasks</strong></h3><p><code>future tasks</code></p><ul><li>tasks with <strong>return values</strong></li></ul><p><code>future objects</code>（also known as <code>promise objects</code></p><ul><li><p>a “handle” for accessing a task’s return value</p></li><li><p>两个主要操作：</p><ul><li><p>Assignment，形式如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = future { </span><br><span class="line">    ⟨ task-with-<span class="keyword">return</span>-value ⟩ </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>future object 被限制为只能一次赋值（<em>single assignment</em>，类似于final变量</p><p>future task 完成后 future object就不能修改了</p></li><li><p>Blocking read</p><ul><li>A.get() 读操作会等待，直到与 future object 关联的 task 完成，将该任务的返回值作为 A.get() 的值</li><li>A.get() 之后的任何statement S 开始执行时与A关联的任务已经完成</li></ul></li></ul></li></ul><a id="more"></a><h3 id="Creating-Future-Tasks-in-Java’s-Fork-Join-Framework"><a href="#Creating-Future-Tasks-in-Java’s-Fork-Join-Framework" class="headerlink" title="Creating Future Tasks in Java’s Fork/Join Framework"></a><strong>Creating Future Tasks in Java’s Fork/Join Framework</strong></h3><p>future tasks和regular tasks的一些关键不同：</p><ol><li>future tasks 继承自FJ框架的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html" target="_blank" rel="noopener">RecursiveTask</a> 类，regular tasks 继承自 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveAction.html" target="_blank" rel="noopener">RecursiveAction</a> 类</li><li>future task 的 <strong>compute()</strong> 方法必须有 non-void 的返回值</li><li>*<em>left.join() *</em>这样的方法调用都会等left指向的任务执行，只是future task 有返回值</li></ol><h3 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a><strong>Memoization</strong></h3><p>记录f(x)的执行结果，防止重复计算</p><ol><li><p>创建特定的数据结构，记录<br>$$<br>{(x_1,y_1=f(x_1)),(x_2,y_2=f(x_2)),…}<br>$$</p></li><li><p>当出现 f 的调用时先在记录中查找</p></li></ol><p>future task在这里非常适合，记录的形式变为了<br>$$<br>{(x_1,y_1=future(f(x_1))),(x_2,y_2=future(f(x_2))),…}<br>$$</p><p>对于输入x，如果对应的future对象已经创建，则可以调用该对象的 get() 方法</p><h3 id="Java-Streams"><a href="#Java-Streams" class="headerlink" title="Java Streams"></a><strong>Java Streams</strong></h3><p>操作集合对象除了<code>for loop</code>还可以利用<code>Java streams</code>提供的API</p><p>下面的例子求注册学生的平均年龄</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">students.stream()</span><br><span class="line">    .filter(s -&gt; s.getStatus() == Student.ACTIVE)</span><br><span class="line">    .mapToInt(a -&gt; a.getAge())</span><br><span class="line">    .average();</span><br></pre></td></tr></tbody></table></figure><p>Java streams 提供了并行编程的API</p><p>上面代码的 <em>students.stream()</em> 替换为 <em>students.parallelStream()</em> 或者 <em>Stream.of(students).parallel()</em> 就可以了</p><h3 id="Determinism-and-Data-Races"><a href="#Determinism-and-Data-Races" class="headerlink" title="Determinism and Data Races"></a><strong>Determinism and Data Races</strong></h3><p><em>functionally deterministic</em></p><ul><li>A parallel program is said to be <em>functionally deterministic</em> if it always computes the same answer when given the same input</li></ul><p><em>structurally deterministic</em></p><ul><li>It always computes the same computation graph, when given the same input. </li></ul><p>没有数据竞争不足以保证确定性</p><p>有数据竞争也不意味着程序的不确定性</p><p>带有数据竞争的不确定程序，每次产生的结果不同，但是可能每个结果都是可接受的！！e.g., different locations for a search pattern in a target string</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Future-Tasks&quot;&gt;&lt;a href=&quot;#Future-Tasks&quot; class=&quot;headerlink&quot; title=&quot;Future Tasks&quot;&gt;&lt;/a&gt;&lt;strong&gt;Future Tasks&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;future tasks&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tasks with &lt;strong&gt;return values&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;future objects&lt;/code&gt;（also known as &lt;code&gt;promise objects&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a “handle” for accessing a task’s return value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个主要操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Assignment，形式如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A = future { &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ⟨ task-with-&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;-value ⟩ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;future object 被限制为只能一次赋值（&lt;em&gt;single assignment&lt;/em&gt;，类似于final变量&lt;/p&gt;
&lt;p&gt;future task 完成后 future object就不能修改了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Blocking read&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A.get() 读操作会等待，直到与 future object 关联的 task 完成，将该任务的返回值作为 A.get() 的值&lt;/li&gt;
&lt;li&gt;A.get() 之后的任何statement S 开始执行时与A关联的任务已经完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://yikayiyo.github.io/tags/java/"/>
    
      <category term="并行编程" scheme="https://yikayiyo.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Task Parallelism</title>
    <link href="https://yikayiyo.github.io/2020/01/08/Task%20Parallelism/"/>
    <id>https://yikayiyo.github.io/2020/01/08/Task%20Parallelism/</id>
    <published>2020-01-08T10:59:19.000Z</published>
    <updated>2020-01-09T11:58:58.049Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.coursera.org/learn/parallel-programming-in-java/" target="_blank" rel="noopener">https://www.coursera.org/learn/parallel-programming-in-java/</a></p><h3 id="Task-Creation-and-Termination-Async-Finish"><a href="#Task-Creation-and-Termination-Async-Finish" class="headerlink" title="Task Creation and Termination (Async, Finish)"></a>Task Creation and Termination (Async, Finish)</h3><p>以数组求和作为例子</p><p>为了求得数组的和，可以将数组分为前后两个部分。两部分的求和可以并行执行，但是在求总和之前要保证两个子任务已经完成。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">finish {</span><br><span class="line">  async SUM1;  <span class="comment">// asynchronously compute sum of the lower half of the array</span></span><br><span class="line">  SUM2;  <span class="comment">// compute sum of the upper half of the array in parallel with SUM1</span></span><br><span class="line">}</span><br><span class="line">SUM;  <span class="comment">// combine the two partial sums after both SUM1 and SUM2 have finished</span></span><br></pre></td></tr></tbody></table></figure><p><code>async &lt;stmt1&gt;</code> ：父任务创建子任务执行<code>&lt;stmt1&gt;</code>，并且是并行于父任务的其余部分执行</p><p>上面的伪代码中，<code>async SUM1;</code>创建子任务SUM1，和SUM2并行执行</p><p><code>finish &lt;stmt2&gt;</code>：父任务执行<code>&lt;stmt2&gt;</code>，并且等待<code>&lt;stmt2&gt;以及其中创建的异步任务</code>完成</p><p>上例中，父任务等待SUM1和SUM2完成，才能执行SUM</p><h3 id="Tasks-in-Java’s-Fork-Join-Framework"><a href="#Tasks-in-Java’s-Fork-Join-Framework" class="headerlink" title="Tasks in Java’s Fork/Join Framework"></a>Tasks in Java’s Fork/Join Framework</h3><p>数组求和的<strong>分治</strong>写法<a id="more"></a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ASum</span></span>{</span><br><span class="line">  <span class="keyword">int</span>[] A; <span class="comment">// input array</span></span><br><span class="line">  <span class="keyword">int</span> LO, HI; <span class="comment">// subrange</span></span><br><span class="line">  <span class="keyword">int</span> SUM; <span class="comment">// return value</span></span><br><span class="line">  ASum(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high){</span><br><span class="line">    <span class="keyword">this</span>.A = array;</span><br><span class="line">    <span class="keyword">this</span>.LO = low;</span><br><span class="line">    <span class="keyword">this</span>.HI = high;</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (LO==HI) SUM = A[LO];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LO&gt;HI) SUM = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">int</span> MID = (LO+HI)/<span class="number">2</span>;</span><br><span class="line">      L = <span class="keyword">new</span> ASum(A, LO, MID);</span><br><span class="line">      R = <span class="keyword">new</span> ASum(A, MID, HI);</span><br><span class="line">      L.compute();</span><br><span class="line">      R.compute();</span><br><span class="line">      SUM = L.SUM + R.SUM;</span><br><span class="line">    }</span><br><span class="line">  } <span class="comment">// compute()</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并行写法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASum</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>{  <span class="comment">//没有返回值的继承RecursiveAction，比如对数组排序</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> seqThreshold = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">int</span> lo, hi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ASum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.lo = low;</span><br><span class="line">        <span class="keyword">this</span>.hi = high;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((hi - lo) &lt;= seqThreshold) {  <span class="comment">//不再切分为子任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i++)</span><br><span class="line">                res += array[i];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            ASum L = <span class="keyword">new</span> ASum(array, lo, mid);</span><br><span class="line">            ASum R = <span class="keyword">new</span> ASum(array, mid, hi);</span><br><span class="line">            <span class="comment">// L.fork();</span></span><br><span class="line">            <span class="comment">// R.fork();</span></span><br><span class="line">            invokeAll(L, R);  <span class="comment">//和上面的两句等价</span></span><br><span class="line">            res += L.join() + R.join();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumOfInts</span><span class="params">(ForkJoinPool pool, <span class="keyword">int</span>[] array)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        ASum a = <span class="keyword">new</span> ASum(array, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> pool.invoke(a);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] nums = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> };</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        System.out.println(sumOfInts(pool, nums));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Computation-Graphs-Work-Span"><a href="#Computation-Graphs-Work-Span" class="headerlink" title="Computation Graphs, Work, Span"></a>Computation Graphs, Work, Span</h3><h4 id="Computation-Graphs"><a href="#Computation-Graphs" class="headerlink" title="Computation Graphs"></a>Computation Graphs</h4><p>Computation Graphs (CGs) model the execution of a parallel program as a <a href="http://en.wikipedia.org/wiki/Partially_ordered_set" target="_blank" rel="noopener">partially ordered set</a>.</p><p>A CG consist of:</p><ul><li>A set of <em>vertices</em> or <em>nodes</em>, in which each node represents a <em>step</em> consisting of an <strong>arbitrary sequential computation</strong>.</li><li>A set of <em>directed</em> <em>edges</em> that represent <strong>ordering constraints</strong> among steps.</li></ul><p>对于fork-join框架，可以将这些有向边分为三类：</p><ul><li><em>Continue</em> edges，连接任务中顺序执行的步骤</li><li>Fork edges，将fork操作连接到子任务的第一个步骤</li><li>join edges connect the last step of a task to all <em>join</em> operations on that task</li></ul><p>一个小例子</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S1</span><br><span class="line">fork S2</span><br><span class="line">S3</span><br><span class="line">join S2  <span class="comment">// 这里join S2发生在S4之前</span></span><br><span class="line">S4</span><br><span class="line"><span class="comment">// S5 如果有的话，连接到S4之后</span></span><br></pre></td></tr></tbody></table></figure><p>对应的CG为</p><img src="/2020/01/08/Task%20Parallelism/image-20200108094903279.png" class=""><h4 id="CGs上的data-race"><a href="#CGs上的data-race" class="headerlink" title="CGs上的data race"></a>CGs上的data race</h4><p>没有边连接的两个节点同时写或者读写相同的位置时发生data race</p><h4 id="CGs上的理想并行程度-（ideal-parallelism）"><a href="#CGs上的理想并行程度-（ideal-parallelism）" class="headerlink" title="CGs上的理想并行程度 （ideal parallelism）"></a>CGs上的理想并行程度 （<em>ideal parallelism</em>）</h4><p>与计算机的实际并行性无关<br>$$<br>ideal,parallelism = \frac{WORK(G)}{SPAN(G)} \tag{1}<br>$$</p><p>其中：</p><ul><li>WORK(G)为G中所有节点执行时间之和</li><li>SPAN(G)为G中关键路径上节点的执行时间之和，上例中SPAN(G)为 <strong>max((S1,S3,S4), (S1,S2,S4))</strong></li></ul><h3 id="Multiprocessor-Scheduling-Parallel-Speedup"><a href="#Multiprocessor-Scheduling-Parallel-Speedup" class="headerlink" title="Multiprocessor Scheduling, Parallel Speedup"></a>Multiprocessor Scheduling, Parallel Speedup</h3><h4 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h4><p>有P个处理器，每个处理器都相同，每一个节点的执行时间都是固定的（不管在那个处理器上），处理器都是<strong>贪心</strong>地执行任务<br>T_p表示在p个处理器上执行一个CG所花的时间,<br>相同的P个处理器，相同的CG，不同的调度算法也可能对应不同的T_p</p><p>$$<br>T_{\infty} \le T_p \le T_1<br>$$</p><h4 id="Speedup-P"><a href="#Speedup-P" class="headerlink" title="Speedup(P)"></a>Speedup(P)</h4><p>the parallel speedup for a given schedule of a CG on <em>P</em> processors，满足下面：<br>$$<br>Speedup(P) = \frac{T_1}{T_P} \tag{2}<br>$$</p><p>$$<br>Speedup(P) \le P \tag{3}<br>$$</p><p>$$<br>Speedup(P) \le \frac {WORK}{SPAN} \tag{4}<br>$$</p><p>（3）表示P个处理器不能带来P倍的加速</p><p>（4）表示现实骨感，理想丰满</p><h3 id="Amdahl’s-Law"><a href="#Amdahl’s-Law" class="headerlink" title="Amdahl’s Law"></a><strong>Amdahl’s Law</strong></h3><p>if <em>q</em> <em>≤</em> 1 is the fraction of <em>WORK</em> in a parallel program that must be executed <em>sequentially</em>, then the best speedup that can be obtained for that program for any number of processors, <em>P</em> , is <em>Speedup(P)</em> <em>≤</em> 1<em>/q</em>.</p><p>例如，如果线性工作占比为0.5，则不管处理器个数再多，有<em>Speedup(P)</em> <em>≤</em> 2</p><p>因为有<br>$$<br>WORK(G)*q \leq SPAN(G) \tag{5}\<br>==&gt;  \frac{WORK(G)}{SPAN(G)} \leq \frac{1}{q}<br>$$<br>上式表示关键路径用时不小于任务中线性部分的用时</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/parallel-programming-in-java/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.coursera.org/learn/parallel-programming-in-java/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Task-Creation-and-Termination-Async-Finish&quot;&gt;&lt;a href=&quot;#Task-Creation-and-Termination-Async-Finish&quot; class=&quot;headerlink&quot; title=&quot;Task Creation and Termination (Async, Finish)&quot;&gt;&lt;/a&gt;Task Creation and Termination (Async, Finish)&lt;/h3&gt;&lt;p&gt;以数组求和作为例子&lt;/p&gt;
&lt;p&gt;为了求得数组的和，可以将数组分为前后两个部分。两部分的求和可以并行执行，但是在求总和之前要保证两个子任务已经完成。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;finish {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  async SUM1;  &lt;span class=&quot;comment&quot;&gt;// asynchronously compute sum of the lower half of the array&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  SUM2;  &lt;span class=&quot;comment&quot;&gt;// compute sum of the upper half of the array in parallel with SUM1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SUM;  &lt;span class=&quot;comment&quot;&gt;// combine the two partial sums after both SUM1 and SUM2 have finished&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;async &amp;lt;stmt1&amp;gt;&lt;/code&gt; ：父任务创建子任务执行&lt;code&gt;&amp;lt;stmt1&amp;gt;&lt;/code&gt;，并且是并行于父任务的其余部分执行&lt;/p&gt;
&lt;p&gt;上面的伪代码中，&lt;code&gt;async SUM1;&lt;/code&gt;创建子任务SUM1，和SUM2并行执行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finish &amp;lt;stmt2&amp;gt;&lt;/code&gt;：父任务执行&lt;code&gt;&amp;lt;stmt2&amp;gt;&lt;/code&gt;，并且等待&lt;code&gt;&amp;lt;stmt2&amp;gt;以及其中创建的异步任务&lt;/code&gt;完成&lt;/p&gt;
&lt;p&gt;上例中，父任务等待SUM1和SUM2完成，才能执行SUM&lt;/p&gt;
&lt;h3 id=&quot;Tasks-in-Java’s-Fork-Join-Framework&quot;&gt;&lt;a href=&quot;#Tasks-in-Java’s-Fork-Join-Framework&quot; class=&quot;headerlink&quot; title=&quot;Tasks in Java’s Fork/Join Framework&quot;&gt;&lt;/a&gt;Tasks in Java’s Fork/Join Framework&lt;/h3&gt;&lt;p&gt;数组求和的&lt;strong&gt;分治&lt;/strong&gt;写法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://yikayiyo.github.io/tags/java/"/>
    
      <category term="并行编程" scheme="https://yikayiyo.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Markdown显示__init__.py</title>
    <link href="https://yikayiyo.github.io/2019/12/25/Markdown%E6%98%BE%E7%A4%BA__/"/>
    <id>https://yikayiyo.github.io/2019/12/25/Markdown%E6%98%BE%E7%A4%BA__/</id>
    <published>2019-12-25T04:59:36.000Z</published>
    <updated>2020-06-18T08:17:51.406Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown语法中双下划线 <code>__</code> 和双星 <code>**</code> 都是强调作用<br>python中的 <strong>init</strong>.py就显示成这个样子了 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f612.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f612.png?v8">😒</span></p><p>可以使用反引号将其包含，显示效果: <code>__init__.py</code> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8">😋</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Markdown语法中双下划线 &lt;code&gt;__&lt;/code&gt; 和双星 &lt;code&gt;**&lt;/code&gt; 都是强调作用&lt;br&gt;python中的 &lt;strong&gt;init&lt;/strong&gt;.py就显示成这个样子了 &lt;span class=&quot;github-emoji&quot; style
      
    
    </summary>
    
    
    
      <category term="杂" scheme="https://yikayiyo.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>记录一次源码阅读</title>
    <link href="https://yikayiyo.github.io/2019/05/12/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://yikayiyo.github.io/2019/05/12/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2019-05-12T08:14:00.000Z</published>
    <updated>2019-05-21T10:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/12/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.svg" class="" title="记录一次源码阅读"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/12/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.svg&quot; class=&quot;&quot; title=&quot;记录一次源码阅
      
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python，读书笔记" scheme="https://yikayiyo.github.io/tags/python%EF%BC%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>DevOps for dummies</title>
    <link href="https://yikayiyo.github.io/2019/02/25/devops/"/>
    <id>https://yikayiyo.github.io/2019/02/25/devops/</id>
    <published>2019-02-25T09:19:00.000Z</published>
    <updated>2019-03-05T14:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>business-driven, people, practice, tools</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>Develop and test against production-like systems </li><li>Deploy with repeatable, reliable processes</li><li>Monitor and validate operational quality</li><li>Amplify feedback loops<a id="more"></a><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3></li></ul><img src="/2019/02/25/devops/devops.png" class="" title="devops"><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ul><li>DevOps isn’t the goal. It helps you reach your goals</li><li>Any kind of system that needs <strong>rapid</strong> delivery of <strong>innovation</strong> requires DevOps</li></ul><ul><li><p>In broad terms, DevOps is an approach based on <strong>lean and agile principles</strong> in which business owners and the development, operations, and quality assurance departments collaborate to deliver software <strong>in a continuous manner</strong> that enables the business to more quickly seize market opportunities and reduce the time to include customer feedback</p></li><li><p>A true DevOps approach includes lines of business, practitioners, executives, partners, suppliers, and so on</p></li><li><p><strong>Continuous testing</strong> is facilitated by adopting capabilities like <strong>automated testing</strong> and <strong>service virtualization</strong></p></li><li><p>software-defined environments enable you to capture infrastructure as a kind of programmable and repeatable pattern, thereby accelerating deployments</p></li><li><p>Collaboration and communication across stakeholders — that’s the culture of DevOps.</p></li><li><p>Giving all stakeholders <strong>visibility</strong> into a project’s goals and status is crucial for building a DevOps culture based on trust and collaboration.</p></li><li><p>Processes define what those people do. Your organization can have a great culture of collaboration, but if people are doing the wrong things or doing the right things in the wrong way, failure is still likely.</p></li><li><p>Adopting continuous delivery typically is the most critical part of adopting DevOps.</p></li><li><p>From a process perspective, you need to adopt processes in three areas to enable <strong>continuous testing</strong>:</p><p>✓ Test environment provisioning and configuration</p><p>✓ Test data management</p><p>✓ Test integration, function, performance, and security</p></li><li><p>If an organization is building or maintaining multiple applications, everything it does has to be repeatable, in a reliable manner, to ensure quality across all applications</p></li><li><p>Start by focusing on the critical parts of organization — not everything all at once — and then gradually broaden to include all stages</p></li><li><p>The build stage is where the code is compiled to create and unit test the binaries to be deployed. Multiple build tools may be used in this stage, based on cross-platform and cross-technology needs</p></li><li><p>Development organizations typically use <strong>build servers</strong> to facilitate the large number of builds required on an ongoing basis to enable continuous integration</p></li><li><p>For any organization that wants to enable <strong>continuous testing</strong>, <strong>managing test data</strong> is an essential function</p></li><li><p>end-to-end Develop/Test environments =  cloud environments + deployment automation + service virtualization</p></li><li><p>Cloud without DevOps means not leveraging all the benefits of cloud</p></li><li><p>When adopting cloud, you first want to decide on the scope of responsibility that you plan to hand over to the cloud platform and what responsibility you want to take on yourself</p></li><li><p>two primary service models for cloud: Infrastructure as a Service (<strong>IaaS</strong>) and Platform as a Service (<strong>PaaS</strong>)</p></li><li><p>treats infrastructure as code best practices：</p><ul><li>Treat pattern definitions, script packages, and services as code</li><li>version everything</li><li>Automate deployment of topology patterns to the cloud</li><li>Manage versions of patterns across multiple cloud environments</li><li>Automate the testing of patterns</li><li>Cleanup catalog resources to avoid sprawl</li></ul></li><li><p>Ten DevOps myths:</p><ul><li>DevOps Is Only for “Born on the Web” Shops</li><li>DevOps Is Operations Learning How to Code</li><li>DevOps Is Just for Development and Operations</li><li>DevOps Isn’t for ITIL Shops</li><li>DevOps Isn’t for Regulated Industries</li><li>DevOps Isn’t for Outsourced Development</li><li>No Cloud Means No DevOps</li><li>DevOps Isn’t for Large, Complex Systems</li><li>DevOps Is Only about Communication</li><li>DevOps Means Continuous Change Deployment</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关键词&quot;&gt;&lt;a href=&quot;#关键词&quot; class=&quot;headerlink&quot; title=&quot;关键词&quot;&gt;&lt;/a&gt;关键词&lt;/h3&gt;&lt;p&gt;business-driven, people, practice, tools&lt;/p&gt;
&lt;h3 id=&quot;原则&quot;&gt;&lt;a href=&quot;#原则&quot; class=&quot;headerlink&quot; title=&quot;原则&quot;&gt;&lt;/a&gt;原则&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Develop and test against production-like systems &lt;/li&gt;
&lt;li&gt;Deploy with repeatable, reliable processes&lt;/li&gt;
&lt;li&gt;Monitor and validate operational quality&lt;/li&gt;
&lt;li&gt;Amplify feedback loops&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="https://yikayiyo.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>异步网络编程</title>
    <link href="https://yikayiyo.github.io/2018/11/25/python%E5%BC%82%E6%AD%A5/"/>
    <id>https://yikayiyo.github.io/2018/11/25/python%E5%BC%82%E6%AD%A5/</id>
    <published>2018-11-25T08:14:00.000Z</published>
    <updated>2019-05-18T09:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>协程、生成器</p><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p>协程：又称作Coroutine。从字面上来理解，即协同运行的例程，它是比是线程（thread）更细量级的用户态线程，特点是允许用户的主动调用和主动退出，挂起当前的例程然后返回值或去执行其他任务，接着返回到原来停下的点继续执行</p></li><li><p>有时间再写。。。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关键词&quot;&gt;&lt;a href=&quot;#关键词&quot; class=&quot;headerlink&quot; title=&quot;关键词&quot;&gt;&lt;/a&gt;关键词&lt;/h3&gt;&lt;p&gt;协程、生成器&lt;/p&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;
      
    
    </summary>
    
    
    
      <category term="python" scheme="https://yikayiyo.github.io/tags/python/"/>
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>遍历二叉树</title>
    <link href="https://yikayiyo.github.io/2018/06/19/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://yikayiyo.github.io/2018/06/19/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2018-06-19T01:47:01.000Z</published>
    <updated>2020-06-19T06:05:03.130Z</updated>
    
    <content type="html"><![CDATA[<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8">⭐</span>非递归实现</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        cur = root  <span class="comment">#借助临时的cur，不要修改root</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:  <span class="comment"># 一直往左走，全部入栈</span></span><br><span class="line">                stack.append(cur) </span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 取出栈顶节点，处理，再处理该节点的右子树   </span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)  </span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>写法一</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        cur = root</span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)  <span class="comment"># 每一个节点都放入栈中</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()  <span class="comment"># 这里pop出来的是已经访问过的节点</span></span><br><span class="line">                cur = cur.right  <span class="comment"># 还需要指向右子树</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8">❤</span>写法二：<a id="more"></a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        cur = root</span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur.right)  <span class="comment"># 栈中直接放入已访问节点的右子树</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()  <span class="comment"># 取到的就是右子树根节点</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><p> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f610.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f610.png?v8">😐</span>写法三：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack, output = [root], []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                output.append(root.val)</span><br><span class="line">                <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment">#右子树先入栈，左子树后入栈</span></span><br><span class="line">                    stack.append(root.right)</span><br><span class="line">                <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    stack.append(root.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></tbody></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p><p>对于当前节点，只有其<strong>右子树已经处理</strong>或<strong>没有右子树</strong>时，才能处理它。</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f440.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f440.png?v8">👀</span>这里要记录一个last_visited节点​​</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        cur = root</span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        last_visited = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = stack[<span class="number">-1</span>]  <span class="comment"># 定位根节点，这个地方不能pop(),因为可能有右子树</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tmp.right <span class="keyword">or</span> tmp.right == last_visited:  </span><br><span class="line">                    <span class="comment"># 没有右子树或者已经访问过了，处理当前根节点</span></span><br><span class="line">                    res.append(tmp.val)</span><br><span class="line">                    last_visited = tmp</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur = tmp.right  <span class="comment"># 右子树未访问，处理右子树</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8">❤</span>后序遍历可以借前序遍历的一个变体实现，<strong>先根右左,再倒置</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        cur = root</span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur.left)  <span class="comment"># 栈中直接放入已访问节点的左子树</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()  <span class="comment"># 取到的就是左子树根节点</span></span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span class=&quot;github-emoji&quot; style=&quot;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8) center/contain&quot; data-src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8&quot;&gt;⭐&lt;/span&gt;非递归实现&lt;/p&gt;
&lt;h3 id=&quot;中序遍历&quot;&gt;&lt;a href=&quot;#中序遍历&quot; class=&quot;headerlink&quot; title=&quot;中序遍历&quot;&gt;&lt;/a&gt;中序遍历&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inorderTraversal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, root: TreeNode)&lt;/span&gt; -&amp;gt; List[int]:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cur = root  &lt;span class=&quot;comment&quot;&gt;#借助临时的cur，不要修改root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stack = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; cur &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; stack:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cur:  &lt;span class=&quot;comment&quot;&gt;# 一直往左走，全部入栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stack.append(cur) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = cur.left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:  &lt;span class=&quot;comment&quot;&gt;# 取出栈顶节点，处理，再处理该节点的右子树   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = stack.pop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res.append(cur.val)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = cur.right&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;前序遍历&quot;&gt;&lt;a href=&quot;#前序遍历&quot; class=&quot;headerlink&quot; title=&quot;前序遍历&quot;&gt;&lt;/a&gt;前序遍历&lt;/h3&gt;&lt;p&gt;写法一&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;preorderTraversal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, root: TreeNode)&lt;/span&gt; -&amp;gt; List[int]:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cur = root&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stack = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; cur &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; stack:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cur:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stack.append(cur)  &lt;span class=&quot;comment&quot;&gt;# 每一个节点都放入栈中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res.append(cur.val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = cur.left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = stack.pop()  &lt;span class=&quot;comment&quot;&gt;# 这里pop出来的是已经访问过的节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = cur.right  &lt;span class=&quot;comment&quot;&gt;# 还需要指向右子树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;span class=&quot;github-emoji&quot; style=&quot;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8) center/contain&quot; data-src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8&quot;&gt;❤&lt;/span&gt;写法二：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记，二叉树" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>word2vec + manage experiments</title>
    <link href="https://yikayiyo.github.io/2018/04/05/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    <id>https://yikayiyo.github.io/2018/04/05/%E8%AF%8D%E5%90%91%E9%87%8F/</id>
    <published>2018-04-05T14:30:10.000Z</published>
    <updated>2018-07-25T06:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键词：model base, variable sharing, model sharing</p><h4 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h4><ul><li>文本的分布式表示是许多自然语言处理任务的基础</li><li>word2vec是用来生成词语分布式表示的一组模型</li><li>主要有两种模型：skip-gram和CBOW</li><li>算法角度：CBOW模型从上下文词预测目标词，skip-gram模型从目标词预测上下文词<a id="more"></a></li><li>统计角度：CBOW模型将an entire context as one observation，这样做smoothes over了许多分布信息，适合小一些的数据集上；skip-gram模型则是将<strong>each</strong> context-target pair as a new observation，在larger datasets上表现更好</li><li>训练词向量：定义一个单层网络，任务是给定中心词预测词典中的词作为上下文词的概率，我们最后要的是隐含层的权重参数</li><li>使用 softmax 来获得可能的目标词的分布，分母要对字典中的所有词取指数再求和，计算是瓶颈</li><li>规避瓶颈的方法：层次化的softmax 和基于采样的 softmax </li><li>文章*<em>Distributed Representations of Words and Phrases and their Compositionality *</em>指出，训练skip-gram模型时，与更复杂的分层softmax相比，负采样可以加快训练速度，为频繁词汇提供更好的向量表示</li><li>负采样实际上是一种称为噪声对比估计（NCE）的简化模型，基于假设，如噪声样本的数量k和噪声样本的分布Q满足kQ(w) = 1，来简化计算；理论上不能保证其导数和softmax梯度一致</li><li>NCE则随着noise样本增多，提供了这种保证</li><li>负采样和NCE只在训练时有用</li></ul><h4 id="Implementing"><a href="#Implementing" class="headerlink" title="Implementing"></a>Implementing</h4><ul><li>词的indices作为输入（一个scalar），</li><li>BATCH_SIZE的样本，输入维度为[BATCH_SIZE]，输出维度为[BATCH_SIZE,1]</li><li>词向量矩阵维度为[VOCAB_SIZE,EMBED_SIZE]，每一行代表一个词向量</li><li>利用tf.nn.embedding_lookup()找中心词对应的向量，免去了不必要的计算（matrix and onehot vector）</li><li>loss使用tf.nn.nce_loss()，optimizer使用GradientDescentOptimizer</li></ul><h4 id="Structure-TF-models"><a href="#Structure-TF-models" class="headerlink" title="Structure TF models"></a>Structure TF models</h4><p>定义图</p><ul><li>导入数据（placeholder or tf.data）</li><li>定义权重</li><li>定义模型</li><li>定义损失函数</li><li>定义优化器</li></ul><p>执行图</p><ul><li>初始化所有变量</li><li>初始化迭代器或者feed in训练数据</li><li>数据经过模型得到结果</li><li>计算cost</li><li>调整模型参数使得cost最小或者最大</li></ul><p>build model as a class in order to reuse easily.</p><h4 id="Variable-sharing"><a href="#Variable-sharing" class="headerlink" title="Variable sharing"></a>Variable sharing</h4><p>Name scope</p><p>将相关的ops放在一个name_scope下，这样得到的图在TensorBoard上是一块一块的，更加整洁。<br>TensorBoard图中三种边：</p><ol><li>灰实边：数据流</li><li>橙实边：参考边，op_lest影响op_right</li><li>灰虚边：控制依赖边，op_left依赖于op_right</li></ol><p>Variable scope</p><p>和Name scope一样都创建了namespace，调用tf.variable_scope(“name”)会隐式地调用tf.name_scope(“name”)，Variable scope主要功能是促进变量共享（facilitate variable sharing)<br>为实现变量共享:</p><ol><li>使用 <strong>tf.get_variable()</strong>,它会在创建变量之前检查其是否存在</li><li>将所用到的变量放到一个VarScope，将这个VarScope设置为可复用的（reusable）</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fully_connected</span><span class="params">(x,output_dim,scope_name)</span>:</span> <span class="comment">#基础组件：全连接层</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(scope_name):</span><br><span class="line">        w = tf.get_variable(<span class="string">"weights"</span>,[x.shape[<span class="number">1</span>],output_dim],initializer=tf.random_normal_initializer())</span><br><span class="line">        b = tf.get_variable(<span class="string">"bias"</span>,[output_dim],initializer= tf.constant_initializer(<span class="number">0.0</span>))</span><br><span class="line">        <span class="keyword">return</span> tf.matmul(x,w) + b</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_hidden_layer</span><span class="params">(x)</span>:</span>  <span class="comment">#网络结构：两个全连接层</span></span><br><span class="line">    h1 = fully_connected(x,<span class="number">50</span>,<span class="string">'h1'</span>)</span><br><span class="line">    h2 = fully_connected(h1,<span class="number">10</span>,<span class="string">'h2'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">'two_layers'</span>) <span class="keyword">as</span> scope: <span class="comment">#调用网络，输入x1，x2</span></span><br><span class="line">    logits1 = two_hidden_layer(x1)</span><br><span class="line">    scope.reuse_variables()</span><br><span class="line">    logits2 = two_hidden_layer(x2）</span><br></pre></td></tr></tbody></table></figure><p>以上代码模式，基础组件可以定义更多，比如conv，relu，网络结构可以更复杂，比如放一个ResNet，非常容易scale。<br>由于使用了变量共享，多次传入x，网络TensorBoard图的复杂程度不会爆炸式增加。</p><p>Graph collections</p><p>使用这个，可以获取满足一定条件的所有变量，tf.get_collection(key,scope=None)<br>比如执行optimizer的时候，默认情况下它会获取key=tf.GraphKeys.TRAINABLE_VARIABLES的变量，即所有可训练的变量（当然也可以传入指定的、要训练的变量<br>获取某个scope下的所有变量，tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES,scope=’scope_name’)<br>key还有许多其它的值，见官网。</p><h4 id="Manage-experiments"><a href="#Manage-experiments" class="headerlink" title="Manage experiments"></a>Manage experiments</h4><p>实验总是很久，中断随时发生，因此训练可以随时随地停止、像没事一样恢复，非常重要。<br>另外一个问题是论文结果复现，控制实验的随机因子对复现结果非常关键。</p><p>tf.train.Saver()</p><p><strong>周期性地保存模型参数</strong>是个好习惯<br>tf.train.Saver()类将图的<strong>变量保存</strong>（不是整张图）到二进制文件，也就是一个checkpoint（变量名到tensors的映射）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义模型</span></span><br><span class="line">...</span><br><span class="line">global_steps = tf.Variable(<span class="number">0</span>, trainable=<span class="literal">False</span>，name=<span class="string">'global_steps'</span>)</span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(lr).minimize(loss,global_step=global_steps)</span><br><span class="line"><span class="comment">#创建一个saver对象</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动一个会话来执行计算</span></span><br><span class="line"><span class="keyword">with</span> tf.session() <span class="keyword">as</span> sess:</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">1</span>,training_steps):</span><br><span class="line">        sess.run([optimizer]) <span class="comment">#global_step会在每一步训练后自加1</span></span><br><span class="line">        <span class="keyword">if</span> step%<span class="number">1000</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="comment">#这里传入step也差不多吧...默认保存图中所有变量</span></span><br><span class="line">            saver.save(sess,<span class="string">'checkpoints/model-name'</span>,global_step=global_steps)</span><br></pre></td></tr></tbody></table></figure><p>生成的checkpoint名，像这样，’checkpoints/skip-gram-10000’<br>在恢复模型时可以直接传入checkpoint名（如果有的话</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ckpt = tf.train.get_checkpoint_state(os.path.dirname(<span class="string">'checkpoints/model-name'</span>))</span><br><span class="line"><span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">    saver.restore(sess,ckpt.model_checkpoint_path) <span class="comment">#恢复的是最近的一个check point</span></span><br></pre></td></tr></tbody></table></figure><p>恢复的时候，网络图还得自己重新搭（still have to create the graph ourselves）之后再加载变量<br>当然，经常的做法是到目前为止表现最好的参数也保存下来（不止是最近的一次）</p><p>tf.summary</p><p>记录模型训练过程中指标变化，包括loss，accuracy等等</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建summaries</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"summaries"</span>):</span><br><span class="line">    tf.summary.scalar(<span class="string">"loss"</span>,loss)</span><br><span class="line">    tf.summary.histogram(<span class="string">"histogram loss"</span>,loss)</span><br><span class="line">    tf.summary.scalar(<span class="string">"accuracy"</span>,accuracy)</span><br><span class="line">    summary_op = tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行summary op</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(steps):</span><br><span class="line">        _loss,_,summary = sess.run([model.loss,model.optimizer,model.summary_op],feed_dict={...})</span><br><span class="line">        writer = tf.summary.FileWriter(<span class="string">'path'</span>+str(lr),sess.graph) <span class="comment">#将lr写入路径，方便tensorboard对比</span></span><br><span class="line">        writer.add(summary,global_step=step) <span class="comment">#记录每一个step的summary</span></span><br><span class="line">    writer.close()</span><br></pre></td></tr></tbody></table></figure><p>control randomization</p><p>为了使得别人在实验时结果会与你一致</p><ol><li><p>op级别<br>所有的tensor初始化时都传入seed参数<br>session记录了随机状态，每一个新的session都会重新start the random state</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>,seed=<span class="number">2</span>)</span><br><span class="line">d = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>,seed=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(c)) <span class="comment">#value: a</span></span><br><span class="line">    print(sess.run(d)) <span class="comment">#same value: a</span></span><br><span class="line">    print(sess.run(c)) <span class="comment">#value: b</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>graph级别<br>比如demo1.py和demo2.py代码相同，设置了tf.set_random_seed(seed)的话执行结果是相同的</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tf.set_random_seed(<span class="number">2</span>)</span><br><span class="line">c = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>)</span><br><span class="line">d = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(c)) <span class="comment"># 都是a</span></span><br><span class="line">    print(sess.run(d)) <span class="comment"># 都是b</span></span><br></pre></td></tr></tbody></table></figure></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键词：model base, variable sharing, model sharing&lt;/p&gt;
&lt;h4 id=&quot;word2vec&quot;&gt;&lt;a href=&quot;#word2vec&quot; class=&quot;headerlink&quot; title=&quot;word2vec&quot;&gt;&lt;/a&gt;word2vec&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;文本的分布式表示是许多自然语言处理任务的基础&lt;/li&gt;
&lt;li&gt;word2vec是用来生成词语分布式表示的一组模型&lt;/li&gt;
&lt;li&gt;主要有两种模型：skip-gram和CBOW&lt;/li&gt;
&lt;li&gt;算法角度：CBOW模型从上下文词预测目标词，skip-gram模型从目标词预测上下文词&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="machine learning" scheme="https://yikayiyo.github.io/tags/machine-learning/"/>
    
      <category term="TensorFlow" scheme="https://yikayiyo.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>linear and logistic regression in TensorFlow</title>
    <link href="https://yikayiyo.github.io/2018/03/29/TensorFlow02/"/>
    <id>https://yikayiyo.github.io/2018/03/29/TensorFlow02/</id>
    <published>2018-03-29T03:37:22.000Z</published>
    <updated>2018-05-31T08:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h3><h4 id="问题定义："><a href="#问题定义：" class="headerlink" title="问题定义："></a>问题定义：</h4><p>设X为生育率，Y为预期寿命，能否找到一个线性函数f使得Y = f(X)？</p><img src="/2018/03/29/TensorFlow02/f1.png" class=""><a id="more"></a><p>数据集描述：</p><p>名称: Birth rate - life expectancy in 2010<br>X = 生育率. Type: float.<br>Y = 预期寿命. Type: foat.<br>数据量: 190<br>数据形式: (X,Y)</p><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><p><strong>假设</strong>X和Y之间的关系是线性的，这意味着有w和b，满足：Y_pred = wX + b.<br>本例中w，b都是scalar，</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = tf.get_variable(<span class="string">'weights'</span>,initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line">b = tf.get_variable(<span class="string">'bias'</span>,initializer=tf.constant(<span class="number">0.0</span>))</span><br></pre></td></tr></tbody></table></figure><p>损失函数使用均方误差</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y_pred = w*X+b</span><br><span class="line">loss = tf.square(Y-Y_pred,name=<span class="string">'loss'</span>)</span><br></pre></td></tr></tbody></table></figure><p>完整代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> utils</span><br><span class="line"></span><br><span class="line">DATA_FILE = <span class="string">"data/birth_life_2010.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 1: 加载数据，形式为（190，2）的numpy数组，每一行代表一个点</span></span><br><span class="line">data, n_samples = utils.read_birth_life_data(DATA_FILE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2: 创建placeholders</span></span><br><span class="line">X = tf.placeholder(tf.float32, name=<span class="string">'X'</span>)</span><br><span class="line">Y = tf.placeholder(tf.float32, name=<span class="string">'Y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3: 创建变量，初始化为0</span></span><br><span class="line">w = tf.get_variable(<span class="string">'weights'</span>, initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line">b = tf.get_variable(<span class="string">'bias'</span>, initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4: 模型</span></span><br><span class="line">Y_predicted = w * X + b </span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 5: 损失函数</span></span><br><span class="line">loss = tf.square(Y - Y_predicted, name=<span class="string">'loss'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 6: GD最小化loss</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=<span class="number">0.001</span>).minimize(loss)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line"><span class="comment"># Step 7: 变量初始化</span></span><br><span class="line">sess.run(tf.global_variables_initializer()) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 8: 训练100回</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): <span class="comment"># run 100 epochs</span></span><br><span class="line"><span class="comment"># 每次传入一个数据点，事实上，使用batches of data更好一点。</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> data:</span><br><span class="line"><span class="comment"># Session runs train_op to minimize loss</span></span><br><span class="line">sess.run(optimizer, feed_dict={X: x, Y:y}) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 9: output the values of w and b</span></span><br><span class="line">w_out, b_out = sess.run([w, b])</span><br></pre></td></tr></tbody></table></figure><p>结论：<br>经过100次训练后，平均损失为30.04，w = -6.07，b = 84.93。<br>这证实了我们的假设，即出生率与一个国家人口的预期寿命之间存在负相关关系。 但是，这并不意味着多一个孩子会减少6年的寿命。</p><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>假设X和Y满足：Y_pred = wX^2 + uX + b</p><p>只需修改部分代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 3: 创建变量，初始化为0</span></span><br><span class="line">w = tf.get_variable(<span class="string">'weights_1'</span>, initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line">u = tf.get_variable(<span class="string">'weights_2'</span>, initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line">b = tf.get_variable(<span class="string">'bias'</span>, initializer=tf.constant(<span class="number">0.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4: 模型</span></span><br><span class="line">Y_predicted = w * X * X + X * u + b</span><br></pre></td></tr></tbody></table></figure><p>由于平方损失会给离群点太多的权重，这里损失函数考虑使用Huber loss：</p><img src="/2018/03/29/TensorFlow02/f2.png" class=""><p>tensorflow提供了一些控制流操作：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">huber_loss</span><span class="params">(labels, predictions, delta=<span class="number">14.0</span>)</span>:</span></span><br><span class="line">    residual = tf.abs(labels - predictions)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">0.5</span> * tf.square(residual)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span> <span class="keyword">return</span> delta * residual - <span class="number">0.5</span> * tf.square(delta)</span><br><span class="line">    <span class="keyword">return</span> tf.cond(residual &lt; delta, f1, f2)</span><br></pre></td></tr></tbody></table></figure><p>最后结果为：<strong>w: -5.883589, b: 85.124306.</strong></p><h4 id="which-one-is-better？"><a href="#which-one-is-better？" class="headerlink" title="which one is better？"></a>which one is better？</h4><p>we do need test data set！！！</p><h3 id="tf-data"><a href="#tf-data" class="headerlink" title="tf.data"></a>tf.data</h3><p>使用placeholder和feed_dicts的好处是将数据处理与TensorFlow分离，使用python就可以轻松地shuffle, batch, generate arbitrary data. 不好的地方是，数据处理的线程很有可能是瓶颈，使整个程序slow down。</p><p>使用队列也是TF中处理数据的一个选项，队列允许pipelining、threading操作，减少了数据加载到placeholders的时间，但是难以使用且容易崩溃。</p><p>tf.data比placeholder更快，比队列更容易使用，而且不会crash。</p><p>数据存储在一个tf.data.Dataset对象中，而不是一个non-TensorFLow对象（numpy array）</p><h4 id="tf-data基操："><a href="#tf-data基操：" class="headerlink" title="tf.data基操："></a>tf.data基操：</h4><ol><li><p>创建DataSet</p><ol><li><p>从tensor创建</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># features,labels都是tensors，也可以是numpy arrays</span></span><br><span class="line">tf.data.DataSet.from_tensor_slice((features,labels))</span><br></pre></td></tr></tbody></table></figure></li><li><p>从file创建</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件每一行代表一个数据，例如csv文件</span></span><br><span class="line">tf.data.TextLineDataset(filenames)</span><br><span class="line"><span class="comment"># 每一个文件长度都固定，比如都是28*28的图片</span></span><br><span class="line">tf.data.FixedLengthRecordDataset([file1,file2,file3,file4,...])</span><br><span class="line"><span class="comment"># tfrecord格式，（还没用过</span></span><br><span class="line">tf.data.TFRecordDataset(filenames)</span><br></pre></td></tr></tbody></table></figure></li></ol></li><li><p>创建Iterator</p><p>取dataset中的数据需要用到迭代器</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只能遍历一遍</span></span><br><span class="line">iterator = dataset.make_one_shot_iterator()</span><br><span class="line"><span class="comment"># 多次初始化，多次遍历</span></span><br><span class="line">iterator = dataset.make_initializable_iterator()</span><br><span class="line"><span class="comment"># 返回一个或者一组样本</span></span><br><span class="line">iterator.get_next()</span><br></pre></td></tr></tbody></table></figure></li><li><p>训练</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iterator = dataset.make_initializable_iterator()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): </span><br><span class="line">        <span class="comment"># 每一个epoch都要初始化iterator</span></span><br><span class="line">        sess.run(iterator.initializer) </span><br><span class="line">        total_loss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                sess.run([optimizer]) </span><br><span class="line">        <span class="keyword">except</span> tf.errors.OutOfRangeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#简单的命令操作dataset</span></span><br><span class="line">dataset = dataset.shuffle(<span class="number">1000</span>)</span><br><span class="line">dataset = dataset.repeat(<span class="number">100</span>)</span><br><span class="line">dataset = dataset.batch(<span class="number">128</span>)</span><br><span class="line">dataset = dataset.map(<span class="keyword">lambda</span> x: tf.one_hot(x, <span class="number">10</span>)) </span><br><span class="line"><span class="comment"># convert each element of dataset to one_hot vector</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Logistic-Regression-with-MINIST"><a href="#Logistic-Regression-with-MINIST" class="headerlink" title="Logistic Regression with MINIST"></a>Logistic Regression with MINIST</h3><h4 id="一个问题："><a href="#一个问题：" class="headerlink" title="一个问题："></a>一个问题：</h4><p>这个实验有多个数据集，训练集、验证集和测试集，如果每个数据集都有各自的iterator，那我们就得为每一个iterator创建一个graph。</p><p> 不，可以用一个迭代器，用不同的数据初始化它</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iterator = tf.data.Iterator.from_structure(train_data.output_types,</span><br><span class="line">                                           train_data.output_shapes)</span><br><span class="line"><span class="comment"># 每一个epoch的训练前，都要sess.run(train_init)</span></span><br><span class="line">train_init = iterator.make_initializer(train_data)</span><br><span class="line">test_init = iterator.make_initializer(test_data)</span><br></pre></td></tr></tbody></table></figure><p><a href="https://github.com/yikayiyo/stanford-tensorflow-tutorials/blob/master/examples/03_logreg.py" target="_blank" rel="noopener">完整代码</a>, tensorboard图示如下：</p><img src="/2018/03/29/TensorFlow02/f3.png" class=""><p>下一步，尝试将这个graph改造得有条理一些。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linear-Regression&quot;&gt;&lt;a href=&quot;#Linear-Regression&quot; class=&quot;headerlink&quot; title=&quot;Linear Regression&quot;&gt;&lt;/a&gt;Linear Regression&lt;/h3&gt;&lt;h4 id=&quot;问题定义：&quot;&gt;&lt;a href=&quot;#问题定义：&quot; class=&quot;headerlink&quot; title=&quot;问题定义：&quot;&gt;&lt;/a&gt;问题定义：&lt;/h4&gt;&lt;p&gt;设X为生育率，Y为预期寿命，能否找到一个线性函数f使得Y = f(X)？&lt;/p&gt;
&lt;img src=&quot;/2018/03/29/TensorFlow02/f1.png&quot; class=&quot;&quot;&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="machine learning" scheme="https://yikayiyo.github.io/tags/machine-learning/"/>
    
      <category term="TensorFlow" scheme="https://yikayiyo.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow Ops</title>
    <link href="https://yikayiyo.github.io/2018/03/28/TensorFlow01/"/>
    <id>https://yikayiyo.github.io/2018/03/28/TensorFlow01/</id>
    <published>2018-03-28T01:37:22.000Z</published>
    <updated>2018-05-29T15:46:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一般流程："><a href="#一般流程：" class="headerlink" title="一般流程："></a>一般流程：</h4><h4 id="TFboy基操："><a href="#TFboy基操：" class="headerlink" title="TFboy基操："></a>TFboy基操：</h4><ul><li>定义图<a id="more"></a></li><li>创建writer，两种方式<ul><li>tf.get_default_graph()</li><li>sess.graph</li></ul></li><li>创建session执行图</li><li>关闭writer</li><li>TensorBoard可视化</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">a = tf.constant(<span class="number">2</span>, name=<span class="string">'a'</span>)</span><br><span class="line">b = tf.constant(<span class="number">3</span>, name=<span class="string">'b'</span>)</span><br><span class="line">x = tf.add(a, b, name=<span class="string">'add'</span>)</span><br><span class="line"><span class="comment"># 第一种</span></span><br><span class="line">writer = tf.summary.FileWriter(<span class="string">'./graphs/low'</span>, tf.get_default_graph()) </span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 第二种</span></span><br><span class="line">    <span class="comment"># writer = tf.summary.FileWriter('./graphs', sess.graph) </span></span><br><span class="line">    print(sess.run(x))</span><br><span class="line">writer.close() <span class="comment"># close the writer when you’re done using it</span></span><br></pre></td></tr></tbody></table></figure><p>writer会将图（包含的各种ops）以日志文件的形式写入指定目录，tensorboard可以将这些文件可视化出来</p><p>上面的程序每跑一次就会产生一个日志文件，不用的日志及时删除</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tensorboard --logdir=<span class="string">'./graphs/low'</span> --port=6006</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意路径不要搞错</span></span><br></pre></td></tr></tbody></table></figure><img src="/2018/03/28/TensorFlow01/ex1.png" class=""><h4 id="没记住的"><a href="#没记住的" class="headerlink" title="没记住的"></a>没记住的</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tf.fill([2,3],8) ===&gt; [[8,8,8],[8,8,8]]</span><br><span class="line">tf.lin_space(10.0,13.0,4,name=None) ===&gt;[10.0 11.0 12.0 13.0]</span><br><span class="line"><span class="comment">#各种分布</span></span><br><span class="line">tf.random_normal</span><br><span class="line">...</span><br><span class="line"><span class="comment">#add multiple tensors</span></span><br><span class="line">tf.add_n([a,b,b]) ====&gt; a+b+b</span><br></pre></td></tr></tbody></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h5><p>训练中需要更新的参数定义为变量</p><p>常量存储在图中，变量则可能在parameter server上</p><p>常量占了很多存储时，加载图会很慢</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># old way</span></span><br><span class="line">tf.Variable(&lt;initial-value&gt;,name=&lt;optional-name&gt;)</span><br><span class="line"><span class="comment"># now</span></span><br><span class="line">tf.get_variable(...)</span><br><span class="line"><span class="comment"># 当initializer时tf.constant时，不需要参数shape</span></span><br><span class="line">s = tf.get_variable(<span class="string">"scalar"</span>, initializer=tf.constant(<span class="number">2</span>)) </span><br><span class="line">m = tf.get_variable(<span class="string">"matrix"</span>, initializer=tf.constant([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]]))</span><br><span class="line">W = tf.get_variable(<span class="string">"big_matrix"</span>, shape=(<span class="number">784</span>, <span class="number">10</span>), initializer=tf.zeros_initializer())</span><br></pre></td></tr></tbody></table></figure><h5 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次性初始化所有变量</span></span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"><span class="comment">#初始化部分变量</span></span><br><span class="line">sess.run(tf.variables_initializer([a, b]))</span><br><span class="line"><span class="comment">#单独初始化</span></span><br><span class="line">sess.run(W.initializer)</span><br><span class="line"><span class="comment">#从文件加载</span></span><br><span class="line">Todo...</span><br></pre></td></tr></tbody></table></figure><h5 id="变量的值"><a href="#变量的值" class="headerlink" title="变量的值"></a>变量的值</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种方式</span></span><br><span class="line">print(sess.run(W))</span><br><span class="line">print(W.eval())</span><br></pre></td></tr></tbody></table></figure><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 赋值会完成初始化的工作</span></span><br><span class="line">W.assign(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 自增自减不会初始化变量</span></span><br><span class="line">W.assign_add(<span class="number">10</span>)</span><br><span class="line">W.assing_sub(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 变量依赖,使用initialized_value()保证用W的值来初始化V</span></span><br><span class="line">V = tf.Variable(W.initialized_value()*<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="控制依赖"><a href="#控制依赖" class="headerlink" title="控制依赖"></a>控制依赖</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># g has 5 ops: a,b,c,d,e</span></span><br><span class="line"><span class="comment"># 还没用到过</span></span><br><span class="line"><span class="keyword">with</span> g.control_dependencies([a,b,c]):</span><br><span class="line">    <span class="comment"># d,e only run after a,b,c have executed</span></span><br><span class="line">    d = ...</span><br><span class="line">    e = ...</span><br></pre></td></tr></tbody></table></figure><h4 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h4><ol><li><p>old way：placeholders and feed_dict</p><p>例如，对于f(x,y) = 2x + y，x y 就是真实值的占位符</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#shape=None 意味着接收任意shape的张量</span></span><br><span class="line">tf.placeholder(dtype,shape=<span class="literal">None</span>,name=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#any tensors that are feedable can be fed</span></span><br><span class="line">tf.Graph.is_feedable(tensor)</span><br><span class="line"><span class="comment">#feed_dict可以用来测试模型，</span></span><br><span class="line"><span class="comment">#直接传入某些值免去了大量的计算</span></span><br><span class="line">a = tf.add(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">b = tf.multiply(a, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(b))                                 <span class="comment"># &gt;&gt; 21</span></span><br><span class="line">    <span class="comment"># compute the value of b given the value of a is 15</span></span><br><span class="line">    print(sess.run(b, feed_dict={a: <span class="number">15</span>}))              <span class="comment"># &gt;&gt; 45</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>new way: tf.data</p><p>[ ] todo…</p></li></ol><h4 id="lazy-loading"><a href="#lazy-loading" class="headerlink" title="lazy loading"></a>lazy loading</h4><p>需要计算op的时候才创建</p><p>因为训练绝大数情况都要计算多次，所以lazy loading会产生大量的冗余节点</p><p>解决办法：</p><ol><li>尽可能的将ops的定义和计算分开（不要在计算的时候创建op</li><li>当你将相关ops组合在一起（比如，1中的步骤在一个类里面）可以使用python的@property机制确保某些功能只执行一次（!!!有待研究）</li></ol><p>相关博客<a href="http://danijar.com/structuring-your-tensorflow-models/" target="_blank" rel="noopener">http://danijar.com/structuring-your-tensorflow-models/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一般流程：&quot;&gt;&lt;a href=&quot;#一般流程：&quot; class=&quot;headerlink&quot; title=&quot;一般流程：&quot;&gt;&lt;/a&gt;一般流程：&lt;/h4&gt;&lt;h4 id=&quot;TFboy基操：&quot;&gt;&lt;a href=&quot;#TFboy基操：&quot; class=&quot;headerlink&quot; title=&quot;TFboy基操：&quot;&gt;&lt;/a&gt;TFboy基操：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;定义图&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="machine learning" scheme="https://yikayiyo.github.io/tags/machine-learning/"/>
    
      <category term="TensorFlow" scheme="https://yikayiyo.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>sparql 笔记</title>
    <link href="https://yikayiyo.github.io/2018/03/26/sparql/"/>
    <id>https://yikayiyo.github.io/2018/03/26/sparql/</id>
    <published>2018-03-26T10:53:29.000Z</published>
    <updated>2018-05-29T01:00:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Jumping-Right-In"><a href="#Jumping-Right-In" class="headerlink" title="Jumping Right In"></a>Jumping Right In</h3><ul><li>FROM指定的数据集会被调用SPARQL处理器时指定的数据集覆盖（如果都指定了</li><li>RDF不是数据格式，而是数据模型，它可以选择存储数据文件的语法</li><li>如果我们将数据与其它数据结合起来，那么RDF三元组的主语和谓语都必须属于特定的名称空间，以防止类似名称之间的混淆，于是我们使用URI来表示它们</li><li>当使用完整的URI时，将其放在尖括号中以向处理器显示它是一个URI</li><li>在semantic web开发中，词汇表是一组使用标准格式存储的术语，供人们重复使用</li><li>发现不同来源三元组之间联系的能力是SPARQL的最佳特性之一</li><li>约定：主谓宾分别用?s,?p,?o表示</li><li>只有满足图模式中所有三元组的数据才会被返回<a id="more"></a></li></ul><h3 id="The-Semantic-Web-RDF-and-Linked-Data-and-SPARQL"><a href="#The-Semantic-Web-RDF-and-Linked-Data-and-SPARQL" class="headerlink" title="The Semantic Web,RDF,and Linked Data(and SPARQL)"></a>The Semantic Web,RDF,and Linked Data(and SPARQL)</h3><ul><li>the semantic web isn’t about the query language or about the model—it’s about the data</li><li>RDF中基本的信息单元是三元组</li><li>将RDF作为一串字节保存在磁盘上的技术术语是序列化</li><li>RDFS gives people a way to describe vocabularies. It is itself a vocabulary with a schema whose triples declare facts.</li><li>Linked Data：<ul><li>Use URIs as names for things.</li><li>Use HTTP URIs so that people can look up those names.</li><li>When someone looks up a URI, provide useful information, using the standards (RDF*, SPARQL).</li><li>Include links to other URIs so that they can discover more things.</li></ul></li></ul><h3 id="SPARQL-Queries"><a href="#SPARQL-Queries" class="headerlink" title="SPARQL Queries"></a>SPARQL Queries</h3><p>介绍SPARQL查询语言更多更有用的特征</p><h4 id="More-Readable-Query-Results"><a href="#More-Readable-Query-Results" class="headerlink" title="More Readable Query Results"></a>More Readable Query Results</h4><ul><li><strong>分号</strong>表示接下来的谓语-宾语对与之前的共有一个主语  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ?<span class="keyword">first</span> ?<span class="keyword">last</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">  ?person ab:firstName ?<span class="keyword">first</span>;</span><br><span class="line">          ab:lastName  ?last.</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>使用那些可读性强的属性，比如标签、描述等等（字符串，而不是URI</li><li><strong>rdfs:label</strong> 是第一个应该注意的属性，别的，<strong>rdfs:comment</strong>,<strong>skos:prefLabel</strong>（首选标签）,<strong>skos:altLabel</strong>（备选标签）</li><li>给定的资源并不总必须是主语、谓语或者宾语，在不同的三元组中它可以是不同的（多个）角色</li></ul><h4 id="Data-That-Might-Not-Be-There"><a href="#Data-That-Might-Not-Be-There" class="headerlink" title="Data That Might Not Be There"></a>Data That Might Not Be There</h4><ul><li>将triple pattern放入到OPTIONAL graph patterns中，表示“如果有的话，检索该值”</li><li>OPTIONAL{t1.t2.t3}包含三个三元组，这些三元组需要同时满足</li><li>OPTIONAL{t1} OPTIONAL{t2} OPTIONAL{t3}则是三个独立的条件</li><li>OPTIONAL graph patterns的顺序很重要  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优先使用nick作为?first</span></span><br><span class="line"><span class="keyword">SELECT</span> ?<span class="keyword">first</span> ?<span class="keyword">last</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">    ?s ab:lastName ?last.</span><br><span class="line">    OPTIONAL {?s ab:nick ?<span class="keyword">first</span>}</span><br><span class="line">    OPTIONAL {?s ab:firstName ?<span class="keyword">first</span>}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Finding-Data-That-Doesn’t-Meet-Certain-Conditions"><a href="#Finding-Data-That-Doesn’t-Meet-Certain-Conditions" class="headerlink" title="Finding Data That Doesn’t Meet Certain Conditions"></a>Finding Data That Doesn’t Meet Certain Conditions</h4><ul><li>SPARQL1.0  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用FILTER和bound，?v没有绑定值时返回true，然后输出</span></span><br><span class="line">OPTIONAL {?s ?p ?v}</span><br><span class="line">FILTER(!bound(?v))</span><br></pre></td></tr></tbody></table></figure></li><li>SPARQL1.1  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当指定的pattern不存在时返回ture</span></span><br><span class="line">NOT EXISTS {?s ?p ?v}</span><br></pre></td></tr></tbody></table></figure>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#另一种方式，减去满足pattern的资源（多数情况下表现相同</span></span><br><span class="line">MINUS {?s ?p ?v}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Serching-Futher-In-The-Data"><a href="#Serching-Futher-In-The-Data" class="headerlink" title="Serching Futher In The Data"></a>Serching Futher In The Data</h4><ul><li>RDF三元组中的对象可以是字符串或者URI，字符串值更易读，但是<strong>URI使得将该数据和其它数据链接起来更加容易</strong></li><li>如果一个数据集中资源的URI可以和另一个数据集中的URI对应起来，哪怕数据集来自不同的地方，不清楚组织形式，也可以利用SPARQL查询到更多的信息</li><li><strong>逗号</strong>表示“接下来的三元组主语谓语和前一个三元组的相同”</li><li>利用属性路径（property paths）：  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 借助正则表达式的符号+（one or more）,返回直接引用、间接引用了A的论文</span></span><br><span class="line"><span class="keyword">SELECT</span> ?s </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{?s c:cites+ :paperA.}</span><br><span class="line"><span class="comment"># 指定引用层数</span></span><br><span class="line"><span class="comment">#{?s c:cites{3} :paperA.}</span></span><br><span class="line"><span class="comment">#相同效果</span></span><br><span class="line"><span class="comment">#{?s c:cites/c:cites/c:cites :paperA.}</span></span><br><span class="line"><span class="comment">#^表示取相反,返回A引用的文章</span></span><br><span class="line"><span class="comment">#{?s ^c:cites :paperA.}</span></span><br><span class="line"><span class="comment"># ^结合property path的例子：引用了F引用的文章的文章</span></span><br><span class="line"><span class="comment">#{</span></span><br><span class="line"><span class="comment">#    ?s c:cites/^c:cites :paperF .</span></span><br><span class="line"><span class="comment">#    FILTER(?s != :paperF)</span></span><br><span class="line"><span class="comment">#}</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Searching-With-Blank-Nodes"><a href="#Searching-With-Blank-Nodes" class="headerlink" title="Searching With Blank Nodes"></a>Searching With Blank Nodes</h4><ul><li>空白节点的任何名称都是临时的，通常会给一个变量名</li><li>过渡的东西，用来链接三元组</li><li>最终的select列表中一般不包含空白节点</li></ul><h4 id="Eliminating-Redundant-Output"><a href="#Eliminating-Redundant-Output" class="headerlink" title="Eliminating Redundant Output"></a>Eliminating Redundant Output</h4><ul><li>DISTINCT关键字</li><li>DISTINCT关键字不会增加查询结构的复杂性（就是在SELECT内容前面加个DISTINCT</li></ul><h4 id="Combining-Different-Search-Conditions"><a href="#Combining-Different-Search-Conditions" class="headerlink" title="Combining Different Search Conditions"></a>Combining Different Search Conditions</h4><ul><li>UNION关键字：指定多个graph patterns，返回满足任意一个pattern的数据的组合(a combination of all the data that fits any of those patterns) </li><li>有些SPARQL处理器在其返回结果中使用声明的前缀，使得结果可读性更强</li></ul><h4 id="Filtering-Data-Based-On-Conditions"><a href="#Filtering-Data-Based-On-Conditions" class="headerlink" title="Filtering Data Based On Conditions"></a>Filtering Data Based On Conditions</h4><ul><li>FILTER() 只有一个参数，表达式只要返回的是布尔值就可以作为参数</li><li>RDF解析器读入输入数据时，它将这些前缀映射到适当的名称空间URIs，然后将数据交给查询处理器</li><li>!isURI(?city): 如果?city不是一个正常的URI，返回true</li><li>IN关键字：查询某个变量属于列表的三元组（前面加NOT可以表示相反的意思  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ask for data where the ?v is either A or B</span></span><br><span class="line">FILTER(?v IN (A,B))</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Retrieving-A-Specific-Number-Of-Results"><a href="#Retrieving-A-Specific-Number-Of-Results" class="headerlink" title="Retrieving A Specific Number Of Results"></a>Retrieving A Specific Number Of Results</h4><ul><li>LIMIT关键字</li><li>放在花括号外面</li><li>OFFSET关键字:跳过几个结果</li></ul><h4 id="Querying-Named-Graphs"><a href="#Querying-Named-Graphs" class="headerlink" title="Querying Named Graphs"></a>Querying Named Graphs</h4><ul><li>命名图(named graph)：为三元组集合命名，方便管理（进行替换之类的操作</li><li>查询的数据集可以在查询内部用FROM指定，也可以在外部在ARQ命令行中指定，后者会覆盖前者  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span>&lt;xx.ttl&gt;</span><br><span class="line"><span class="keyword">FROM</span>&lt;yy.ttl&gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{...}</span><br></pre></td></tr></tbody></table></figure></li><li>指定的查询数据集构成了默认图(default graph)，它不属于任何命名图</li><li>FROM NAMED :表示数据集不会被加入到默认图，查询时需要指定其graph name（ARQ的约定是将URI作为其name），第六章会有SPARQL1.1标准的相关内容  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ?lname ?courseName</span><br><span class="line"><span class="keyword">FROM</span> &lt;ex069.ttl&gt;</span><br><span class="line"><span class="keyword">FROM</span> NAMED &lt;ex125.ttl&gt;</span><br><span class="line"><span class="keyword">FROM</span> NAMED &lt;ex122.ttl&gt; <span class="comment"># 即使这里写了，如果在查询中没有指定（GRAPH &lt;ex125.ttl&gt;），其数据不会被用来检索</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">    { ?student ab:lastName ?lname }</span><br><span class="line">    <span class="keyword">UNION</span></span><br><span class="line">    { GRAPH &lt;ex125.ttl&gt; { ?course ab:courseTitle ?courseName } }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>GRAPH关键字：查询中使用这个关键字表明引用特定命名图中的数据</li><li>GRAPH后面也可以跟变量，让SPARQL处理器寻找满足某个模式的图  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里只设置了特定的命名图来查询，如果存在默认图，则没有任何返回结果</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> NAMED &lt;yyy.ttl&gt;</span><br><span class="line"><span class="keyword">FROM</span> NAMED &lt;xxx.ttl&gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{GRAPH ?g(?s ?p ?o)}</span><br></pre></td></tr></tbody></table></figure></li><li>SPARQL处理器有一些预定义的命名图，当你在GRAPH中指定时不需要事先标识  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ?graph ?email </span><br><span class="line"><span class="keyword">FROM</span> &lt;ex134.ttl&gt; </span><br><span class="line"><span class="keyword">FROM</span> NAMED &lt;ex125.ttl&gt; </span><br><span class="line"><span class="keyword">FROM</span> NAMED &lt;ex122.ttl&gt; </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">{</span><br><span class="line">    ?graph dc:<span class="built_in">date</span> <span class="string">"2011-09-24"</span> . </span><br><span class="line">    { GRAPH ?graph { ?s ab:email ?email } }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Queries-In-Your-Queries"><a href="#Queries-In-Your-Queries" class="headerlink" title="Queries In Your Queries"></a>Queries In Your Queries</h4><ul><li>子查询特征：可以将复杂的查询细分，又可以将来自不同查询的结果合并</li><li>每个子查询必须放到自己的花括号中</li></ul><h4 id="Combining-Values-And-Assigning-Values-To-Variables"><a href="#Combining-Values-And-Assigning-Values-To-Variables" class="headerlink" title="Combining Values And Assigning Values To Variables"></a>Combining Values And Assigning Values To Variables</h4><ul><li><p>sparql查询出来的值可以用于数学运算，函数调用</p></li><li><p>BIND关键字</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数学运算的例子</span></span><br><span class="line"><span class="comment">#这里利用amount创建了变量tip和total</span></span><br><span class="line"><span class="keyword">SELECT</span> ?description </span><br><span class="line">?amount </span><br><span class="line">((?amount * <span class="number">.2</span>) <span class="keyword">AS</span> ?tip) </span><br><span class="line">((?amount + ?tip) <span class="keyword">AS</span> ?total)</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">    ?meal e:description ?description ;</span><br><span class="line">          e:amount ?amount .</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#函数调用的例子</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">(<span class="keyword">UCASE</span>(<span class="keyword">SUBSTR</span>(?description,<span class="number">1</span>,<span class="number">3</span>))<span class="keyword">as</span> ?mealCode) </span><br><span class="line">?amount </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">    ?meal e:description ?description ;</span><br><span class="line">          e:amount ?amount .</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#改进,expression calculation moved to a subquery,利用BIND关键字为变量赋值</span></span><br><span class="line"><span class="keyword">SELECT</span> ?mealCode ?amount</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">    ?meal e:description ?description ;</span><br><span class="line">          e:amount ?amount .</span><br><span class="line">    BIND (UCASE(SUBSTR(?description,1,3)) as ?mealCode)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Sorting-Aggregating-Finding-The-Biggest-And-Smallest-And…"><a href="#Sorting-Aggregating-Finding-The-Biggest-And-Smallest-And…" class="headerlink" title="Sorting, Aggregating, Finding The Biggest And Smallest And…"></a>Sorting, Aggregating, Finding The Biggest And Smallest And…</h4><ul><li>SPARQL使用<strong>ORDER BY</strong>来排序（默认从小到大）.  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据amount排序</span></span><br><span class="line"><span class="keyword">SELECT</span> ?description ?<span class="built_in">date</span> ?amount</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">    ?meal e:description ?description ;</span><br><span class="line">    e:date ?date ;</span><br><span class="line">    e:amount ?amount .</span><br><span class="line">}</span><br><span class="line">ORDER BY ?amount</span><br></pre></td></tr></tbody></table></figure></li><li>从大到小排序：利用DESC()，括号里面是排序用的指标  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据amount从大到小排序</span></span><br><span class="line"><span class="keyword">SELECT</span> ?description ?<span class="built_in">date</span> ?amount </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">    ?meal e:description ?description ;</span><br><span class="line">        e:date ?date ;</span><br><span class="line">        e:amount ?amount .</span><br><span class="line">}</span><br><span class="line">ORDER BY DESC(?amount)</span><br></pre></td></tr></tbody></table></figure></li><li>多条件排序，各个条件空格隔开  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先根据description排序（字母表），再根据amount从大到小排序</span></span><br><span class="line"><span class="keyword">SELECT</span> ?description ?<span class="built_in">date</span> ?amount </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">    ?meal e:description ?description ;</span><br><span class="line">        e:date ?date ;</span><br><span class="line">        e:amount ?amount .</span><br><span class="line">}</span><br><span class="line">ORDER BY ?description DESC(?amount)</span><br></pre></td></tr></tbody></table></figure></li><li>找最值<ul><li>sparql1.0: 先排序，然后LIMIT 1</li><li>sparql1.1: MAX(),MIN()</li></ul></li><li>均值：AVG()  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">AVG</span>(?amount) <span class="keyword">as</span> ?avgAmount)</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">    ?meal e:amount ?amount .</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>求和SUM(),计数COUNT()</li><li>GROUP_CONCAT(): 将很多数据绑定到一个变量，默认的分隔符是空格  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回一个amountlist，形如“25.05,10.00,6.65,31.45”</span></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">GROUP_CONCAT</span>(?amount;SEPARATOR = ',') AS amountlist)</span><br><span class="line">WHERE { ?meal e:amount ?amount.}</span><br></pre></td></tr></tbody></table></figure></li><li>GROUP BY: 根据某属性分组；代入SUM()函数可以求和，类似的，可以代入别的函数  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计早中晚餐总数</span></span><br><span class="line"><span class="keyword">SELECT</span> ?description (<span class="keyword">SUM</span>(?amount) <span class="keyword">AS</span> ?meanTotal)</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{...}</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ?description</span><br></pre></td></tr></tbody></table></figure></li><li>HAVING 关键字：限定显示出来的结果需要满足的条件  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#我们只对总数超过20的感兴趣</span></span><br><span class="line"><span class="keyword">SELECT</span> ?description (<span class="keyword">SUM</span>(?amount) <span class="keyword">AS</span> ?meanTotal)</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{...}</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ?description</span><br><span class="line"><span class="keyword">HAVING</span> (<span class="keyword">SUM</span>(?amount)&gt;<span class="number">20</span>)</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Query-A-Remote-SPARQL-Service"><a href="#Query-A-Remote-SPARQL-Service" class="headerlink" title="Query A Remote SPARQL Service"></a>Query A Remote SPARQL Service</h4><ul><li>查询远程sparql服务<ul><li>FROM 关键字(RDF file)  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ?title</span><br><span class="line"><span class="keyword">FROM</span> &lt;xxx://xxx.xxx.xxxx/xxx&gt;</span><br><span class="line">{?s dc:title ?title}</span><br></pre></td></tr></tbody></table></figure></li><li>SERVICE 关键字(SPARQL endpoint)  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在SPAERQL endpoint运行查询得到一些内容，再进行检索返回结果</span></span><br><span class="line"><span class="keyword">SELECT</span> ?p ?o</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">{</span><br><span class="line">    SERVICE &lt;xxx://xxx.xxx/xxx&gt;</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">SELECT</span> ?p ?o</span><br><span class="line">        <span class="keyword">WHERE</span> {xxx ?p ?o}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><strong>ARQ 必须指定–data参数，即便查询对数据没有任何操作（上面的查询，其实只是指定了待查询的endpoint，而不是数据</strong></li><li>可以借助<strong>D2RQ</strong>使用SPARQL查询关系数据库（RDB）<h4 id="Federated-Queries-Searching-Multiple-Datasets-With-One-Query"><a href="#Federated-Queries-Searching-Multiple-Datasets-With-One-Query" class="headerlink" title="Federated Queries:Searching Multiple Datasets With One Query"></a>Federated Queries:Searching Multiple Datasets With One Query</h4></li><li>联合查询(Federated Queries):一个query查询多个数据集<ul><li>第一个子查询中绑定的变量，在之后的子查询中依旧可用</li><li>如果数据集之间关系密切，上面的特点就会很有用（用来交叉引用）</li><li>如果一个查询由两个子查询，子查询1返回a个结果，子查询2返回b个结果，那么整体查询就返回a*b个结果（cross-product）</li><li>子查询依次执行，可能会花点时间</li></ul></li></ul><h3 id="Coping-Creating-And-Converting-Data"><a href="#Coping-Creating-And-Converting-Data" class="headerlink" title="Coping,Creating,And Converting Data"></a>Coping,Creating,And Converting Data</h3><p>除了查询出结果还能做更多的事</p><h4 id="Query-Forms-SELECT-DESCRIBE-ASK-and-CONSTRUCT"><a href="#Query-Forms-SELECT-DESCRIBE-ASK-and-CONSTRUCT" class="headerlink" title="Query Forms: SELECT, DESCRIBE, ASK, and CONSTRUCT"></a>Query Forms: SELECT, DESCRIBE, ASK, and CONSTRUCT</h4><ul><li>CONSTRUCT返回三元组；可以返回原数据也可以抽取出值来创建新的三元组；可以用来复制、创建、转换</li><li>ASK询问处理器给定的图模式是否描述特定数据集中的一组三元组，返回一个布尔值；可以用来自动化数据处理流程中的质量控制；</li><li>DESCRIBE要求提供描述特定资源的三元组</li></ul><h4 id="Copying-Data"><a href="#Copying-Data" class="headerlink" title="Copying Data"></a>Copying Data</h4><ul><li>利用CONSTRUCT抽取三元组；结合GRAPH关键字可以从特定命名图中抽取；SELECT后面跟的是变量列表，CONSTRUCT后面跟的是想要构造的三元组      <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#construct后面跟的是三元组，用花括号包围,里面可以包含任意个三元组模式（triple patterns）</span></span><br><span class="line">CONSTRUCT</span><br><span class="line">{?person ?p ?o}</span><br><span class="line">WHERE</span><br><span class="line">{...}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Creating-New-Data"><a href="#Creating-New-Data" class="headerlink" title="Creating New Data"></a>Creating New Data</h4><ul><li>利用一些函数处理数据，得到新的字段</li><li>指明资源所属的类会让信息推断更加容易</li><li>所谓的创建信息其实是将隐含的信息明确化</li></ul><h4 id="Converting-Data"><a href="#Converting-Data" class="headerlink" title="Converting Data"></a>Converting Data</h4><ul><li>将一个命名空间中的属性转换到需要的命名空间</li><li>意味着规范化URI以便更加容易地组合数据</li><li>owl:sameAs是DBpedia中用来将不同来源的资源联系起来的方式</li></ul><h4 id="Finding-Bad-Data"><a href="#Finding-Bad-Data" class="headerlink" title="Finding Bad Data"></a>Finding Bad Data</h4><ul><li>schema是一组关于数据结构和数据类型的规则</li><li>如果数据遵循了某个schema那么就不需要程序员写代码应对“给字符串加了1”这样的情形了</li><li>语义网应用采用了别的方法，通过添加更多的metadata</li><li>使用SPARQL添加限制而不是OWL</li></ul><h4 id="Defining-Rules-with-SPARQL"><a href="#Defining-Rules-with-SPARQL" class="headerlink" title="Defining Rules with SPARQL"></a>Defining Rules with SPARQL</h4><ul><li>rules expressed as queries</li><li>一些常用的：<ul><li>isURI</li><li>datatype(?amount)) != xsd:integer</li><li>!(bound(?grade))</li><li>?grade &lt; 5</li></ul></li></ul><h4 id="Generating-Data-About-Broken-Rules"><a href="#Generating-Data-About-Broken-Rules" class="headerlink" title="Generating Data About Broken Rules"></a>Generating Data About Broken Rules</h4><ul><li>将ASK换为CONSTRUCT</li><li>问题建模：问题类型、相关属性</li><li>可以使用Union将不同的规则加合并，但是随着规则的增多，这种方式会产生越来越多的错误（ there’d be greater and greater room for error</li><li>好的处理方式是：分开存储规则，使用是时候pipeline</li></ul><h4 id="Using-Existing-SPARQL-Rules-Vocabularies"><a href="#Using-Existing-SPARQL-Rules-Vocabularies" class="headerlink" title="Using Existing SPARQL Rules Vocabularies"></a>Using Existing SPARQL Rules Vocabularies</h4><ul><li>Schemarama</li><li>SPIN</li><li>关系数据库–API–check for rule compliance using SPARQL</li></ul><h4 id="Asking-for-a-Description-of-a-Resource"><a href="#Asking-for-a-Description-of-a-Resource" class="headerlink" title="Asking for a Description of a Resource"></a>Asking for a Description of a Resource</h4><ul><li>DESCRIBE+URI :返回资源的一些信息，具体返回结果和SPARQL查询引擎有关</li><li>CONSTRUCT可以完成相同的事情，with better control，因此不太推荐在serious的应用开发中使用</li></ul><h3 id="Datatypes-And-Functions"><a href="#Datatypes-And-Functions" class="headerlink" title="Datatypes And Functions"></a>Datatypes And Functions</h3><h4 id="Datatypes-and-Queries"><a href="#Datatypes-and-Queries" class="headerlink" title="Datatypes and Queries"></a>Datatypes and Queries</h4><ul><li>数据类型元数据的存储是记录语义信息的最早方式之一</li><li>标明数据类型方便理解，不标明的话会有默认设置</li><li>str()强制类型转换：FILTER (str(?o) = “two”) #返回所有值为”two”的</li></ul><h4 id="Representing-Strings"><a href="#Representing-Strings" class="headerlink" title="Representing Strings"></a>Representing Strings</h4><ul><li>单引号，双引号，三个单引号或者双引号</li><li>ARQ输出的时候:使用双引号分隔字符串；回车为/r，换行为/n，转义为/；输出的顺序doesn’t matter</li></ul><h4 id="Comparing-Values-and-Doing-Arithmetic"><a href="#Comparing-Values-and-Doing-Arithmetic" class="headerlink" title="Comparing Values and Doing Arithmetic"></a>Comparing Values and Doing Arithmetic</h4><ul><li>当使用不同的数字类型显式键入不同的值时，仍然可以在执行算术时将它们一起使用：比如integer和decimal可以乘到一起</li></ul><h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><ul><li>SPARQL 1.0规范提供了一些基本函数，SPARQL 1.1提供了更广泛的选择，几乎所有都基于XPath函数</li><li>SPARQL处理器可以提供其实施者想要包含的任何扩展功能</li></ul><h4 id="Program-Logic-Functions"><a href="#Program-Logic-Functions" class="headerlink" title="Program Logic Functions"></a>Program Logic Functions</h4><ul><li>IF()函数有三个参数。 如果第一个参数为true，则该函数返回第二个参数的值; 否则返回第三个</li><li>COALESCE():接受很多参数，返回the first one that doesn’t result in an error  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ?<span class="keyword">first</span> ?<span class="keyword">last</span> </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">{</span><br><span class="line">?s ab:lastName ?<span class="keyword">last</span>; </span><br><span class="line">   ab:firstName ?firstname . </span><br><span class="line">OPTIONAL{ ?s ab:nick ?nickname . } </span><br><span class="line">BIND (COALESCE(?nickname,?firstname) AS ?first)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Node-Type-and-Datatype-Checking-Functions"><a href="#Node-Type-and-Datatype-Checking-Functions" class="headerlink" title="Node Type and Datatype Checking Functions"></a>Node Type and Datatype Checking Functions</h4><ul><li>函数参数可能需要是特定类型，数据字段也需要是特定类型</li><li>datatype()函数可以用来检测类型</li><li>isBlank(), isLiteral(), isNumeric(), isIRI(), and isURI()</li><li>数字，字符串和关键字true和false（全部写成小写）都是literals，只有URI和空白节点不是</li><li>datatype(params) 返回一个URI，标识params的类型,params为空白节点和URIs时返回为空</li><li>bound()告诉我们一个变量是否有一个绑定的值</li></ul><h4 id="Node-Type-Conversion-Functions"><a href="#Node-Type-Conversion-Functions" class="headerlink" title="Node Type Conversion Functions"></a>Node Type Conversion Functions</h4><ul><li>URI() function lets you convert values to URIs if possible</li><li>在将值传递给URI()或IRI()函数之前，使用ENCODE_FOR_URI()函数预处理是个推荐的做法，但要注意它只接受simple literals或xsd：string</li><li>str():返回传入资源的字符串形式，传入为空白节点时不返回值</li><li>一个例子：  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONSTRUCT {?s ?p ?testURI.} </span><br><span class="line">WHERE</span><br><span class="line">{</span><br><span class="line">    ?s ?p ?o . </span><br><span class="line">    BIND( IF(isURI(?o), ?o, URI(ENCODE_FOR_URI(str(?o))) ) AS ?testURI)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Datatype-Conversion"><a href="#Datatype-Conversion" class="headerlink" title="Datatype Conversion"></a>Datatype Conversion</h4><ul><li>conversion to boolean is pickier: xsd:boolean(?o)不能转换True，可以转换true</li><li>xsd:dateTime()不能转换“2011-11-12” ，可以转换“2011-11-12T14:30:00”</li><li>STRDT()接收两个参数，一个literal值和一个类型URI，创建一个typed literal（自定义类型）  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONSTRUCT { ?s u:amount ?newAmount . } </span><br><span class="line">WHERE {</span><br><span class="line">    ?s im:product ?prodName ;</span><br><span class="line">       im:amount ?amount ; </span><br><span class="line">       im:units ?units .</span><br><span class="line">       BIND (STRDT(?amount, URI(CONCAT("http://learningsparql.com/ns/units<span class="comment">#",?units))) AS ?newAmount)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Checking-Adding-and-Removing-Spoken-Language-Tags"><a href="#Checking-Adding-and-Removing-Spoken-Language-Tags" class="headerlink" title="Checking, Adding, and Removing Spoken Language Tags"></a>Checking, Adding, and Removing Spoken Language Tags</h4><ul><li>FILTER ( lang(?label) = “en” ) #只返回英文标签</li><li>BIND (str(?label) AS ?strippedLabel) #去掉@en，只返回文字信息</li><li>STRLANG()函数可以为属性加标签，比如：STRLANG(?USTerm,”en-US”)</li></ul><h4 id="String-Functions"><a href="#String-Functions" class="headerlink" title="String Functions"></a>String Functions</h4><ul><li>STRLEN(), SUBSTR(), UCASE(), and LCASE()</li><li>STRSTARTS(), STRENDS(), CONTAINS(),regex() #返回布尔值</li><li>The regex() function expects its first argument to be either an xsd:string or a simple literal with no language tag。可以str()一下</li></ul><h4 id="Numeric-Functions"><a href="#Numeric-Functions" class="headerlink" title="Numeric Functions"></a>Numeric Functions</h4><ul><li>abs(),round(),ceil(),flloor()</li><li>rand()+CONSTRUCT :生成样本数据</li></ul><h4 id="Date-and-Time-Functions"><a href="#Date-and-Time-Functions" class="headerlink" title="Date and Time Functions"></a>Date and Time Functions</h4><ul><li>now(),timezone(),tz()</li></ul><h4 id="Hash-Functions"><a href="#Hash-Functions" class="headerlink" title="Hash Functions"></a>Hash Functions</h4><ul><li>MD5(),SHA1(),SHA224(),SHA256(),SHA384(),SHA512()</li></ul><h4 id="Extension-Functions"><a href="#Extension-Functions" class="headerlink" title="Extension Functions"></a>Extension Functions</h4><ul><li>不同的SPARQL处理器支持的拓展函数不同</li><li>less portable</li></ul><h3 id="Updating-Data-With-SPARQL"><a href="#Updating-Data-With-SPARQL" class="headerlink" title="Updating Data With SPARQL"></a>Updating Data With SPARQL</h3><p>query the data with the SPARQL query language and manage it with the update language.</p><h4 id="Getting-Started-with-Fuseki"><a href="#Getting-Started-with-Fuseki" class="headerlink" title="Getting Started with Fuseki"></a>Getting Started with Fuseki</h4><ul><li>下载、安装</li></ul><h4 id="Adding-Data-to-a-Dataset"><a href="#Adding-Data-to-a-Dataset" class="headerlink" title="Adding Data to a Dataset"></a>Adding Data to a Dataset</h4><ul><li>更新文件后缀为.ru，意思是一个插入请求，not a query<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># INSERT DATA后面跟要插入的triples</span></span><br><span class="line"><span class="comment"># 简单快速插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">DATA</span> </span><br><span class="line">{d:i8301 ab:homeTel <span class="string">"(718) 440-9821"</span> . ab:Person a rdfs:<span class="keyword">Class</span> .}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#where后面跟triple patterns，可以引用上面的变量</span></span><br><span class="line"><span class="comment"># 灵活创造</span></span><br><span class="line"><span class="keyword">INSERT</span> {d:i8301 ab:homeTel <span class="string">"(718) 440-9821"</span> . ab:Person a rdfs:<span class="keyword">Class</span> .}</span><br><span class="line"><span class="keyword">WHERE</span> {}</span><br></pre></td></tr></tbody></table></figure></li><li>三元组模式就是任意位置都可以被变量替换的三元组</li></ul><h4 id="Deleting-Data"><a href="#Deleting-Data" class="headerlink" title="Deleting Data"></a>Deleting Data</h4><ul><li>DELETE DATA{}和DELETE{}WHERE{}</li><li>DELETE WHERE{} :删除匹配where条件的三元组</li><li>CLEAR  DEFAULT</li></ul><h4 id="Changing-Existing-Data"><a href="#Changing-Existing-Data" class="headerlink" title="Changing Existing Data"></a>Changing Existing Data</h4><ul><li>在一次更新操作中，删除+插入</li><li>即使删除发生在插入之前，INSERT图形模式仍然具有WHERE子句存储的所有信息</li></ul><h4 id="Named-Graphs"><a href="#Named-Graphs" class="headerlink" title="Named Graphs"></a>Named Graphs</h4><ul><li>SPARQL更新允许使用分号连接多个操作</li><li>将三元组插入不存在的图时，SPARQL处理器会创建该图</li></ul><h4 id="Dropping-Graphs"><a href="#Dropping-Graphs" class="headerlink" title="Dropping Graphs"></a>Dropping Graphs</h4><ul><li>DROP GRAPH d:g1 #删除图g1</li><li>DROP DEFAULT #清除默认图，（因为默认图总是存在，即使为空</li><li>DROP NAMED：删除命名图</li><li>DROP ALL ：删除所有图</li><li>SPARQL Update没有UNDO操作，因此DROP ALL是个需要慎重的动作</li><li>这里的DROP换为CLEAR表示图中的清除三元组</li><li>CREATE GRAPH：创建一个空白图</li></ul><h4 id="Named-Graph-Syntax-Shortcuts-WITH-and-USING"><a href="#Named-Graph-Syntax-Shortcuts-WITH-and-USING" class="headerlink" title="Named Graph Syntax Shortcuts: WITH and USING"></a>Named Graph Syntax Shortcuts: WITH and USING</h4><ul><li>with语句指明要操作的图，比GRAPH节省</li><li>USING的作用类似于SELECT语句的FROM</li><li>USING NAMED === FROM NAMED  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USING NAMED d:g2 </span><br><span class="line">WHERE</span><br><span class="line">{ </span><br><span class="line">    <span class="comment"># 这里一定要声明GRAPH d:g2</span></span><br><span class="line">    GRAPH d:g2 {?s dm:tag "five" . ?s dm:tag "six" .}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>使用USING就不要使用WITH</li></ul><h4 id="Deleting-and-Replacing-Triples-in-Named-Graphs"><a href="#Deleting-and-Replacing-Triples-in-Named-Graphs" class="headerlink" title="Deleting and Replacing Triples in Named Graphs"></a>Deleting and Replacing Triples in Named Graphs</h4>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">DATA</span> { GRAPH d:g2{ d:x dm:tag <span class="string">"six"</span> }}</span><br></pre></td></tr></tbody></table></figure>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRAPH+图名或者变量名</span></span><br><span class="line"><span class="keyword">DELETE</span> { GRAPH ?g { ?s ?p <span class="string">"three"</span> } } </span><br><span class="line"><span class="keyword">WHERE</span> { GRAPH ?g { ?s ?p <span class="string">"three"</span> } }</span><br></pre></td></tr></tbody></table></figure>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> d:g1 </span><br><span class="line"><span class="keyword">DELETE</span> { ?s ?p <span class="string">"four"</span>}</span><br><span class="line"><span class="keyword">WHERE</span> { ?s ?p <span class="string">"four"</span>}</span><br></pre></td></tr></tbody></table></figure><h3 id="Building-Applications-With-SPARQL"><a href="#Building-Applications-With-SPARQL" class="headerlink" title="Building Applications With SPARQL"></a>Building Applications With SPARQL</h3><ul><li>将查询发送到端点的最常见方式是将查询的转义版本作为参数添加到端点的URI</li><li>D2RQ</li><li>SPARQLWrapper for python</li><li>ARQ source code for java</li></ul><h3 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h3><ul><li><strong>blank node</strong>: A subject or object in an RDF graph that has no identity. These are typically used to group together other values</li><li><strong>default graph</strong>: The triples in an RDF dataset that don’t belong to a named graph</li><li><strong>IRI</strong>: Internationalized Resource Identifier: a URI that allows a wider choice of characters,making it “internationalized.”</li><li><strong>literal</strong>: A value, as opposed to a URI, which is a name for something. A literal may have a datatype or a spoken language tag associated with it, but not both. A simple literal is a literal with no language tag or datatype</li><li><strong>N3</strong>: A non-XML RDF serialization format developed by Tim Berners-Lee. Turtle is a simplified version of N3</li><li><strong>N-Triples</strong>: A very simple RDF serialization format that shows complete URIs with no abbreviation and a triple on each line. Often used as a graph dump format</li><li><strong>named graph</strong>: A set of triples, typically within a larger collection of them, that can be referenced with a particular name. The name is a URI</li><li><strong>RDF/XML</strong>: RDF’s original serialization format, based on XML</li><li><strong>RDFS</strong>: the RDF Schema (RDFS) specification lets you specify classes, properties, and metadata about those classes and properties. These serve as metadata to let you infer new facts about your data, not as validation rules to indicate correct versus incorrect data</li><li><strong>triplestore</strong>: A specialized database manager designed for storing triples</li><li><strong>Turtle</strong>: An increasingly popular RDF serialization format based on N3</li><li><strong>URI</strong>: “URI” is used more often to refer to an identifier, and “URL” to refer to a locator, or address.We use URIs to identify resources and property names in RDF</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Jumping-Right-In&quot;&gt;&lt;a href=&quot;#Jumping-Right-In&quot; class=&quot;headerlink&quot; title=&quot;Jumping Right In&quot;&gt;&lt;/a&gt;Jumping Right In&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;FROM指定的数据集会被调用SPARQL处理器时指定的数据集覆盖（如果都指定了&lt;/li&gt;
&lt;li&gt;RDF不是数据格式，而是数据模型，它可以选择存储数据文件的语法&lt;/li&gt;
&lt;li&gt;如果我们将数据与其它数据结合起来，那么RDF三元组的主语和谓语都必须属于特定的名称空间，以防止类似名称之间的混淆，于是我们使用URI来表示它们&lt;/li&gt;
&lt;li&gt;当使用完整的URI时，将其放在尖括号中以向处理器显示它是一个URI&lt;/li&gt;
&lt;li&gt;在semantic web开发中，词汇表是一组使用标准格式存储的术语，供人们重复使用&lt;/li&gt;
&lt;li&gt;发现不同来源三元组之间联系的能力是SPARQL的最佳特性之一&lt;/li&gt;
&lt;li&gt;约定：主谓宾分别用?s,?p,?o表示&lt;/li&gt;
&lt;li&gt;只有满足图模式中所有三元组的数据才会被返回&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱小demo</title>
    <link href="https://yikayiyo.github.io/2018/03/10/kgdemo/"/>
    <id>https://yikayiyo.github.io/2018/03/10/kgdemo/</id>
    <published>2018-03-10T02:14:20.000Z</published>
    <updated>2019-03-15T01:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>系统：<br>ubuntu16.04</p><p>软件目录:</p><ul><li>项目目录/home/gao/software/kgdemo/</li><li>数据库/home/gao/software/mysql</li><li>应用框架/home/gao/software/apache-jena-3.6.0（这里使用了它的TDB组件</li><li>SPARQL服务器/home/gao/software/apache-jena-fuseki-3.6.0</li><li>数据转化工具/home/gao/software/d2rq-0.8.1</li><li>本体构建工具/home/gao/software/Protege-5.2.0<a id="more"></a></li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>与电影相关的.基本统计数据如下：</p><ol><li>演员数量：505人</li><li>电影数量：4518部</li><li>电影类型：19类</li><li>人物与电影的关系：14451</li><li>电影与类型的关系：7898</li></ol><p>演员的基本信息包括：姓名、英文名、出生日期、死亡日期、出生地、个人简介.<br>电影的基本信息包括：电影名称、电影简介、电影评分、电影发行日期、电影类型.</p><img src="/2018/03/10/kgdemo/ErGraph.png" class=""><h3 id="本体建模"><a href="#本体建模" class="headerlink" title="本体建模"></a>本体建模</h3><img src="/2018/03/10/kgdemo/OntoGraph.png" class=""><ul><li><p>打开protege,在Ontology IRI中填写新建本体资源的IRI为”<a href="http://www.kgmovie.demo.com&quot;" target="_blank" rel="noopener">http://www.kgmovie.demo.com"</a></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入protege目录,执行下面的命令</span></span><br><span class="line">./run.sh</span><br></pre></td></tr></tbody></table></figure></li><li><p>点击“Entities”tab标签,选择“Classes”标签.在这个界面,我们创建电影知识图谱的类/概念.</p><p>在owl:Thing下创建三个子类,Person,Movie,Genre.三个类的默认关系是互斥的.</p></li></ul><ul><li><p>切换到”Object Properties”页面创建<strong>类之间的关系,即,对象属性</strong>。</p><p>创建了三个对象属性，”hasActedIn”表示某人参演了某电影,该属性的”domain”是人,”range”是电影。(*”domain”表示该属性是属于哪个类的，”range”表示该属性的取值范围*),设置该属性的逆属性(Inverse of)是”hasActor”,可用于推理.另外一个属性”hasGenre”表示电影属于什么类型.</p></li><li><p>切换到”Data properties”页面创建<strong>类的属性,即,数据属性</strong>.</p><p>其实区分数据属性和对象属性还有一个很直观的方法,我们观察其”range”取值范围即可.</p><p><strong>对象属性的取值范围是类,而数据属性的取值范围则是字面量.</strong></p></li><li><p>保存文件,命名为”kgdemo.owl”</p></li><li><p>注意到,<strong>mysql中有五个表,本体中只有三个类</strong></p></li></ul><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><h3 id="mysql-gt-RDF"><a href="#mysql-gt-RDF" class="headerlink" title="mysql -> RDF"></a>mysql -&gt; RDF</h3><ul><li><p>下载D2RQ，进入其目录，运行下面的命令生成<strong>默认的</strong>mapping文件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./generate-mapping -u &lt;username&gt; -p &lt;password&gt; -o ../kgdemo/kg_demo_movie_mapping.ttl jdbc:mysql:///kg_demo_movie</span><br></pre></td></tr></tbody></table></figure></li><li><p>根据我们定义的本体<strong>修改mapping文件</strong></p><p>ttl文件中添加前缀: @prefix : <a href="http://www.kgmovie.demo.com#" target="_blank" rel="noopener">http://www.kgmovie.demo.com#</a> .(包括最后的这个句号)</p><p>去除没用的genre__label和genre_genre_id信息</p><p>vocab:xxxx 换成了本体构建时候的类</p><p>d2rq:property属性修改为本体中定义的属性(对象属性或者数据属性)</p></li><li><p>数据转为RDF</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./dump-rdf -o ../kgdemo/kg_demo_movie.nt ../kgdemo/kg_demo_movie_mapping.ttl</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询示例</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ?titles <span class="keyword">WHERE</span> {</span><br><span class="line">  ?p rdf:<span class="keyword">type</span> :Person.</span><br><span class="line">  ?p :personEnglishName <span class="string">'Stephen Chow'</span>.</span><br><span class="line">  ?p :hasActedIn ?movies.</span><br><span class="line">  ?movies :movieTitle ?titles</span><br><span class="line">}</span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>返回结果为:</p><table><thead><tr><th>titles</th></tr></thead><tbody><tr><td>“功夫”</td></tr><tr><td>“琉璃樽”</td></tr><tr><td>“英雄本色”</td></tr><tr><td>“少林足球”</td></tr><tr><td>“西游记第壹佰零壹回之月光宝盒”</td></tr><tr><td>“长江七号”</td></tr><tr><td>“西游记大结局之仙履奇缘”</td></tr><tr><td>“建国大业”</td></tr><tr><td>“审死官”</td></tr><tr><td>“龙在天涯”</td></tr></tbody></table></li></ul><h3 id="Bug-To-Fix"><a href="#Bug-To-Fix" class="headerlink" title="Bug To Fix"></a>Bug To Fix</h3><p>使用中文姓名查询不到person</p><h2 id="jena-SPARQL-endpoint及推理"><a href="#jena-SPARQL-endpoint及推理" class="headerlink" title="jena SPARQL endpoint及推理"></a>jena SPARQL endpoint及推理</h2><h3 id="jena示例"><a href="#jena示例" class="headerlink" title="jena示例"></a>jena示例</h3><ul><li>下载apache-jena和apache-jena-fuseki</li><li>在apache-jena目录下,使用“tdbloader”将之前我们的RDF数据以TDB的方式存储。命令如下：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./tdbloader --loc="../../kgdemo/tdb" "../../kgdemo/kg_demo_movie.nt"</span><br><span class="line">16:15:50 INFO  loader               :: -- Start triples data phase</span><br><span class="line">16:15:50 INFO  loader               :: ** Load empty triples table</span><br><span class="line">16:15:50 INFO  loader               :: -- Start quads data phase</span><br><span class="line">16:15:50 INFO  loader               :: ** Load empty quads table</span><br><span class="line">16:15:50 INFO  loader               :: Load: ../../kgdemo/kg_demo_movie.nt -- 2018/03/19 16:15:50 CST</span><br><span class="line">16:15:52 INFO  loader               :: -- Finish triples data phase</span><br><span class="line">16:15:52 INFO  loader               :: ** Data: 47,144 triples loaded in 1.26 seconds [Rate: 37,327.00 per second]</span><br><span class="line">16:15:52 INFO  loader               :: -- Finish quads data phase</span><br><span class="line">16:15:52 INFO  loader               :: -- Start triples index phase</span><br><span class="line">16:15:52 INFO  loader               :: ** Index SPO-&gt;POS: 47,144 slots indexed in 0.14 seconds [Rate: 334,354.63 per second]</span><br><span class="line">16:15:52 INFO  loader               :: ** Index SPO-&gt;OSP: 47,144 slots indexed in 0.13 seconds [Rate: 374,158.72 per second]</span><br><span class="line">16:15:52 INFO  loader               :: -- Finish triples index phase</span><br><span class="line">16:15:52 INFO  loader               :: ** 47,144 triples indexed in 0.27 seconds [Rate: 172,688.64 per second]</span><br><span class="line">16:15:52 INFO  loader               :: -- Finish triples load</span><br><span class="line">16:15:52 INFO  loader               :: ** Completed: 47,144 triples loaded in 1.55 seconds [Rate: 30,356.73 per second]</span><br><span class="line">16:15:52 INFO  loader               :: -- Finish quads load</span><br></pre></td></tr></tbody></table></figure><ul><li>在fuseki-server目录下,运行 <em>./fuseki-server</em> 服务,会在当前目录生成run文件夹,将本体文件重命名为”kgdemo.ttl”放入run/database,然后在run/configuration里创建config.ttl文件,内容为:</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@prefix :      &lt;http://base/#&gt; .</span><br><span class="line">@prefix tdb:   &lt;http://jena.hpl.hp.com/2008/tdb#&gt; .</span><br><span class="line">@prefix rdf:   &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .</span><br><span class="line">@prefix ja:    &lt;http://jena.hpl.hp.com/2005/11/Assembler#&gt; .</span><br><span class="line">@prefix rdfs:  &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .</span><br><span class="line">@prefix fuseki: &lt;http://jena.apache.org/fuseki#&gt; .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:service1        a                fuseki:Service ;</span><br><span class="line">fuseki:dataset                    &lt;#dataset&gt; ;</span><br><span class="line">fuseki:name                       "kg_demo_movie" ;</span><br><span class="line">fuseki:serviceQuery               "query" , "sparql" ;</span><br><span class="line">fuseki:serviceReadGraphStore      "get" ;</span><br><span class="line">fuseki:serviceReadWriteGraphStore "data" ;</span><br><span class="line">fuseki:serviceUpdate              "update" ;</span><br><span class="line">fuseki:serviceUpload              "upload" .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;#dataset&gt; rdf:type ja:RDFDataset ;</span><br><span class="line">    ja:defaultGraph &lt;#model_inf&gt; ;</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">&lt;#model_inf&gt; a ja:InfModel ;</span><br><span class="line">    ja:baseModel &lt;#tdbGraph&gt; ;</span><br><span class="line"></span><br><span class="line">    #本体文件的路径</span><br><span class="line">    ja:content [ja:externalContent &lt;file:////home/gao/software/apache-jena-fuseki-3.6.0/run/databases/kgdemo.ttl&gt; ] ;</span><br><span class="line">    </span><br><span class="line">    #启用OWL推理机</span><br><span class="line">    ja:reasoner [ja:reasonerURL &lt;http://jena.hpl.hp.com/2003/OWLFBRuleReasoner&gt;] .</span><br><span class="line"></span><br><span class="line">&lt;#tdbGraph&gt; rdf:type tdb:GraphTDB ;</span><br><span class="line">    tdb:dataset &lt;#tdbDataset&gt; ;</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">&lt;#tdbDataset&gt; rdf:type tdb:DatasetTDB ;</span><br><span class="line">    tdb:location "/home/gao/software/kgdemo/tdb" ;</span><br></pre></td></tr></tbody></table></figure><ul><li>重启运行 <em>./fuseki-server</em></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[2018-03-19 16:39:13] Server     INFO  Apache Jena Fuseki 3.6.0</span><br><span class="line">[2018-03-19 16:39:13] Config     INFO  FUSEKI_HOME=/home/gao/software/apache-jena-fuseki-3.6.0</span><br><span class="line">[2018-03-19 16:39:13] Config     INFO  FUSEKI_BASE=/home/gao/software/apache-jena-fuseki-3.6.0/run</span><br><span class="line">[2018-03-19 16:39:13] Config     INFO  Shiro file: file:///home/gao/software/apache-jena-fuseki-3.6.0/run/shiro.ini</span><br><span class="line">[2018-03-19 16:39:13] Config     INFO  Configuration file: /home/gao/software/apache-jena-fuseki-3.6.0/run/config.ttl</span><br><span class="line">[2018-03-19 16:39:13] Config     INFO  Load configuration: file:///home/gao/software/apache-jena-fuseki-3.6.0/run/configuration/conf.ttl</span><br><span class="line">[2018-03-19 16:39:13] Config     INFO  Register: /kg_demo_movie</span><br><span class="line">[2018-03-19 16:39:13] Server     INFO  Started 2018/03/19 16:39:13 CST on port 3030</span><br></pre></td></tr></tbody></table></figure><ul><li>打开页面localhost:3030,查询,这里使用中文ok</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;</span><br><span class="line">prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;</span><br><span class="line">prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt;</span><br><span class="line">prefix : &lt;http://www.kgmovie.demo.com#&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ?titles <span class="keyword">WHERE</span> {</span><br><span class="line">  ?p rdf:<span class="keyword">type</span> :Person.</span><br><span class="line">  ?p :personName <span class="string">'周星驰'</span>.</span><br><span class="line">  ?p :hasActedIn ?movies.</span><br><span class="line">  ?movies :movieTitle ?titles</span><br><span class="line">}</span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th></th><th>titles</th></tr></thead><tbody><tr><td>1</td><td>“琉璃樽”</td></tr><tr><td>2</td><td>“西游记第壹佰零壹回之月光宝盒”</td></tr><tr><td>3</td><td>“大内密探零零发”</td></tr><tr><td>4</td><td>“功夫”</td></tr><tr><td>5</td><td>“长江七号”</td></tr><tr><td>6</td><td>“回魂夜”</td></tr><tr><td>7</td><td>“百变星君”</td></tr><tr><td>8</td><td>“英雄本色”</td></tr><tr><td>9</td><td>“建国大业”</td></tr><tr><td>10</td><td>“唐伯虎点秋香”</td></tr></tbody></table><h3 id="自定义推理规则"><a href="#自定义推理规则" class="headerlink" title="自定义推理规则"></a>自定义推理规则</h3><ul><li>在“databases”文件夹下新建一个文本文件“rules.ttl”，填入如下内容：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@prefix : &lt;http://www.kgmovie.demo.com#&gt; .</span><br><span class="line">@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .</span><br><span class="line">@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .</span><br><span class="line">@prefix xsd: &lt;XML Schema&gt; .</span><br><span class="line">@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .</span><br><span class="line"></span><br><span class="line">[ruleComedian: (?p :hasActedIn ?m) (?m :hasGenre ?g) (?g :genreName '喜剧') -&gt; (?p rdf:type :Comedian)]</span><br><span class="line">[ruleInverse: (?p :hasActedIn ?m) -&gt; (?m :hasActor ?p)]</span><br></pre></td></tr></tbody></table></figure><ul><li>修改juseki-server配置文件:</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@prefix :      &lt;http://base/#&gt; .</span><br><span class="line">@prefix tdb:   &lt;http://jena.hpl.hp.com/2008/tdb#&gt; .</span><br><span class="line">@prefix rdf:   &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .</span><br><span class="line">@prefix ja:    &lt;http://jena.hpl.hp.com/2005/11/Assembler#&gt; .</span><br><span class="line">@prefix rdfs:  &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .</span><br><span class="line">@prefix fuseki: &lt;http://jena.apache.org/fuseki#&gt; .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:service1        a                fuseki:Service ;</span><br><span class="line">fuseki:dataset                    &lt;#dataset&gt; ;</span><br><span class="line">fuseki:name                       "kg_demo_movie" ;</span><br><span class="line">fuseki:serviceQuery               "query" , "sparql" ;</span><br><span class="line">fuseki:serviceReadGraphStore      "get" ;</span><br><span class="line">fuseki:serviceReadWriteGraphStore "data" ;</span><br><span class="line">fuseki:serviceUpdate              "update" ;</span><br><span class="line">fuseki:serviceUpload              "upload" .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;#dataset&gt; rdf:type ja:RDFDataset ;</span><br><span class="line">    ja:defaultGraph &lt;#model_inf&gt; ;</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">&lt;#model_inf&gt; a ja:InfModel ;</span><br><span class="line">    ja:baseModel &lt;#tdbGraph&gt; ;</span><br><span class="line"></span><br><span class="line">    #本体文件的路径</span><br><span class="line">    ja:content [ja:externalContent &lt;file:////home/gao/software/apache-jena-fuseki-3.6.0/run/databases/kgdemo.ttl&gt; ] ;</span><br><span class="line">    </span><br><span class="line">    #关闭OWL推理机</span><br><span class="line">    #ja:reasoner [ja:reasonerURL &lt;http://jena.hpl.hp.com/2003/OWLFBRuleReasoner&gt;] .</span><br><span class="line"></span><br><span class="line">#开启规则推理机，并指定规则文件路径</span><br><span class="line">    ja:reasoner [</span><br><span class="line">        ja:reasonerURL &lt;http://jena.hpl.hp.com/2003/GenericRuleReasoner&gt; ; </span><br><span class="line">        ja:rulesFrom &lt;file:////home/gao/software/apache-jena-fuseki-3.6.0/run/databases/rules.ttl&gt; ; ]</span><br><span class="line">    .</span><br><span class="line">&lt;#tdbGraph&gt; rdf:type tdb:GraphTDB ;</span><br><span class="line">    tdb:dataset &lt;#tdbDataset&gt; ;</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">&lt;#tdbDataset&gt; rdf:type tdb:DatasetTDB ;</span><br><span class="line">    tdb:location "/home/gao/software/kgdemo/tdb" ;</span><br><span class="line">    .</span><br></pre></td></tr></tbody></table></figure><ul><li>查询:</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> n <span class="keyword">WHERE</span> {</span><br><span class="line">?x rdf:<span class="keyword">type</span> :Comedian.</span><br><span class="line">?x :personName ?n.</span><br><span class="line">}</span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><p>结果如下:</p><table><thead><tr><th></th><th>n</th></tr></thead><tbody><tr><td>1</td><td>“邓浩光”</td></tr><tr><td>2</td><td>“梁朝伟”</td></tr><tr><td>3</td><td>“杨恭如”</td></tr><tr><td>4</td><td>“梁韵蕊”</td></tr><tr><td>5</td><td>“吴宇森”</td></tr><tr><td>6</td><td>“徐锦江”</td></tr><tr><td>7</td><td>“黄家驹”</td></tr><tr><td>8</td><td>“叶进”</td></tr><tr><td>9</td><td>“午马”</td></tr><tr><td>10</td><td>“梁咏琪”</td></tr></tbody></table><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>不用sparql，用natural language查询结果<br>query-answer</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h2&gt;&lt;p&gt;系统：&lt;br&gt;ubuntu16.04&lt;/p&gt;
&lt;p&gt;软件目录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目目录/home/gao/software/kgdemo/&lt;/li&gt;
&lt;li&gt;数据库/home/gao/software/mysql&lt;/li&gt;
&lt;li&gt;应用框架/home/gao/software/apache-jena-3.6.0（这里使用了它的TDB组件&lt;/li&gt;
&lt;li&gt;SPARQL服务器/home/gao/software/apache-jena-fuseki-3.6.0&lt;/li&gt;
&lt;li&gt;数据转化工具/home/gao/software/d2rq-0.8.1&lt;/li&gt;
&lt;li&gt;本体构建工具/home/gao/software/Protege-5.2.0&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="知识图谱" scheme="https://yikayiyo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>构建IT领域概念图谱</title>
    <link href="https://yikayiyo.github.io/2018/01/10/%E6%9E%84%E5%BB%BAIT%E9%A2%86%E5%9F%9F%E6%A6%82%E5%BF%B5%E5%9B%BE%E8%B0%B1/"/>
    <id>https://yikayiyo.github.io/2018/01/10/%E6%9E%84%E5%BB%BAIT%E9%A2%86%E5%9F%9F%E6%A6%82%E5%BF%B5%E5%9B%BE%E8%B0%B1/</id>
    <published>2018-01-10T09:17:14.000Z</published>
    <updated>2018-01-10T10:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.sciencedirect.com/science/article/pii/S0957417415005941" target="_blank" rel="noopener">原文地址</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    <strong>关联开放数据</strong>（LOD）中包含丰富的知识和语义，它的发展促使了很多知识型应用的诞生和兴起。在这些应用中，实体间的相关性（不同于相似性）这一概念扮演了重要角色。</p><p>​    在给定一个查询后我们感兴趣的不只是确切的返回值（exact answers ），还有那些与查询紧密相关的东西。</p><p>​    利用DBpedia中IT领域数据构建概念图谱的方法，不仅利用字符串匹配，还可以利用LOD数据集中编码的显示或隐式语义。在此基础上构建的专家系统，可以帮助那些在IT领域进行<strong>实体搜索</strong>任务的用户。</p><p>​    为了对相关实体进行<strong>排序</strong>需要计算相关度，这就涉及到不同的<strong>相关性度量</strong>（relatedness measures）。</p><h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>​    基于关键词匹配的搜索在同义、歧义发生时，表现得很挣扎（suffer）。哪怕查询语句、资源描述都结构化了，同样的问题依然存在。导致这一问题的主要原因是，它们都<strong>无法捕获</strong>查询、资源描述中的词语的<strong>词义(meaning of terms)以及语义关联(the semantic relation)</strong>。</p><p>​    相关性（relatedness）是语义上的，比相似性概念宽泛（wider）。举例来说，MySQL和PostgreSQL很相似的，PHP和MySQL则是很相关的。</p><p>​    构建图谱的关键在于，怎么衡量两个实体间的相关度。</p><p>​    本文提出了一种语义感知的度量来评估实体间相关度，并利用这个度量构建IT领域概念图谱，图上每个节点都是IT概念（编程语言、数据库、技术、框架，等等）。</p><p>​    构建图谱时，利用了来自web的数据的<strong>统计特征</strong>以及从LOD数据集中抽取的<strong>语义知识</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0957417415005941&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a 
      
    
    </summary>
    
    
    
      <category term="知识图谱" scheme="https://yikayiyo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
      <category term="关联数据" scheme="https://yikayiyo.github.io/tags/%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE/"/>
    
      <category term="DBpedia" scheme="https://yikayiyo.github.io/tags/DBpedia/"/>
    
  </entry>
  
</feed>
