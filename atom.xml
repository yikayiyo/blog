<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misbehavior</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yikayiyo.github.io/"/>
  <updated>2020-01-09T11:53:01.796Z</updated>
  <id>https://yikayiyo.github.io/</id>
  
  <author>
    <name>yikayiyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Task Parallelism</title>
    <link href="https://yikayiyo.github.io/2020/01/08/Task%20Parallelism/"/>
    <id>https://yikayiyo.github.io/2020/01/08/Task%20Parallelism/</id>
    <published>2020-01-08T10:59:19.000Z</published>
    <updated>2020-01-09T11:53:01.796Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.coursera.org/learn/parallel-programming-in-java/" target="_blank" rel="external">https://www.coursera.org/learn/parallel-programming-in-java/</a></p><h3 id="Task-Creation-and-Termination-Async-Finish" class="heading-control"><a href="#Task-Creation-and-Termination-Async-Finish" class="headerlink" title="Task Creation and Termination (Async, Finish)"></a>Task Creation and Termination (Async, Finish)<a class="heading-anchor" href="#Task-Creation-and-Termination-Async-Finish" aria-hidden="true"></a></h3><p>以数组求和作为例子</p><p>为了求得数组的和，可以将数组分为前后两个部分。两部分的求和可以并行执行，但是在求总和之前要保证两个子任务已经完成。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">finish {</div><div class="line">  async SUM1;  <span class="comment">// asynchronously compute sum of the lower half of the array</span></div><div class="line">  SUM2;  <span class="comment">// compute sum of the upper half of the array in parallel with SUM1</span></div><div class="line">}</div><div class="line">SUM;  <span class="comment">// combine the two partial sums after both SUM1 and SUM2 have finished</span></div></pre></td></tr></tbody></table></figure><p><code>async &lt;stmt1&gt;</code> ：父任务创建子任务执行<code>&lt;stmt1&gt;</code>，并且是并行于父任务的其余部分执行</p><p>上面的伪代码中，<code>async SUM1;</code>创建子任务SUM1，和SUM2并行执行</p><p><code>finish &lt;stmt2&gt;</code>：父任务执行<code>&lt;stmt2&gt;</code>，并且等待<code>&lt;stmt2&gt;以及其中创建的异步任务</code>完成</p><p>上例中，父任务等待SUM1和SUM2完成，才能执行SUM</p><h3 id="Tasks-in-Java’s-Fork-Join-Framework" class="heading-control"><a href="#Tasks-in-Java’s-Fork-Join-Framework" class="headerlink" title="Tasks in Java’s Fork/Join Framework"></a>Tasks in Java’s Fork/Join Framework<a class="heading-anchor" href="#Tasks-in-Java’s-Fork-Join-Framework" aria-hidden="true"></a></h3><p>数组求和的<strong>分治</strong>写法<a id="more"></a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ASum</span></span>{</div><div class="line">  <span class="keyword">int</span>[] A; <span class="comment">// input array</span></div><div class="line">  <span class="keyword">int</span> LO, HI; <span class="comment">// subrange</span></div><div class="line">  <span class="keyword">int</span> SUM; <span class="comment">// return value</span></div><div class="line">  ASum(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high){</div><div class="line">    <span class="keyword">this</span>.A = array;</div><div class="line">    <span class="keyword">this</span>.LO = low;</div><div class="line">    <span class="keyword">this</span>.HI = high;</div><div class="line">  }</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">if</span> (LO==HI) SUM = A[LO];</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LO&gt;HI) SUM = <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> {</div><div class="line">      <span class="keyword">int</span> MID = (LO+HI)/<span class="number">2</span>;</div><div class="line">      L = <span class="keyword">new</span> ASum(A, LO, MID);</div><div class="line">      R = <span class="keyword">new</span> ASum(A, MID, HI);</div><div class="line">      L.compute();</div><div class="line">      R.compute();</div><div class="line">      SUM = L.SUM + R.SUM;</div><div class="line">    }</div><div class="line">  } <span class="comment">// compute()</span></div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>并行写法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASum</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>{  <span class="comment">//没有返回值的继承RecursiveAction，比如对数组排序</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> seqThreshold = <span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span>[] array;</div><div class="line">    <span class="keyword">int</span> lo, hi;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ASum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>{</div><div class="line">        <span class="keyword">this</span>.array = array;</div><div class="line">        <span class="keyword">this</span>.lo = low;</div><div class="line">        <span class="keyword">this</span>.hi = high;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> ((hi - lo) &lt;= seqThreshold) {  <span class="comment">//不再切分为子任务</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i++)</div><div class="line">                res += array[i];</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</div><div class="line">            ASum L = <span class="keyword">new</span> ASum(array, lo, mid);</div><div class="line">            ASum R = <span class="keyword">new</span> ASum(array, mid, hi);</div><div class="line">            <span class="comment">// L.fork();</span></div><div class="line">            <span class="comment">// R.fork();</span></div><div class="line">            invokeAll(L, R);  <span class="comment">//和上面的两句等价</span></div><div class="line">            res += L.join() + R.join();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumOfInts</span><span class="params">(ForkJoinPool pool, <span class="keyword">int</span>[] array)</span> </span>{</div><div class="line">        <span class="keyword">int</span> n = array.length;</div><div class="line">        ASum a = <span class="keyword">new</span> ASum(array, <span class="number">0</span>, n);</div><div class="line">        <span class="keyword">return</span> pool.invoke(a);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>{</div><div class="line">        <span class="keyword">int</span>[] nums = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> };</div><div class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</div><div class="line">        System.out.println(sumOfInts(pool, nums));</div><div class="line">    }</div><div class="line">    </div><div class="line">}</div></pre></td></tr></tbody></table></figure><h3 id="Computation-Graphs-Work-Span" class="heading-control"><a href="#Computation-Graphs-Work-Span" class="headerlink" title="Computation Graphs, Work, Span"></a>Computation Graphs, Work, Span<a class="heading-anchor" href="#Computation-Graphs-Work-Span" aria-hidden="true"></a></h3><h4 id="Computation-Graphs" class="heading-control"><a href="#Computation-Graphs" class="headerlink" title="Computation Graphs"></a>Computation Graphs<a class="heading-anchor" href="#Computation-Graphs" aria-hidden="true"></a></h4><p>Computation Graphs (CGs) model the execution of a parallel program as a <a href="http://en.wikipedia.org/wiki/Partially_ordered_set" target="_blank" rel="external">partially ordered set</a>.</p><p>A CG consist of:</p><ul><li>A set of <em>vertices</em> or <em>nodes</em>, in which each node represents a <em>step</em> consisting of an <strong>arbitrary sequential computation</strong>.</li><li>A set of <em>directed</em> <em>edges</em> that represent <strong>ordering constraints</strong> among steps.</li></ul><p>对于fork-join框架，可以将这些有向边分为三类：</p><ul><li><em>Continue</em> edges，连接任务中顺序执行的步骤</li><li>Fork edges，将fork操作连接到子任务的第一个步骤</li><li>join edges connect the last step of a task to all <em>join</em> operations on that task</li></ul><p>一个小例子</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">S1</div><div class="line">fork S2</div><div class="line">S3</div><div class="line">join S2  <span class="comment">// 这里join S2发生在S4之前</span></div><div class="line">S4</div><div class="line"><span class="comment">// S5 如果有的话，连接到S4之后</span></div></pre></td></tr></tbody></table></figure><p>对应的CG为<br><img src="/2020/01/08/Task%20Parallelism/image-20200108094903279.png" alt="image-20200108094903279.png" title=""></p><h4 id="CGs上的data-race" class="heading-control"><a href="#CGs上的data-race" class="headerlink" title="CGs上的data race"></a>CGs上的data race<a class="heading-anchor" href="#CGs上的data-race" aria-hidden="true"></a></h4><p>没有边连接的两个节点同时写或者读写相同的位置时发生data race</p><h4 id="CGs上的理想并行程度-（ideal-parallelism）" class="heading-control"><a href="#CGs上的理想并行程度-（ideal-parallelism）" class="headerlink" title="CGs上的理想并行程度 （ideal parallelism）"></a>CGs上的理想并行程度 （<em>ideal parallelism</em>）<a class="heading-anchor" href="#CGs上的理想并行程度-（ideal-parallelism）" aria-hidden="true"></a></h4><p>与计算机的实际并行性无关<br>$$<br>ideal\,parallelism = \frac{WORK(G)}{SPAN(G)} \tag{1}<br>$$</p><p>其中：</p><ul><li>WORK(G)为G中所有节点执行时间之和</li><li>SPAN(G)为G中关键路径上节点的执行时间之和，上例中SPAN(G)为 <strong>max((S1,S3,S4), (S1,S2,S4))</strong></li></ul><h3 id="Multiprocessor-Scheduling-Parallel-Speedup" class="heading-control"><a href="#Multiprocessor-Scheduling-Parallel-Speedup" class="headerlink" title="Multiprocessor Scheduling, Parallel Speedup"></a>Multiprocessor Scheduling, Parallel Speedup<a class="heading-anchor" href="#Multiprocessor-Scheduling-Parallel-Speedup" aria-hidden="true"></a></h3><h4 id="假设" class="heading-control"><a href="#假设" class="headerlink" title="假设"></a>假设<a class="heading-anchor" href="#假设" aria-hidden="true"></a></h4><p>有P个处理器，每个处理器都相同，每一个节点的执行时间都是固定的（不管在那个处理器上），处理器都是<strong>贪心</strong>地执行任务<br>T_p表示在p个处理器上执行一个CG所花的时间,<br>相同的P个处理器，相同的CG，不同的调度算法也可能对应不同的T_p</p><p>$$<br>T_{\infty} \le T_p \le T_1<br>$$</p><h4 id="Speedup-P" class="heading-control"><a href="#Speedup-P" class="headerlink" title="Speedup(P)"></a>Speedup(P)<a class="heading-anchor" href="#Speedup-P" aria-hidden="true"></a></h4><p>the parallel speedup for a given schedule of a CG on <em>P</em> processors，满足下面：<br>$$<br>Speedup(P) = \frac{T_1}{T_P} \tag{2}<br>$$</p><p>$$<br>Speedup(P) \le P \tag{3}<br>$$</p><p>$$<br>Speedup(P) \le \frac {WORK}{SPAN} \tag{4}<br>$$</p><p>（3）表示P个处理器不能带来P倍的加速</p><p>（4）表示现实骨感，理想丰满</p><h3 id="Amdahl’s-Law" class="heading-control"><a href="#Amdahl’s-Law" class="headerlink" title="Amdahl’s Law"></a><strong>Amdahl’s Law</strong><a class="heading-anchor" href="#Amdahl’s-Law" aria-hidden="true"></a></h3><p>if <em>q</em> <em>≤</em> 1 is the fraction of <em>WORK</em> in a parallel program that must be executed <em>sequentially</em>, then the best speedup that can be obtained for that program for any number of processors, <em>P</em> , is <em>Speedup(P)</em> <em>≤</em> 1<em>/q</em>.</p><p>例如，如果线性工作占比为0.5，则不管处理器个数再多，有<em>Speedup(P)</em> <em>≤</em> 2</p><p>因为有<br>$$<br>WORK(G)*q \leq SPAN(G) \tag{5}\<br>==&gt;  \frac{WORK(G)}{SPAN(G)} \leq \frac{1}{q}<br>$$<br>上式表示关键路径用时不小于任务中线性部分的用时</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/parallel-programming-in-java/&quot;&gt;https://www.coursera.org/learn/parallel-programming-in-java/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Task-Creation-and-Termination-Async-Finish&quot;&gt;&lt;a href=&quot;#Task-Creation-and-Termination-Async-Finish&quot; class=&quot;headerlink&quot; title=&quot;Task Creation and Termination (Async, Finish)&quot;&gt;&lt;/a&gt;Task Creation and Termination (Async, Finish)&lt;/h3&gt;&lt;p&gt;以数组求和作为例子&lt;/p&gt;
&lt;p&gt;为了求得数组的和，可以将数组分为前后两个部分。两部分的求和可以并行执行，但是在求总和之前要保证两个子任务已经完成。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;finish {&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  async SUM1;  &lt;span class=&quot;comment&quot;&gt;// asynchronously compute sum of the lower half of the array&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  SUM2;  &lt;span class=&quot;comment&quot;&gt;// compute sum of the upper half of the array in parallel with SUM1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;}&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;SUM;  &lt;span class=&quot;comment&quot;&gt;// combine the two partial sums after both SUM1 and SUM2 have finished&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;async &amp;lt;stmt1&amp;gt;&lt;/code&gt; ：父任务创建子任务执行&lt;code&gt;&amp;lt;stmt1&amp;gt;&lt;/code&gt;，并且是并行于父任务的其余部分执行&lt;/p&gt;
&lt;p&gt;上面的伪代码中，&lt;code&gt;async SUM1;&lt;/code&gt;创建子任务SUM1，和SUM2并行执行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finish &amp;lt;stmt2&amp;gt;&lt;/code&gt;：父任务执行&lt;code&gt;&amp;lt;stmt2&amp;gt;&lt;/code&gt;，并且等待&lt;code&gt;&amp;lt;stmt2&amp;gt;以及其中创建的异步任务&lt;/code&gt;完成&lt;/p&gt;
&lt;p&gt;上例中，父任务等待SUM1和SUM2完成，才能执行SUM&lt;/p&gt;
&lt;h3 id=&quot;Tasks-in-Java’s-Fork-Join-Framework&quot;&gt;&lt;a href=&quot;#Tasks-in-Java’s-Fork-Join-Framework&quot; class=&quot;headerlink&quot; title=&quot;Tasks in Java’s Fork/Join Framework&quot;&gt;&lt;/a&gt;Tasks in Java’s Fork/Join Framework&lt;/h3&gt;&lt;p&gt;数组求和的&lt;strong&gt;分治&lt;/strong&gt;写法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://yikayiyo.github.io/tags/java/"/>
    
      <category term="并行编程" scheme="https://yikayiyo.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Markdown显示__init__.py</title>
    <link href="https://yikayiyo.github.io/2019/12/25/Markdown%E6%98%BE%E7%A4%BA__/"/>
    <id>https://yikayiyo.github.io/2019/12/25/Markdown%E6%98%BE%E7%A4%BA__/</id>
    <published>2019-12-25T04:59:36.000Z</published>
    <updated>2019-12-25T05:31:10.970Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown语法中双下划线 <code>__</code> 和双星 <code>**</code> 都是强调作用<br>python中的 <strong>init</strong>.py就显示成这个样子了 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f612.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f612.png?v8">😒</span></p><p>可以使用反引号将其包含，显示效果: <code>__init__.py</code> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8">😋</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Markdown语法中双下划线 &lt;code&gt;__&lt;/code&gt; 和双星 &lt;code&gt;**&lt;/code&gt; 都是强调作用&lt;br&gt;python中的 &lt;strong&gt;init&lt;/strong&gt;.py就显示成这个样子了 &lt;span class=&quot;github-emoji&quot; style
      
    
    </summary>
    
    
    
      <category term="杂" scheme="https://yikayiyo.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>记录一次源码阅读</title>
    <link href="https://yikayiyo.github.io/2019/05/12/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://yikayiyo.github.io/2019/05/12/requests%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2019-05-12T08:14:00.000Z</published>
    <updated>2019-05-21T10:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/12/requests源码阅读/requests源码阅读.svg" alt="记录一次源码阅读" title="记录一次源码阅读"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/12/requests源码阅读/requests源码阅读.svg&quot; alt=&quot;记录一次源码阅读&quot; title=&quot;记录一次源码阅读&quot;&gt;&lt;script&gt;
        document.querySelectorAll(&#39;.github-emo
      
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python，读书笔记" scheme="https://yikayiyo.github.io/tags/python%EF%BC%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>DevOps for dummies</title>
    <link href="https://yikayiyo.github.io/2019/02/25/devops/"/>
    <id>https://yikayiyo.github.io/2019/02/25/devops/</id>
    <published>2019-02-25T09:19:00.000Z</published>
    <updated>2019-03-05T14:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关键词" class="heading-control"><a href="#关键词" class="headerlink" title="关键词"></a>关键词<a class="heading-anchor" href="#关键词" aria-hidden="true"></a></h3><p>business-driven, people, practice, tools</p><h3 id="原则" class="heading-control"><a href="#原则" class="headerlink" title="原则"></a>原则<a class="heading-anchor" href="#原则" aria-hidden="true"></a></h3><ul><li>Develop and test against production-like systems </li><li>Deploy with repeatable, reliable processes</li><li>Monitor and validate operational quality</li><li>Amplify feedback loops<a id="more"></a><h3 id="架构" class="heading-control"><a href="#架构" class="headerlink" title="架构"></a>架构<a class="heading-anchor" href="#架构" aria-hidden="true"></a></h3></li></ul><img src="/2019/02/25/devops/devops.png" alt="devops" title="devops"><h3 id="Notes" class="heading-control"><a href="#Notes" class="headerlink" title="Notes"></a>Notes<a class="heading-anchor" href="#Notes" aria-hidden="true"></a></h3><ul><li>DevOps isn’t the goal. It helps you reach your goals</li><li>Any kind of system that needs <strong>rapid</strong> delivery of <strong>innovation</strong> requires DevOps</li></ul><ul><li><p>In broad terms, DevOps is an approach based on <strong>lean and agile principles</strong> in which business owners and the development, operations, and quality assurance departments collaborate to deliver software <strong>in a continuous manner</strong> that enables the business to more quickly seize market opportunities and reduce the time to include customer feedback</p></li><li><p>A true DevOps approach includes lines of business, practitioners, executives, partners, suppliers, and so on</p></li><li><p><strong>Continuous testing</strong> is facilitated by adopting capabilities like <strong>automated testing</strong> and <strong>service virtualization</strong></p></li><li><p>software-defined environments enable you to capture infrastructure as a kind of programmable and repeatable pattern, thereby accelerating deployments</p></li><li><p>Collaboration and communication across stakeholders — that’s the culture of DevOps.</p></li><li><p>Giving all stakeholders <strong>visibility</strong> into a project’s goals and status is crucial for building a DevOps culture based on trust and collaboration.</p></li><li><p>Processes define what those people do. Your organization can have a great culture of collaboration, but if people are doing the wrong things or doing the right things in the wrong way, failure is still likely.</p></li><li><p>Adopting continuous delivery typically is the most critical part of adopting DevOps.</p></li><li><p>From a process perspective, you need to adopt processes in three areas to enable <strong>continuous testing</strong>:</p><p>✓ Test environment provisioning and configuration</p><p>✓ Test data management</p><p>✓ Test integration, function, performance, and security</p></li><li><p>If an organization is building or maintaining multiple applications, everything it does has to be repeatable, in a reliable manner, to ensure quality across all applications</p></li><li><p>Start by focusing on the critical parts of organization — not everything all at once — and then gradually broaden to include all stages</p></li><li><p>The build stage is where the code is compiled to create and unit test the binaries to be deployed. Multiple build tools may be used in this stage, based on cross-platform and cross-technology needs</p></li><li><p>Development organizations typically use <strong>build servers</strong> to facilitate the large number of builds required on an ongoing basis to enable continuous integration</p></li><li><p>For any organization that wants to enable <strong>continuous testing</strong>, <strong>managing test data</strong> is an essential function</p></li><li><p>end-to-end Develop/Test environments =  cloud environments + deployment automation + service virtualization</p></li><li><p>Cloud without DevOps means not leveraging all the benefits of cloud</p></li><li><p>When adopting cloud, you first want to decide on the scope of responsibility that you plan to hand over to the cloud platform and what responsibility you want to take on yourself</p></li><li><p>two primary service models for cloud: Infrastructure as a Service (<strong>IaaS</strong>) and Platform as a Service (<strong>PaaS</strong>)</p></li><li><p>treats infrastructure as code best practices：</p><ul><li>Treat pattern definitions, script packages, and services as code</li><li>version everything</li><li>Automate deployment of topology patterns to the cloud</li><li>Manage versions of patterns across multiple cloud environments</li><li>Automate the testing of patterns</li><li>Cleanup catalog resources to avoid sprawl</li></ul></li><li><p>Ten DevOps myths:</p><ul><li>DevOps Is Only for “Born on the Web” Shops</li><li>DevOps Is Operations Learning How to Code</li><li>DevOps Is Just for Development and Operations</li><li>DevOps Isn’t for ITIL Shops</li><li>DevOps Isn’t for Regulated Industries</li><li>DevOps Isn’t for Outsourced Development</li><li>No Cloud Means No DevOps</li><li>DevOps Isn’t for Large, Complex Systems</li><li>DevOps Is Only about Communication</li><li>DevOps Means Continuous Change Deployment</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关键词&quot;&gt;&lt;a href=&quot;#关键词&quot; class=&quot;headerlink&quot; title=&quot;关键词&quot;&gt;&lt;/a&gt;关键词&lt;/h3&gt;&lt;p&gt;business-driven, people, practice, tools&lt;/p&gt;
&lt;h3 id=&quot;原则&quot;&gt;&lt;a href=&quot;#原则&quot; class=&quot;headerlink&quot; title=&quot;原则&quot;&gt;&lt;/a&gt;原则&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Develop and test against production-like systems &lt;/li&gt;
&lt;li&gt;Deploy with repeatable, reliable processes&lt;/li&gt;
&lt;li&gt;Monitor and validate operational quality&lt;/li&gt;
&lt;li&gt;Amplify feedback loops&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="https://yikayiyo.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>异步网络编程</title>
    <link href="https://yikayiyo.github.io/2018/11/25/python%E5%BC%82%E6%AD%A5/"/>
    <id>https://yikayiyo.github.io/2018/11/25/python%E5%BC%82%E6%AD%A5/</id>
    <published>2018-11-25T08:14:00.000Z</published>
    <updated>2019-05-18T09:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关键词" class="heading-control"><a href="#关键词" class="headerlink" title="关键词"></a>关键词<a class="heading-anchor" href="#关键词" aria-hidden="true"></a></h3><p>协程、生成器</p><h3 id="笔记" class="heading-control"><a href="#笔记" class="headerlink" title="笔记"></a>笔记<a class="heading-anchor" href="#笔记" aria-hidden="true"></a></h3><ul><li><p>协程：又称作Coroutine。从字面上来理解，即协同运行的例程，它是比是线程（thread）更细量级的用户态线程，特点是允许用户的主动调用和主动退出，挂起当前的例程然后返回值或去执行其他任务，接着返回到原来停下的点继续执行</p></li><li><p>有时间再写。。。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关键词&quot; class=&quot;heading-control&quot;&gt;&lt;a href=&quot;#关键词&quot; class=&quot;headerlink&quot; title=&quot;关键词&quot;&gt;&lt;/a&gt;关键词&lt;a class=&quot;heading-anchor&quot; href=&quot;#关键词&quot; aria-hidden=
      
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="https://yikayiyo.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>word2vec + manage experiments</title>
    <link href="https://yikayiyo.github.io/2018/04/05/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    <id>https://yikayiyo.github.io/2018/04/05/%E8%AF%8D%E5%90%91%E9%87%8F/</id>
    <published>2018-04-05T14:30:10.000Z</published>
    <updated>2018-07-25T06:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键词：model base, variable sharing, model sharing</p><h4 id="word2vec" class="heading-control"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec<a class="heading-anchor" href="#word2vec" aria-hidden="true"></a></h4><ul><li>文本的分布式表示是许多自然语言处理任务的基础</li><li>word2vec是用来生成词语分布式表示的一组模型</li><li>主要有两种模型：skip-gram和CBOW</li><li>算法角度：CBOW模型从上下文词预测目标词，skip-gram模型从目标词预测上下文词<a id="more"></a></li><li>统计角度：CBOW模型将an entire context as one observation，这样做smoothes over了许多分布信息，适合小一些的数据集上；skip-gram模型则是将<strong>each</strong> context-target pair as a new observation，在larger datasets上表现更好</li><li>训练词向量：定义一个单层网络，任务是给定中心词预测词典中的词作为上下文词的概率，我们最后要的是隐含层的权重参数</li><li>使用 softmax 来获得可能的目标词的分布，分母要对字典中的所有词取指数再求和，计算是瓶颈</li><li>规避瓶颈的方法：层次化的softmax 和基于采样的 softmax </li><li>文章<strong>Distributed Representations of Words and Phrases and their Compositionality </strong>指出，训练skip-gram模型时，与更复杂的分层softmax相比，负采样可以加快训练速度，为频繁词汇提供更好的向量表示</li><li>负采样实际上是一种称为噪声对比估计（NCE）的简化模型，基于假设，如噪声样本的数量k和噪声样本的分布Q满足kQ(w) = 1，来简化计算；理论上不能保证其导数和softmax梯度一致</li><li>NCE则随着noise样本增多，提供了这种保证</li><li>负采样和NCE只在训练时有用</li></ul><h4 id="Implementing" class="heading-control"><a href="#Implementing" class="headerlink" title="Implementing"></a>Implementing<a class="heading-anchor" href="#Implementing" aria-hidden="true"></a></h4><ul><li>词的indices作为输入（一个scalar），</li><li>BATCH_SIZE的样本，输入维度为[BATCH_SIZE]，输出维度为[BATCH_SIZE,1]</li><li>词向量矩阵维度为[VOCAB_SIZE,EMBED_SIZE]，每一行代表一个词向量</li><li>利用tf.nn.embedding_lookup()找中心词对应的向量，免去了不必要的计算（matrix and onehot vector）</li><li>loss使用tf.nn.nce_loss()，optimizer使用GradientDescentOptimizer</li></ul><h4 id="Structure-TF-models" class="heading-control"><a href="#Structure-TF-models" class="headerlink" title="Structure TF models"></a>Structure TF models<a class="heading-anchor" href="#Structure-TF-models" aria-hidden="true"></a></h4><p>定义图</p><ul><li>导入数据（placeholder or tf.data）</li><li>定义权重</li><li>定义模型</li><li>定义损失函数</li><li>定义优化器</li></ul><p>执行图</p><ul><li>初始化所有变量</li><li>初始化迭代器或者feed in训练数据</li><li>数据经过模型得到结果</li><li>计算cost</li><li>调整模型参数使得cost最小或者最大</li></ul><p>build model as a class in order to reuse easily.</p><h4 id="Variable-sharing" class="heading-control"><a href="#Variable-sharing" class="headerlink" title="Variable sharing"></a>Variable sharing<a class="heading-anchor" href="#Variable-sharing" aria-hidden="true"></a></h4><p>Name scope</p><p>将相关的ops放在一个name_scope下，这样得到的图在TensorBoard上是一块一块的，更加整洁。<br>TensorBoard图中三种边：</p><ol><li>灰实边：数据流</li><li>橙实边：参考边，op_lest影响op_right</li><li>灰虚边：控制依赖边，op_left依赖于op_right</li></ol><p>Variable scope</p><p>和Name scope一样都创建了namespace，调用tf.variable_scope(“name”)会隐式地调用tf.name_scope(“name”)，Variable scope主要功能是促进变量共享（facilitate variable sharing)<br>为实现变量共享:</p><ol><li>使用 <strong>tf.get_variable()</strong>,它会在创建变量之前检查其是否存在</li><li>将所用到的变量放到一个VarScope，将这个VarScope设置为可复用的（reusable）</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fully_connected</span><span class="params">(x,output_dim,scope_name)</span>:</span> <span class="comment">#基础组件：全连接层</span></div><div class="line">    <span class="keyword">with</span> tf.variable_scope(scope_name):</div><div class="line">        w = tf.get_variable(<span class="string">"weights"</span>,[x.shape[<span class="number">1</span>],output_dim],initializer=tf.random_normal_initializer())</div><div class="line">        b = tf.get_variable(<span class="string">"bias"</span>,[output_dim],initializer= tf.constant_initializer(<span class="number">0.0</span>))</div><div class="line">        <span class="keyword">return</span> tf.matmul(x,w) + b</div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_hidden_layer</span><span class="params">(x)</span>:</span>  <span class="comment">#网络结构：两个全连接层</span></div><div class="line">    h1 = fully_connected(x,<span class="number">50</span>,<span class="string">'h1'</span>)</div><div class="line">    h2 = fully_connected(h1,<span class="number">10</span>,<span class="string">'h2'</span>)</div><div class="line">    </div><div class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">'two_layers'</span>) <span class="keyword">as</span> scope: <span class="comment">#调用网络，输入x1，x2</span></div><div class="line">    logits1 = two_hidden_layer(x1)</div><div class="line">    scope.reuse_variables()</div><div class="line">    logits2 = two_hidden_layer(x2）</div></pre></td></tr></tbody></table></figure><p>以上代码模式，基础组件可以定义更多，比如conv，relu，网络结构可以更复杂，比如放一个ResNet，非常容易scale。<br>由于使用了变量共享，多次传入x，网络TensorBoard图的复杂程度不会爆炸式增加。</p><p>Graph collections</p><p>使用这个，可以获取满足一定条件的所有变量，tf.get_collection(key,scope=None)<br>比如执行optimizer的时候，默认情况下它会获取key=tf.GraphKeys.TRAINABLE_VARIABLES的变量，即所有可训练的变量（当然也可以传入指定的、要训练的变量<br>获取某个scope下的所有变量，tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES,scope=’scope_name’)<br>key还有许多其它的值，见官网。</p><h4 id="Manage-experiments" class="heading-control"><a href="#Manage-experiments" class="headerlink" title="Manage experiments"></a>Manage experiments<a class="heading-anchor" href="#Manage-experiments" aria-hidden="true"></a></h4><p>实验总是很久，中断随时发生，因此训练可以随时随地停止、像没事一样恢复，非常重要。<br>另外一个问题是论文结果复现，控制实验的随机因子对复现结果非常关键。</p><p>tf.train.Saver()</p><p><strong>周期性地保存模型参数</strong>是个好习惯<br>tf.train.Saver()类将图的<strong>变量保存</strong>（不是整张图）到二进制文件，也就是一个checkpoint（变量名到tensors的映射）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#定义模型</span></div><div class="line">...</div><div class="line">global_steps = tf.Variable(<span class="number">0</span>, trainable=<span class="keyword">False</span>，name=<span class="string">'global_steps'</span>)</div><div class="line">optimizer = tf.train.GradientDescentOptimizer(lr).minimize(loss,global_step=global_steps)</div><div class="line"><span class="comment">#创建一个saver对象</span></div><div class="line">saver = tf.train.Saver()</div><div class="line"></div><div class="line"><span class="comment">#启动一个会话来执行计算</span></div><div class="line"><span class="keyword">with</span> tf.session() <span class="keyword">as</span> sess:</div><div class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">1</span>,training_steps):</div><div class="line">        sess.run([optimizer]) <span class="comment">#global_step会在每一步训练后自加1</span></div><div class="line">        <span class="keyword">if</span> step%<span class="number">1000</span>==<span class="number">0</span>:</div><div class="line">            <span class="comment">#这里传入step也差不多吧...默认保存图中所有变量</span></div><div class="line">            saver.save(sess,<span class="string">'checkpoints/model-name'</span>,global_step=global_steps)</div></pre></td></tr></tbody></table></figure><p>生成的checkpoint名，像这样，’checkpoints/skip-gram-10000’<br>在恢复模型时可以直接传入checkpoint名（如果有的话</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ckpt = tf.train.get_checkpoint_state(os.path.dirname(<span class="string">'checkpoints/model-name'</span>))</div><div class="line"><span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</div><div class="line">    saver.restore(sess,ckpt.model_checkpoint_path) <span class="comment">#恢复的是最近的一个check point</span></div></pre></td></tr></tbody></table></figure><p>恢复的时候，网络图还得自己重新搭（still have to create the graph ourselves）之后再加载变量<br>当然，经常的做法是到目前为止表现最好的参数也保存下来（不止是最近的一次）</p><p>tf.summary</p><p>记录模型训练过程中指标变化，包括loss，accuracy等等</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#创建summaries</span></div><div class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"summaries"</span>):</div><div class="line">    tf.summary.scalar(<span class="string">"loss"</span>,loss)</div><div class="line">    tf.summary.histogram(<span class="string">"histogram loss"</span>,loss)</div><div class="line">    tf.summary.scalar(<span class="string">"accuracy"</span>,accuracy)</div><div class="line">    summary_op = tf.summary.merge_all()</div><div class="line"></div><div class="line"><span class="comment">#执行summary op</span></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(steps):</div><div class="line">        _loss,_,summary = sess.run([model.loss,model.optimizer,model.summary_op],feed_dict={...})</div><div class="line">        writer = tf.summary.FileWriter(<span class="string">'path'</span>+str(lr),sess.graph) <span class="comment">#将lr写入路径，方便tensorboard对比</span></div><div class="line">        writer.add(summary,global_step=step) <span class="comment">#记录每一个step的summary</span></div><div class="line">    writer.close()</div></pre></td></tr></tbody></table></figure><p>control randomization</p><p>为了使得别人在实验时结果会与你一致</p><ol><li><p>op级别<br>所有的tensor初始化时都传入seed参数<br>session记录了随机状态，每一个新的session都会重新start the random state</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">c = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>,seed=<span class="number">2</span>)</div><div class="line">d = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>,seed=<span class="number">2</span>)</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    print(sess.run(c)) <span class="comment">#value: a</span></div><div class="line">    print(sess.run(d)) <span class="comment">#same value: a</span></div><div class="line">    print(sess.run(c)) <span class="comment">#value: b</span></div></pre></td></tr></tbody></table></figure></li><li><p>graph级别<br>比如demo1.py和demo2.py代码相同，设置了tf.set_random_seed(seed)的话执行结果是相同的</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tf.set_random_seed(<span class="number">2</span>)</div><div class="line">c = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>)</div><div class="line">d = tf.random_uniform([],<span class="number">-10</span>,<span class="number">10</span>)</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    print(sess.run(c)) <span class="comment"># 都是a</span></div><div class="line">    print(sess.run(d)) <span class="comment"># 都是b</span></div></pre></td></tr></tbody></table></figure></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键词：model base, variable sharing, model sharing&lt;/p&gt;
&lt;h4 id=&quot;word2vec&quot;&gt;&lt;a href=&quot;#word2vec&quot; class=&quot;headerlink&quot; title=&quot;word2vec&quot;&gt;&lt;/a&gt;word2vec&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;文本的分布式表示是许多自然语言处理任务的基础&lt;/li&gt;
&lt;li&gt;word2vec是用来生成词语分布式表示的一组模型&lt;/li&gt;
&lt;li&gt;主要有两种模型：skip-gram和CBOW&lt;/li&gt;
&lt;li&gt;算法角度：CBOW模型从上下文词预测目标词，skip-gram模型从目标词预测上下文词&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="machine learning" scheme="https://yikayiyo.github.io/tags/machine-learning/"/>
    
      <category term="TensorFlow" scheme="https://yikayiyo.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>linear and logistic regression in TensorFlow</title>
    <link href="https://yikayiyo.github.io/2018/03/29/TensorFlow02/"/>
    <id>https://yikayiyo.github.io/2018/03/29/TensorFlow02/</id>
    <published>2018-03-29T03:37:22.000Z</published>
    <updated>2018-05-31T08:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linear-Regression" class="heading-control"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression<a class="heading-anchor" href="#Linear-Regression" aria-hidden="true"></a></h3><h4 id="问题定义：" class="heading-control"><a href="#问题定义：" class="headerlink" title="问题定义："></a>问题定义：<a class="heading-anchor" href="#问题定义：" aria-hidden="true"></a></h4><p>设X为生育率，Y为预期寿命，能否找到一个线性函数f使得Y = f(X)？</p><img src="/2018/03/29/TensorFlow02/f1.png" alt="f1.png" title=""><a id="more"></a><p>数据集描述：</p><p>名称: Birth rate - life expectancy in 2010<br>X = 生育率. Type: float.<br>Y = 预期寿命. Type: foat.<br>数据量: 190<br>数据形式: (X,Y)</p><h4 id="方法1：" class="heading-control"><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：<a class="heading-anchor" href="#方法1：" aria-hidden="true"></a></h4><p><strong>假设</strong>X和Y之间的关系是线性的，这意味着有w和b，满足：Y_pred = wX + b.<br>本例中w，b都是scalar，</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">w = tf.get_variable(<span class="string">'weights'</span>,initializer=tf.constant(<span class="number">0.0</span>))</div><div class="line">b = tf.get_variable(<span class="string">'bias'</span>,initializer=tf.constant(<span class="number">0.0</span>))</div></pre></td></tr></tbody></table></figure><p>损失函数使用均方误差</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Y_pred = w*X+b</div><div class="line">loss = tf.square(Y-Y_pred,name=<span class="string">'loss'</span>)</div></pre></td></tr></tbody></table></figure><p>完整代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> utils</div><div class="line"></div><div class="line">DATA_FILE = <span class="string">"data/birth_life_2010.txt"</span></div><div class="line"></div><div class="line"><span class="comment"># Step 1: 加载数据，形式为（190，2）的numpy数组，每一行代表一个点</span></div><div class="line">data, n_samples = utils.read_birth_life_data(DATA_FILE)</div><div class="line"></div><div class="line"><span class="comment"># Step 2: 创建placeholders</span></div><div class="line">X = tf.placeholder(tf.float32, name=<span class="string">'X'</span>)</div><div class="line">Y = tf.placeholder(tf.float32, name=<span class="string">'Y'</span>)</div><div class="line"></div><div class="line"><span class="comment"># Step 3: 创建变量，初始化为0</span></div><div class="line">w = tf.get_variable(<span class="string">'weights'</span>, initializer=tf.constant(<span class="number">0.0</span>))</div><div class="line">b = tf.get_variable(<span class="string">'bias'</span>, initializer=tf.constant(<span class="number">0.0</span>))</div><div class="line"></div><div class="line"><span class="comment"># Step 4: 模型</span></div><div class="line">Y_predicted = w * X + b </div><div class="line"></div><div class="line"><span class="comment"># Step 5: 损失函数</span></div><div class="line">loss = tf.square(Y - Y_predicted, name=<span class="string">'loss'</span>)</div><div class="line"></div><div class="line"><span class="comment"># Step 6: GD最小化loss</span></div><div class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=<span class="number">0.001</span>).minimize(loss)</div><div class="line"> </div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line"><span class="comment"># Step 7: 变量初始化</span></div><div class="line">sess.run(tf.global_variables_initializer()) </div><div class="line"></div><div class="line"><span class="comment"># Step 8: 训练100回</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): <span class="comment"># run 100 epochs</span></div><div class="line"><span class="comment"># 每次传入一个数据点，事实上，使用batches of data更好一点。</span></div><div class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> data:</div><div class="line"><span class="comment"># Session runs train_op to minimize loss</span></div><div class="line">sess.run(optimizer, feed_dict={X: x, Y:y}) </div><div class="line"></div><div class="line"><span class="comment"># Step 9: output the values of w and b</span></div><div class="line">w_out, b_out = sess.run([w, b])</div></pre></td></tr></tbody></table></figure><p>结论：<br>经过100次训练后，平均损失为30.04，w = -6.07，b = 84.93。<br>这证实了我们的假设，即出生率与一个国家人口的预期寿命之间存在负相关关系。 但是，这并不意味着多一个孩子会减少6年的寿命。</p><h4 id="方法2：" class="heading-control"><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：<a class="heading-anchor" href="#方法2：" aria-hidden="true"></a></h4><p>假设X和Y满足：Y_pred = wX^2 + uX + b</p><p>只需修改部分代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Step 3: 创建变量，初始化为0</span></div><div class="line">w = tf.get_variable(<span class="string">'weights_1'</span>, initializer=tf.constant(<span class="number">0.0</span>))</div><div class="line">u = tf.get_variable(<span class="string">'weights_2'</span>, initializer=tf.constant(<span class="number">0.0</span>))</div><div class="line">b = tf.get_variable(<span class="string">'bias'</span>, initializer=tf.constant(<span class="number">0.0</span>))</div><div class="line"></div><div class="line"><span class="comment"># Step 4: 模型</span></div><div class="line">Y_predicted = w * X * X + X * u + b</div></pre></td></tr></tbody></table></figure><p>由于平方损失会给离群点太多的权重，这里损失函数考虑使用Huber loss：</p><img src="/2018/03/29/TensorFlow02/f2.png" alt="f2.png" title=""><p>tensorflow提供了一些控制流操作：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 具体实现</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">huber_loss</span><span class="params">(labels, predictions, delta=<span class="number">14.0</span>)</span>:</span></div><div class="line">    residual = tf.abs(labels - predictions)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">0.5</span> * tf.square(residual)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span> <span class="keyword">return</span> delta * residual - <span class="number">0.5</span> * tf.square(delta)</div><div class="line">    <span class="keyword">return</span> tf.cond(residual &lt; delta, f1, f2)</div></pre></td></tr></tbody></table></figure><p>最后结果为：<strong>w: -5.883589, b: 85.124306.</strong></p><h4 id="which-one-is-better？" class="heading-control"><a href="#which-one-is-better？" class="headerlink" title="which one is better？"></a>which one is better？<a class="heading-anchor" href="#which-one-is-better？" aria-hidden="true"></a></h4><p>we do need test data set！！！</p><h3 id="tf-data" class="heading-control"><a href="#tf-data" class="headerlink" title="tf.data"></a>tf.data<a class="heading-anchor" href="#tf-data" aria-hidden="true"></a></h3><p>使用placeholder和feed_dicts的好处是将数据处理与TensorFlow分离，使用python就可以轻松地shuffle, batch, generate arbitrary data. 不好的地方是，数据处理的线程很有可能是瓶颈，使整个程序slow down。</p><p>使用队列也是TF中处理数据的一个选项，队列允许pipelining、threading操作，减少了数据加载到placeholders的时间，但是难以使用且容易崩溃。</p><p>tf.data比placeholder更快，比队列更容易使用，而且不会crash。</p><p>数据存储在一个tf.data.Dataset对象中，而不是一个non-TensorFLow对象（numpy array）</p><h4 id="tf-data基操：" class="heading-control"><a href="#tf-data基操：" class="headerlink" title="tf.data基操："></a>tf.data基操：<a class="heading-anchor" href="#tf-data基操：" aria-hidden="true"></a></h4><ol><li><p>创建DataSet</p><ol><li><p>从tensor创建</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># features,labels都是tensors，也可以是numpy arrays</span></div><div class="line">tf.data.DataSet.from_tensor_slice((features,labels))</div></pre></td></tr></tbody></table></figure></li><li><p>从file创建</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 文件每一行代表一个数据，例如csv文件</span></div><div class="line">tf.data.TextLineDataset(filenames)</div><div class="line"><span class="comment"># 每一个文件长度都固定，比如都是28*28的图片</span></div><div class="line">tf.data.FixedLengthRecordDataset([file1,file2,file3,file4,...])</div><div class="line"><span class="comment"># tfrecord格式，（还没用过</span></div><div class="line">tf.data.TFRecordDataset(filenames)</div></pre></td></tr></tbody></table></figure></li></ol></li><li><p>创建Iterator</p><p>取dataset中的数据需要用到迭代器</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 只能遍历一遍</span></div><div class="line">iterator = dataset.make_one_shot_iterator()</div><div class="line"><span class="comment"># 多次初始化，多次遍历</span></div><div class="line">iterator = dataset.make_initializable_iterator()</div><div class="line"><span class="comment"># 返回一个或者一组样本</span></div><div class="line">iterator.get_next()</div></pre></td></tr></tbody></table></figure></li><li><p>训练</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">iterator = dataset.make_initializable_iterator()</div><div class="line">...</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): </div><div class="line">        <span class="comment"># 每一个epoch都要初始化iterator</span></div><div class="line">        sess.run(iterator.initializer) </div><div class="line">        total_loss = <span class="number">0</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">                sess.run([optimizer]) </div><div class="line">        <span class="keyword">except</span> tf.errors.OutOfRangeError:</div><div class="line">            <span class="keyword">pass</span></div></pre></td></tr></tbody></table></figure></li></ol><h4 id="其它操作" class="heading-control"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作<a class="heading-anchor" href="#其它操作" aria-hidden="true"></a></h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#简单的命令操作dataset</span></div><div class="line">dataset = dataset.shuffle(<span class="number">1000</span>)</div><div class="line">dataset = dataset.repeat(<span class="number">100</span>)</div><div class="line">dataset = dataset.batch(<span class="number">128</span>)</div><div class="line">dataset = dataset.map(<span class="keyword">lambda</span> x: tf.one_hot(x, <span class="number">10</span>)) </div><div class="line"><span class="comment"># convert each element of dataset to one_hot vector</span></div></pre></td></tr></tbody></table></figure><h3 id="Logistic-Regression-with-MINIST" class="heading-control"><a href="#Logistic-Regression-with-MINIST" class="headerlink" title="Logistic Regression with MINIST"></a>Logistic Regression with MINIST<a class="heading-anchor" href="#Logistic-Regression-with-MINIST" aria-hidden="true"></a></h3><h4 id="一个问题：" class="heading-control"><a href="#一个问题：" class="headerlink" title="一个问题："></a>一个问题：<a class="heading-anchor" href="#一个问题：" aria-hidden="true"></a></h4><p>这个实验有多个数据集，训练集、验证集和测试集，如果每个数据集都有各自的iterator，那我们就得为每一个iterator创建一个graph。</p><p> 不，可以用一个迭代器，用不同的数据初始化它</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iterator = tf.data.Iterator.from_structure(train_data.output_types,</div><div class="line">                                           train_data.output_shapes)</div><div class="line"><span class="comment"># 每一个epoch的训练前，都要sess.run(train_init)</span></div><div class="line">train_init = iterator.make_initializer(train_data)</div><div class="line">test_init = iterator.make_initializer(test_data)</div></pre></td></tr></tbody></table></figure><p><a href="https://github.com/yikayiyo/stanford-tensorflow-tutorials/blob/master/examples/03_logreg.py" target="_blank" rel="external">完整代码</a>, tensorboard图示如下：</p><img src="/2018/03/29/TensorFlow02/f3.png" alt="f3.png" title=""><p>下一步，尝试将这个graph改造得有条理一些。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linear-Regression&quot;&gt;&lt;a href=&quot;#Linear-Regression&quot; class=&quot;headerlink&quot; title=&quot;Linear Regression&quot;&gt;&lt;/a&gt;Linear Regression&lt;/h3&gt;&lt;h4 id=&quot;问题定义：&quot;&gt;&lt;a href=&quot;#问题定义：&quot; class=&quot;headerlink&quot; title=&quot;问题定义：&quot;&gt;&lt;/a&gt;问题定义：&lt;/h4&gt;&lt;p&gt;设X为生育率，Y为预期寿命，能否找到一个线性函数f使得Y = f(X)？&lt;/p&gt;
&lt;img src=&quot;/2018/03/29/TensorFlow02/f1.png&quot; alt=&quot;f1.png&quot; title=&quot;&quot;&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="machine learning" scheme="https://yikayiyo.github.io/tags/machine-learning/"/>
    
      <category term="TensorFlow" scheme="https://yikayiyo.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow Ops</title>
    <link href="https://yikayiyo.github.io/2018/03/28/TensorFlow01/"/>
    <id>https://yikayiyo.github.io/2018/03/28/TensorFlow01/</id>
    <published>2018-03-28T01:37:22.000Z</published>
    <updated>2018-05-29T15:46:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一般流程：" class="heading-control"><a href="#一般流程：" class="headerlink" title="一般流程："></a>一般流程：<a class="heading-anchor" href="#一般流程：" aria-hidden="true"></a></h4><h4 id="TFboy基操：" class="heading-control"><a href="#TFboy基操：" class="headerlink" title="TFboy基操："></a>TFboy基操：<a class="heading-anchor" href="#TFboy基操：" aria-hidden="true"></a></h4><ul><li>定义图<a id="more"></a></li><li>创建writer，两种方式<ul><li>tf.get_default_graph()</li><li>sess.graph</li></ul></li><li>创建session执行图</li><li>关闭writer</li><li>TensorBoard可视化</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line">a = tf.constant(<span class="number">2</span>, name=<span class="string">'a'</span>)</div><div class="line">b = tf.constant(<span class="number">3</span>, name=<span class="string">'b'</span>)</div><div class="line">x = tf.add(a, b, name=<span class="string">'add'</span>)</div><div class="line"><span class="comment"># 第一种</span></div><div class="line">writer = tf.summary.FileWriter(<span class="string">'./graphs/low'</span>, tf.get_default_graph()) </div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="comment"># 第二种</span></div><div class="line">    <span class="comment"># writer = tf.summary.FileWriter('./graphs', sess.graph) </span></div><div class="line">    print(sess.run(x))</div><div class="line">writer.close() <span class="comment"># close the writer when you’re done using it</span></div></pre></td></tr></tbody></table></figure><p>writer会将图（包含的各种ops）以日志文件的形式写入指定目录，tensorboard可以将这些文件可视化出来</p><p>上面的程序每跑一次就会产生一个日志文件，不用的日志及时删除</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ tensorboard --logdir='./graphs/low' --port=6006</div><div class="line">#注意路径不要搞错</div></pre></td></tr></tbody></table></figure><img src="/2018/03/28/TensorFlow01/ex1.png" alt="ex1.png" title=""><h4 id="没记住的" class="heading-control"><a href="#没记住的" class="headerlink" title="没记住的"></a>没记住的<a class="heading-anchor" href="#没记住的" aria-hidden="true"></a></h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">tf.fill([2,3],8) ===&gt; [[8,8,8],[8,8,8]]</div><div class="line">tf.lin_space(10.0,13.0,4,name=None) ===&gt;[10.0 11.0 12.0 13.0]</div><div class="line">#各种分布</div><div class="line">tf.random_normal</div><div class="line">...</div><div class="line">#add multiple tensors</div><div class="line">tf.add_n([a,b,b]) ====&gt; a+b+b</div></pre></td></tr></tbody></table></figure><h4 id="变量" class="heading-control"><a href="#变量" class="headerlink" title="变量"></a>变量<a class="heading-anchor" href="#变量" aria-hidden="true"></a></h4><h5 id="变量定义" class="heading-control"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义<a class="heading-anchor" href="#变量定义" aria-hidden="true"></a></h5><p>训练中需要更新的参数定义为变量</p><p>常量存储在图中，变量则可能在parameter server上</p><p>常量占了很多存储时，加载图会很慢</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># old way</span></div><div class="line">tf.Variable(&lt;initial-value&gt;,name=&lt;optional-name&gt;)</div><div class="line"><span class="comment"># now</span></div><div class="line">tf.get_variable(...)</div><div class="line"><span class="comment"># 当initializer时tf.constant时，不需要参数shape</span></div><div class="line">s = tf.get_variable(<span class="string">"scalar"</span>, initializer=tf.constant(<span class="number">2</span>)) </div><div class="line">m = tf.get_variable(<span class="string">"matrix"</span>, initializer=tf.constant([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]]))</div><div class="line">W = tf.get_variable(<span class="string">"big_matrix"</span>, shape=(<span class="number">784</span>, <span class="number">10</span>), initializer=tf.zeros_initializer())</div></pre></td></tr></tbody></table></figure><h5 id="变量初始化" class="heading-control"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化<a class="heading-anchor" href="#变量初始化" aria-hidden="true"></a></h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#一次性初始化所有变量</span></div><div class="line">sess.run(tf.global_variables_initializer())</div><div class="line"><span class="comment">#初始化部分变量</span></div><div class="line">sess.run(tf.variables_initializer([a, b]))</div><div class="line"><span class="comment">#单独初始化</span></div><div class="line">sess.run(W.initializer)</div><div class="line"><span class="comment">#从文件加载</span></div><div class="line">Todo...</div></pre></td></tr></tbody></table></figure><h5 id="变量的值" class="heading-control"><a href="#变量的值" class="headerlink" title="变量的值"></a>变量的值<a class="heading-anchor" href="#变量的值" aria-hidden="true"></a></h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 两种方式</span></div><div class="line">print(sess.run(W))</div><div class="line">print(W.eval())</div></pre></td></tr></tbody></table></figure><h5 id="变量赋值" class="heading-control"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值<a class="heading-anchor" href="#变量赋值" aria-hidden="true"></a></h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 赋值会完成初始化的工作</span></div><div class="line">W.assign(<span class="number">100</span>)</div><div class="line"><span class="comment"># 自增自减不会初始化变量</span></div><div class="line">W.assign_add(<span class="number">10</span>)</div><div class="line">W.assing_sub(<span class="number">2</span>)</div><div class="line"><span class="comment"># 变量依赖,使用initialized_value()保证用W的值来初始化V</span></div><div class="line">V = tf.Variable(W.initialized_value()*<span class="number">2</span>)</div></pre></td></tr></tbody></table></figure><h4 id="控制依赖" class="heading-control"><a href="#控制依赖" class="headerlink" title="控制依赖"></a>控制依赖<a class="heading-anchor" href="#控制依赖" aria-hidden="true"></a></h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># g has 5 ops: a,b,c,d,e</span></div><div class="line"><span class="comment"># 还没用到过</span></div><div class="line"><span class="keyword">with</span> g.control_dependencies([a,b,c]):</div><div class="line">    <span class="comment"># d,e only run after a,b,c have executed</span></div><div class="line">    d = ...</div><div class="line">    e = ...</div></pre></td></tr></tbody></table></figure><h4 id="数据导入" class="heading-control"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入<a class="heading-anchor" href="#数据导入" aria-hidden="true"></a></h4><ol><li><p>old way：placeholders and feed_dict</p><p>例如，对于f(x,y) = 2x + y，x y 就是真实值的占位符</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#shape=None 意味着接收任意shape的张量</span></div><div class="line">tf.placeholder(dtype,shape=<span class="keyword">None</span>,name=<span class="keyword">None</span>)</div><div class="line"><span class="comment">#any tensors that are feedable can be fed</span></div><div class="line">tf.Graph.is_feedable(tensor)</div><div class="line"><span class="comment">#feed_dict可以用来测试模型，</span></div><div class="line"><span class="comment">#直接传入某些值免去了大量的计算</span></div><div class="line">a = tf.add(<span class="number">2</span>, <span class="number">5</span>)</div><div class="line">b = tf.multiply(a, <span class="number">3</span>)</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    print(sess.run(b))                                 <span class="comment"># &gt;&gt; 21</span></div><div class="line">    <span class="comment"># compute the value of b given the value of a is 15</span></div><div class="line">    print(sess.run(b, feed_dict={a: <span class="number">15</span>}))              <span class="comment"># &gt;&gt; 45</span></div></pre></td></tr></tbody></table></figure></li><li><p>new way: tf.data</p><p>[ ] todo…</p></li></ol><h4 id="lazy-loading" class="heading-control"><a href="#lazy-loading" class="headerlink" title="lazy loading"></a>lazy loading<a class="heading-anchor" href="#lazy-loading" aria-hidden="true"></a></h4><p>需要计算op的时候才创建</p><p>因为训练绝大数情况都要计算多次，所以lazy loading会产生大量的冗余节点</p><p>解决办法：</p><ol><li>尽可能的将ops的定义和计算分开（不要在计算的时候创建op</li><li>当你将相关ops组合在一起（比如，1中的步骤在一个类里面）可以使用python的@property机制确保某些功能只执行一次（!!!有待研究）</li></ol><p>相关博客<a href="http://danijar.com/structuring-your-tensorflow-models/" target="_blank" rel="external">http://danijar.com/structuring-your-tensorflow-models/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一般流程：&quot;&gt;&lt;a href=&quot;#一般流程：&quot; class=&quot;headerlink&quot; title=&quot;一般流程：&quot;&gt;&lt;/a&gt;一般流程：&lt;/h4&gt;&lt;h4 id=&quot;TFboy基操：&quot;&gt;&lt;a href=&quot;#TFboy基操：&quot; class=&quot;headerlink&quot; title=&quot;TFboy基操：&quot;&gt;&lt;/a&gt;TFboy基操：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;定义图&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="machine learning" scheme="https://yikayiyo.github.io/tags/machine-learning/"/>
    
      <category term="TensorFlow" scheme="https://yikayiyo.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>sparql 笔记</title>
    <link href="https://yikayiyo.github.io/2018/03/26/sparql/"/>
    <id>https://yikayiyo.github.io/2018/03/26/sparql/</id>
    <published>2018-03-26T10:53:29.000Z</published>
    <updated>2018-05-29T01:00:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Jumping-Right-In" class="heading-control"><a href="#Jumping-Right-In" class="headerlink" title="Jumping Right In"></a>Jumping Right In<a class="heading-anchor" href="#Jumping-Right-In" aria-hidden="true"></a></h3><ul><li>FROM指定的数据集会被调用SPARQL处理器时指定的数据集覆盖（如果都指定了</li><li>RDF不是数据格式，而是数据模型，它可以选择存储数据文件的语法</li><li>如果我们将数据与其它数据结合起来，那么RDF三元组的主语和谓语都必须属于特定的名称空间，以防止类似名称之间的混淆，于是我们使用URI来表示它们</li><li>当使用完整的URI时，将其放在尖括号中以向处理器显示它是一个URI</li><li>在semantic web开发中，词汇表是一组使用标准格式存储的术语，供人们重复使用</li><li>发现不同来源三元组之间联系的能力是SPARQL的最佳特性之一</li><li>约定：主谓宾分别用?s,?p,?o表示</li><li>只有满足图模式中所有三元组的数据才会被返回<a id="more"></a></li></ul><h3 id="The-Semantic-Web-RDF-and-Linked-Data-and-SPARQL" class="heading-control"><a href="#The-Semantic-Web-RDF-and-Linked-Data-and-SPARQL" class="headerlink" title="The Semantic Web,RDF,and Linked Data(and SPARQL)"></a>The Semantic Web,RDF,and Linked Data(and SPARQL)<a class="heading-anchor" href="#The-Semantic-Web-RDF-and-Linked-Data-and-SPARQL" aria-hidden="true"></a></h3><ul><li>the semantic web isn’t about the query language or about the model—it’s about the data</li><li>RDF中基本的信息单元是三元组</li><li>将RDF作为一串字节保存在磁盘上的技术术语是序列化</li><li>RDFS gives people a way to describe vocabularies. It is itself a vocabulary with a schema whose triples declare facts.</li><li>Linked Data：<ul><li>Use URIs as names for things.</li><li>Use HTTP URIs so that people can look up those names.</li><li>When someone looks up a URI, provide useful information, using the standards (RDF*, SPARQL).</li><li>Include links to other URIs so that they can discover more things.</li></ul></li></ul><h3 id="SPARQL-Queries" class="heading-control"><a href="#SPARQL-Queries" class="headerlink" title="SPARQL Queries"></a>SPARQL Queries<a class="heading-anchor" href="#SPARQL-Queries" aria-hidden="true"></a></h3><p>介绍SPARQL查询语言更多更有用的特征</p><h4 id="More-Readable-Query-Results" class="heading-control"><a href="#More-Readable-Query-Results" class="headerlink" title="More Readable Query Results"></a>More Readable Query Results<a class="heading-anchor" href="#More-Readable-Query-Results" aria-hidden="true"></a></h4><ul><li><p><strong>分号</strong>表示接下来的谓语-宾语对与之前的共有一个主语</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SELECT ?first ?last</div><div class="line">WHERE</div><div class="line">{</div><div class="line">  ?person ab:firstName ?first;</div><div class="line">          ab:lastName  ?last.</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li><li><p>使用那些可读性强的属性，比如标签、描述等等（字符串，而不是URI</p></li><li><strong>rdfs:label</strong> 是第一个应该注意的属性，别的，<strong>rdfs:comment</strong>,<strong>skos:prefLabel</strong>（首选标签）,<strong>skos:altLabel</strong>（备选标签）</li><li>给定的资源并不总必须是主语、谓语或者宾语，在不同的三元组中它可以是不同的（多个）角色</li></ul><h4 id="Data-That-Might-Not-Be-There" class="heading-control"><a href="#Data-That-Might-Not-Be-There" class="headerlink" title="Data That Might Not Be There"></a>Data That Might Not Be There<a class="heading-anchor" href="#Data-That-Might-Not-Be-There" aria-hidden="true"></a></h4><ul><li>将triple pattern放入到OPTIONAL graph patterns中，表示“如果有的话，检索该值”</li><li>OPTIONAL{t1.t2.t3}包含三个三元组，这些三元组需要同时满足</li><li>OPTIONAL{t1} OPTIONAL{t2} OPTIONAL{t3}则是三个独立的条件</li><li>OPTIONAL graph patterns的顺序很重要  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 优先使用nick作为?first</div><div class="line">SELECT ?first ?last</div><div class="line">WHERE</div><div class="line">{</div><div class="line">    ?s ab:lastName ?last.</div><div class="line">    OPTIONAL {?s ab:nick ?first}</div><div class="line">    OPTIONAL {?s ab:firstName ?first}</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Finding-Data-That-Doesn’t-Meet-Certain-Conditions" class="heading-control"><a href="#Finding-Data-That-Doesn’t-Meet-Certain-Conditions" class="headerlink" title="Finding Data That Doesn’t Meet Certain Conditions"></a>Finding Data That Doesn’t Meet Certain Conditions<a class="heading-anchor" href="#Finding-Data-That-Doesn’t-Meet-Certain-Conditions" aria-hidden="true"></a></h4><ul><li><p>SPARQL1.0</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 利用FILTER和bound，?v没有绑定值时返回true，然后输出</div><div class="line">OPTIONAL {?s ?p ?v}</div><div class="line">FILTER(!bound(?v))</div></pre></td></tr></tbody></table></figure></li><li><p>SPARQL1.1</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 当指定的pattern不存在时返回ture</div><div class="line">NOT EXISTS {?s ?p ?v}</div></pre></td></tr></tbody></table></figure>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#另一种方式，减去满足pattern的资源（多数情况下表现相同</div><div class="line">MINUS {?s ?p ?v}</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Serching-Futher-In-The-Data" class="heading-control"><a href="#Serching-Futher-In-The-Data" class="headerlink" title="Serching Futher In The Data"></a>Serching Futher In The Data<a class="heading-anchor" href="#Serching-Futher-In-The-Data" aria-hidden="true"></a></h4><ul><li>RDF三元组中的对象可以是字符串或者URI，字符串值更易读，但是<strong>URI使得将该数据和其它数据链接起来更加容易</strong></li><li>如果一个数据集中资源的URI可以和另一个数据集中的URI对应起来，哪怕数据集来自不同的地方，不清楚组织形式，也可以利用SPARQL查询到更多的信息</li><li><strong>逗号</strong>表示“接下来的三元组主语谓语和前一个三元组的相同”</li><li>利用属性路径（property paths）：  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 借助正则表达式的符号+（one or more）,返回直接引用、间接引用了A的论文</div><div class="line">SELECT ?s </div><div class="line">WHERE</div><div class="line">{?s c:cites+ :paperA.}</div><div class="line"># 指定引用层数</div><div class="line">#{?s c:cites{3} :paperA.}</div><div class="line">#相同效果</div><div class="line">#{?s c:cites/c:cites/c:cites :paperA.}</div><div class="line">#^表示取相反,返回A引用的文章</div><div class="line">#{?s ^c:cites :paperA.}</div><div class="line"># ^结合property path的例子：引用了F引用的文章的文章</div><div class="line">#{</div><div class="line">#    ?s c:cites/^c:cites :paperF .</div><div class="line">#    FILTER(?s != :paperF)</div><div class="line">#}</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Searching-With-Blank-Nodes" class="heading-control"><a href="#Searching-With-Blank-Nodes" class="headerlink" title="Searching With Blank Nodes"></a>Searching With Blank Nodes<a class="heading-anchor" href="#Searching-With-Blank-Nodes" aria-hidden="true"></a></h4><ul><li>空白节点的任何名称都是临时的，通常会给一个变量名</li><li>过渡的东西，用来链接三元组</li><li>最终的select列表中一般不包含空白节点</li></ul><h4 id="Eliminating-Redundant-Output" class="heading-control"><a href="#Eliminating-Redundant-Output" class="headerlink" title="Eliminating Redundant Output"></a>Eliminating Redundant Output<a class="heading-anchor" href="#Eliminating-Redundant-Output" aria-hidden="true"></a></h4><ul><li>DISTINCT关键字</li><li>DISTINCT关键字不会增加查询结构的复杂性（就是在SELECT内容前面加个DISTINCT</li></ul><h4 id="Combining-Different-Search-Conditions" class="heading-control"><a href="#Combining-Different-Search-Conditions" class="headerlink" title="Combining Different Search Conditions"></a>Combining Different Search Conditions<a class="heading-anchor" href="#Combining-Different-Search-Conditions" aria-hidden="true"></a></h4><ul><li>UNION关键字：指定多个graph patterns，返回满足任意一个pattern的数据的组合(a combination of all the data that fits any of those patterns) </li><li>有些SPARQL处理器在其返回结果中使用声明的前缀，使得结果可读性更强</li></ul><h4 id="Filtering-Data-Based-On-Conditions" class="heading-control"><a href="#Filtering-Data-Based-On-Conditions" class="headerlink" title="Filtering Data Based On Conditions"></a>Filtering Data Based On Conditions<a class="heading-anchor" href="#Filtering-Data-Based-On-Conditions" aria-hidden="true"></a></h4><ul><li>FILTER() 只有一个参数，表达式只要返回的是布尔值就可以作为参数</li><li>RDF解析器读入输入数据时，它将这些前缀映射到适当的名称空间URIs，然后将数据交给查询处理器</li><li>!isURI(?city): 如果?city不是一个正常的URI，返回true</li><li>IN关键字：查询某个变量属于列表的三元组（前面加NOT可以表示相反的意思  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ask for data where the ?v is either A or B</div><div class="line">FILTER(?v IN (A,B))</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Retrieving-A-Specific-Number-Of-Results" class="heading-control"><a href="#Retrieving-A-Specific-Number-Of-Results" class="headerlink" title="Retrieving A Specific Number Of Results"></a>Retrieving A Specific Number Of Results<a class="heading-anchor" href="#Retrieving-A-Specific-Number-Of-Results" aria-hidden="true"></a></h4><ul><li>LIMIT关键字</li><li>放在花括号外面</li><li>OFFSET关键字:跳过几个结果</li></ul><h4 id="Querying-Named-Graphs" class="heading-control"><a href="#Querying-Named-Graphs" class="headerlink" title="Querying Named Graphs"></a>Querying Named Graphs<a class="heading-anchor" href="#Querying-Named-Graphs" aria-hidden="true"></a></h4><ul><li>命名图(named graph)：为三元组集合命名，方便管理（进行替换之类的操作</li><li><p>查询的数据集可以在查询内部用FROM指定，也可以在外部在ARQ命令行中指定，后者会覆盖前者</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * </div><div class="line"><span class="keyword">FROM</span>&lt;xx.ttl&gt;</div><div class="line"><span class="keyword">FROM</span>&lt;yy.ttl&gt;</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">{...}</div></pre></td></tr></tbody></table></figure></li><li><p>指定的查询数据集构成了默认图(default graph)，它不属于任何命名图</p></li><li><p>FROM NAMED :表示数据集不会被加入到默认图，查询时需要指定其graph name（ARQ的约定是将URI作为其name），第六章会有SPARQL1.1标准的相关内容</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ?lname ?courseName</div><div class="line"><span class="keyword">FROM</span> &lt;ex069.ttl&gt;</div><div class="line"><span class="keyword">FROM</span> NAMED &lt;ex125.ttl&gt;</div><div class="line"><span class="keyword">FROM</span> NAMED &lt;ex122.ttl&gt; # 即使这里写了，如果在查询中没有指定（GRAPH &lt;ex125.ttl&gt;），其数据不会被用来检索</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">{</div><div class="line">    { ?student ab:lastName ?lname }</div><div class="line">    <span class="keyword">UNION</span></div><div class="line">    { GRAPH &lt;ex125.ttl&gt; { ?course ab:courseTitle ?courseName } }</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li><li><p>GRAPH关键字：查询中使用这个关键字表明引用特定命名图中的数据</p></li><li><p>GRAPH后面也可以跟变量，让SPARQL处理器寻找满足某个模式的图</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#这里只设置了特定的命名图来查询，如果存在默认图，则没有任何返回结果</div><div class="line">SELECT *</div><div class="line">FROM NAMED &lt;yyy.ttl&gt;</div><div class="line">FROM NAMED &lt;xxx.ttl&gt;</div><div class="line">WHERE</div><div class="line">{GRAPH ?g(?s ?p ?o)}</div></pre></td></tr></tbody></table></figure></li><li><p>SPARQL处理器有一些预定义的命名图，当你在GRAPH中指定时不需要事先标识</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ?graph ?email </div><div class="line"><span class="keyword">FROM</span> &lt;ex134.ttl&gt; </div><div class="line"><span class="keyword">FROM</span> NAMED &lt;ex125.ttl&gt; </div><div class="line"><span class="keyword">FROM</span> NAMED &lt;ex122.ttl&gt; </div><div class="line"><span class="keyword">WHERE</span> </div><div class="line">{</div><div class="line">    ?graph dc:<span class="built_in">date</span> <span class="string">"2011-09-24"</span> . </div><div class="line">    { GRAPH ?graph { ?s ab:email ?email } }</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Queries-In-Your-Queries" class="heading-control"><a href="#Queries-In-Your-Queries" class="headerlink" title="Queries In Your Queries"></a>Queries In Your Queries<a class="heading-anchor" href="#Queries-In-Your-Queries" aria-hidden="true"></a></h4><ul><li>子查询特征：可以将复杂的查询细分，又可以将来自不同查询的结果合并</li><li>每个子查询必须放到自己的花括号中</li></ul><h4 id="Combining-Values-And-Assigning-Values-To-Variables" class="heading-control"><a href="#Combining-Values-And-Assigning-Values-To-Variables" class="headerlink" title="Combining Values And Assigning Values To Variables"></a>Combining Values And Assigning Values To Variables<a class="heading-anchor" href="#Combining-Values-And-Assigning-Values-To-Variables" aria-hidden="true"></a></h4><ul><li>sparql查询出来的值可以用于数学运算，函数调用</li><li><p>BIND关键字</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#数学运算的例子</div><div class="line">#这里利用amount创建了变量tip和total</div><div class="line">SELECT ?description </div><div class="line">?amount </div><div class="line">((?amount * .2) AS ?tip) </div><div class="line">((?amount + ?tip) AS ?total)</div><div class="line">WHERE</div><div class="line">{</div><div class="line">    ?meal e:description ?description ;</div><div class="line">          e:amount ?amount .</div><div class="line">}</div></pre></td></tr></tbody></table></figure>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#函数调用的例子</div><div class="line">SELECT </div><div class="line">(UCASE(SUBSTR(?description,1,3))as ?mealCode) </div><div class="line">?amount </div><div class="line">WHERE</div><div class="line">{</div><div class="line">    ?meal e:description ?description ;</div><div class="line">          e:amount ?amount .</div><div class="line">}</div></pre></td></tr></tbody></table></figure>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#改进,expression calculation moved to a subquery,利用BIND关键字为变量赋值</div><div class="line">SELECT ?mealCode ?amount</div><div class="line">WHERE</div><div class="line">{</div><div class="line">    ?meal e:description ?description ;</div><div class="line">          e:amount ?amount .</div><div class="line">    BIND (UCASE(SUBSTR(?description,1,3)) as ?mealCode)</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Sorting-Aggregating-Finding-The-Biggest-And-Smallest-And…" class="heading-control"><a href="#Sorting-Aggregating-Finding-The-Biggest-And-Smallest-And…" class="headerlink" title="Sorting, Aggregating, Finding The Biggest And Smallest And…"></a>Sorting, Aggregating, Finding The Biggest And Smallest And…<a class="heading-anchor" href="#Sorting-Aggregating-Finding-The-Biggest-And-Smallest-And…" aria-hidden="true"></a></h4><ul><li><p>SPARQL使用<strong>ORDER BY</strong>来排序（默认从小到大）.</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 根据amount排序</div><div class="line">SELECT ?description ?date ?amount</div><div class="line">WHERE</div><div class="line">{</div><div class="line">    ?meal e:description ?description ;</div><div class="line">    e:date ?date ;</div><div class="line">    e:amount ?amount .</div><div class="line">}</div><div class="line">ORDER BY ?amount</div></pre></td></tr></tbody></table></figure></li><li><p>从大到小排序：利用DESC()，括号里面是排序用的指标</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#根据amount从大到小排序</div><div class="line">SELECT ?description ?date ?amount </div><div class="line">WHERE</div><div class="line">{</div><div class="line">    ?meal e:description ?description ;</div><div class="line">        e:date ?date ;</div><div class="line">        e:amount ?amount .</div><div class="line">}</div><div class="line">ORDER BY DESC(?amount)</div></pre></td></tr></tbody></table></figure></li><li><p>多条件排序，各个条件空格隔开</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 先根据description排序（字母表），再根据amount从大到小排序</div><div class="line">SELECT ?description ?date ?amount </div><div class="line">WHERE</div><div class="line">{</div><div class="line">    ?meal e:description ?description ;</div><div class="line">        e:date ?date ;</div><div class="line">        e:amount ?amount .</div><div class="line">}</div><div class="line">ORDER BY ?description DESC(?amount)</div></pre></td></tr></tbody></table></figure></li><li><p>找最值</p><ul><li>sparql1.0: 先排序，然后LIMIT 1</li><li>sparql1.1: MAX(),MIN()</li></ul></li><li><p>均值：AVG()</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> (<span class="keyword">AVG</span>(?amount) <span class="keyword">as</span> ?avgAmount)</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">{</div><div class="line">    ?meal e:amount ?amount .</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li><li><p>求和SUM(),计数COUNT()</p></li><li><p>GROUP_CONCAT(): 将很多数据绑定到一个变量，默认的分隔符是空格</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 返回一个amountlist，形如“25.05,10.00,6.65,31.45”</div><div class="line">SELECT (GROUP_CONCAT(?amount;SEPARATOR = ',') AS amountlist)</div><div class="line">WHERE { ?meal e:amount ?amount.}</div></pre></td></tr></tbody></table></figure></li><li><p>GROUP BY: 根据某属性分组；代入SUM()函数可以求和，类似的，可以代入别的函数</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 统计早中晚餐总数</div><div class="line">SELECT ?description (SUM(?amount) AS ?meanTotal)</div><div class="line">WHERE</div><div class="line">{...}</div><div class="line">GROUP BY ?description</div></pre></td></tr></tbody></table></figure></li><li><p>HAVING 关键字：限定显示出来的结果需要满足的条件</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#我们只对总数超过20的感兴趣</div><div class="line">SELECT ?description (SUM(?amount) AS ?meanTotal)</div><div class="line">WHERE</div><div class="line">{...}</div><div class="line">GROUP BY ?description</div><div class="line">HAVING (SUM(?amount)&gt;20)</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Query-A-Remote-SPARQL-Service" class="heading-control"><a href="#Query-A-Remote-SPARQL-Service" class="headerlink" title="Query A Remote SPARQL Service"></a>Query A Remote SPARQL Service<a class="heading-anchor" href="#Query-A-Remote-SPARQL-Service" aria-hidden="true"></a></h4><ul><li><p>查询远程sparql服务</p><ul><li><p>FROM 关键字(RDF file)</p>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ?title</div><div class="line"><span class="keyword">FROM</span> &lt;xxx://xxx.xxx.xxxx/xxx&gt;</div><div class="line">{?s dc:title ?title}</div></pre></td></tr></tbody></table></figure></li><li><p>SERVICE 关键字(SPARQL endpoint)</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 在SPAERQL endpoint运行查询得到一些内容，再进行检索返回结果</div><div class="line">SELECT ?p ?o</div><div class="line">WHERE</div><div class="line">{</div><div class="line">    SERVICE &lt;xxx://xxx.xxx/xxx&gt;</div><div class="line">    {</div><div class="line">        SELECT ?p ?o</div><div class="line">        WHERE {xxx ?p ?o}</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>ARQ 必须指定–data参数，即便查询对数据没有任何操作（上面的查询，其实只是指定了待查询的endpoint，而不是数据</strong></p></li><li>可以借助<strong>D2RQ</strong>使用SPARQL查询关系数据库（RDB）<h4 id="Federated-Queries-Searching-Multiple-Datasets-With-One-Query" class="heading-control"><a href="#Federated-Queries-Searching-Multiple-Datasets-With-One-Query" class="headerlink" title="Federated Queries:Searching Multiple Datasets With One Query"></a>Federated Queries:Searching Multiple Datasets With One Query<a class="heading-anchor" href="#Federated-Queries-Searching-Multiple-Datasets-With-One-Query" aria-hidden="true"></a></h4></li><li>联合查询(Federated Queries):一个query查询多个数据集<ul><li>第一个子查询中绑定的变量，在之后的子查询中依旧可用</li><li>如果数据集之间关系密切，上面的特点就会很有用（用来交叉引用）</li><li>如果一个查询由两个子查询，子查询1返回a个结果，子查询2返回b个结果，那么整体查询就返回a*b个结果（cross-product）</li><li>子查询依次执行，可能会花点时间</li></ul></li></ul><h3 id="Coping-Creating-And-Converting-Data" class="heading-control"><a href="#Coping-Creating-And-Converting-Data" class="headerlink" title="Coping,Creating,And Converting Data"></a>Coping,Creating,And Converting Data<a class="heading-anchor" href="#Coping-Creating-And-Converting-Data" aria-hidden="true"></a></h3><p>除了查询出结果还能做更多的事</p><h4 id="Query-Forms-SELECT-DESCRIBE-ASK-and-CONSTRUCT" class="heading-control"><a href="#Query-Forms-SELECT-DESCRIBE-ASK-and-CONSTRUCT" class="headerlink" title="Query Forms: SELECT, DESCRIBE, ASK, and CONSTRUCT"></a>Query Forms: SELECT, DESCRIBE, ASK, and CONSTRUCT<a class="heading-anchor" href="#Query-Forms-SELECT-DESCRIBE-ASK-and-CONSTRUCT" aria-hidden="true"></a></h4><ul><li>CONSTRUCT返回三元组；可以返回原数据也可以抽取出值来创建新的三元组；可以用来复制、创建、转换</li><li>ASK询问处理器给定的图模式是否描述特定数据集中的一组三元组，返回一个布尔值；可以用来自动化数据处理流程中的质量控制；</li><li>DESCRIBE要求提供描述特定资源的三元组</li></ul><h4 id="Copying-Data" class="heading-control"><a href="#Copying-Data" class="headerlink" title="Copying Data"></a>Copying Data<a class="heading-anchor" href="#Copying-Data" aria-hidden="true"></a></h4><ul><li>利用CONSTRUCT抽取三元组；结合GRAPH关键字可以从特定命名图中抽取；SELECT后面跟的是变量列表，CONSTRUCT后面跟的是想要构造的三元组      <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#construct后面跟的是三元组，用花括号包围,里面可以包含任意个三元组模式（triple patterns）</div><div class="line">CONSTRUCT</div><div class="line">{?person ?p ?o}</div><div class="line">WHERE</div><div class="line">{...}</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Creating-New-Data" class="heading-control"><a href="#Creating-New-Data" class="headerlink" title="Creating New Data"></a>Creating New Data<a class="heading-anchor" href="#Creating-New-Data" aria-hidden="true"></a></h4><ul><li>利用一些函数处理数据，得到新的字段</li><li>指明资源所属的类会让信息推断更加容易</li><li>所谓的创建信息其实是将隐含的信息明确化</li></ul><h4 id="Converting-Data" class="heading-control"><a href="#Converting-Data" class="headerlink" title="Converting Data"></a>Converting Data<a class="heading-anchor" href="#Converting-Data" aria-hidden="true"></a></h4><ul><li>将一个命名空间中的属性转换到需要的命名空间</li><li>意味着规范化URI以便更加容易地组合数据</li><li>owl:sameAs是DBpedia中用来将不同来源的资源联系起来的方式</li></ul><h4 id="Finding-Bad-Data" class="heading-control"><a href="#Finding-Bad-Data" class="headerlink" title="Finding Bad Data"></a>Finding Bad Data<a class="heading-anchor" href="#Finding-Bad-Data" aria-hidden="true"></a></h4><ul><li>schema是一组关于数据结构和数据类型的规则</li><li>如果数据遵循了某个schema那么就不需要程序员写代码应对“给字符串加了1”这样的情形了</li><li>语义网应用采用了别的方法，通过添加更多的metadata</li><li>使用SPARQL添加限制而不是OWL</li></ul><h4 id="Defining-Rules-with-SPARQL" class="heading-control"><a href="#Defining-Rules-with-SPARQL" class="headerlink" title="Defining Rules with SPARQL"></a>Defining Rules with SPARQL<a class="heading-anchor" href="#Defining-Rules-with-SPARQL" aria-hidden="true"></a></h4><ul><li>rules expressed as queries</li><li>一些常用的：<ul><li>isURI</li><li>datatype(?amount)) != xsd:integer</li><li>!(bound(?grade))</li><li>?grade &lt; 5</li></ul></li></ul><h4 id="Generating-Data-About-Broken-Rules" class="heading-control"><a href="#Generating-Data-About-Broken-Rules" class="headerlink" title="Generating Data About Broken Rules"></a>Generating Data About Broken Rules<a class="heading-anchor" href="#Generating-Data-About-Broken-Rules" aria-hidden="true"></a></h4><ul><li>将ASK换为CONSTRUCT</li><li>问题建模：问题类型、相关属性</li><li>可以使用Union将不同的规则加合并，但是随着规则的增多，这种方式会产生越来越多的错误（ there’d be greater and greater room for error</li><li>好的处理方式是：分开存储规则，使用是时候pipeline</li></ul><h4 id="Using-Existing-SPARQL-Rules-Vocabularies" class="heading-control"><a href="#Using-Existing-SPARQL-Rules-Vocabularies" class="headerlink" title="Using Existing SPARQL Rules Vocabularies"></a>Using Existing SPARQL Rules Vocabularies<a class="heading-anchor" href="#Using-Existing-SPARQL-Rules-Vocabularies" aria-hidden="true"></a></h4><ul><li>Schemarama</li><li>SPIN</li><li>关系数据库–API–check for rule compliance using SPARQL</li></ul><h4 id="Asking-for-a-Description-of-a-Resource" class="heading-control"><a href="#Asking-for-a-Description-of-a-Resource" class="headerlink" title="Asking for a Description of a Resource"></a>Asking for a Description of a Resource<a class="heading-anchor" href="#Asking-for-a-Description-of-a-Resource" aria-hidden="true"></a></h4><ul><li>DESCRIBE+URI :返回资源的一些信息，具体返回结果和SPARQL查询引擎有关</li><li>CONSTRUCT可以完成相同的事情，with better control，因此不太推荐在serious的应用开发中使用</li></ul><h3 id="Datatypes-And-Functions" class="heading-control"><a href="#Datatypes-And-Functions" class="headerlink" title="Datatypes And Functions"></a>Datatypes And Functions<a class="heading-anchor" href="#Datatypes-And-Functions" aria-hidden="true"></a></h3><h4 id="Datatypes-and-Queries" class="heading-control"><a href="#Datatypes-and-Queries" class="headerlink" title="Datatypes and Queries"></a>Datatypes and Queries<a class="heading-anchor" href="#Datatypes-and-Queries" aria-hidden="true"></a></h4><ul><li>数据类型元数据的存储是记录语义信息的最早方式之一</li><li>标明数据类型方便理解，不标明的话会有默认设置</li><li>str()强制类型转换：FILTER (str(?o) = “two”) #返回所有值为”two”的</li></ul><h4 id="Representing-Strings" class="heading-control"><a href="#Representing-Strings" class="headerlink" title="Representing Strings"></a>Representing Strings<a class="heading-anchor" href="#Representing-Strings" aria-hidden="true"></a></h4><ul><li>单引号，双引号，三个单引号或者双引号</li><li>ARQ输出的时候:使用双引号分隔字符串；回车为/r，换行为/n，转义为/；输出的顺序doesn’t matter</li></ul><h4 id="Comparing-Values-and-Doing-Arithmetic" class="heading-control"><a href="#Comparing-Values-and-Doing-Arithmetic" class="headerlink" title="Comparing Values and Doing Arithmetic"></a>Comparing Values and Doing Arithmetic<a class="heading-anchor" href="#Comparing-Values-and-Doing-Arithmetic" aria-hidden="true"></a></h4><ul><li>当使用不同的数字类型显式键入不同的值时，仍然可以在执行算术时将它们一起使用：比如integer和decimal可以乘到一起</li></ul><h4 id="Functions" class="heading-control"><a href="#Functions" class="headerlink" title="Functions"></a>Functions<a class="heading-anchor" href="#Functions" aria-hidden="true"></a></h4><ul><li>SPARQL 1.0规范提供了一些基本函数，SPARQL 1.1提供了更广泛的选择，几乎所有都基于XPath函数</li><li>SPARQL处理器可以提供其实施者想要包含的任何扩展功能</li></ul><h4 id="Program-Logic-Functions" class="heading-control"><a href="#Program-Logic-Functions" class="headerlink" title="Program Logic Functions"></a>Program Logic Functions<a class="heading-anchor" href="#Program-Logic-Functions" aria-hidden="true"></a></h4><ul><li>IF()函数有三个参数。 如果第一个参数为true，则该函数返回第二个参数的值; 否则返回第三个</li><li>COALESCE():接受很多参数，返回the first one that doesn’t result in an error  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT ?first ?last </div><div class="line">WHERE </div><div class="line">{</div><div class="line">?s ab:lastName ?last; </div><div class="line">   ab:firstName ?firstname . </div><div class="line">OPTIONAL{ ?s ab:nick ?nickname . } </div><div class="line">BIND (COALESCE(?nickname,?firstname) AS ?first)</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Node-Type-and-Datatype-Checking-Functions" class="heading-control"><a href="#Node-Type-and-Datatype-Checking-Functions" class="headerlink" title="Node Type and Datatype Checking Functions"></a>Node Type and Datatype Checking Functions<a class="heading-anchor" href="#Node-Type-and-Datatype-Checking-Functions" aria-hidden="true"></a></h4><ul><li>函数参数可能需要是特定类型，数据字段也需要是特定类型</li><li>datatype()函数可以用来检测类型</li><li>isBlank(), isLiteral(), isNumeric(), isIRI(), and isURI()</li><li>数字，字符串和关键字true和false（全部写成小写）都是literals，只有URI和空白节点不是</li><li>datatype(params) 返回一个URI，标识params的类型,params为空白节点和URIs时返回为空</li><li>bound()告诉我们一个变量是否有一个绑定的值</li></ul><h4 id="Node-Type-Conversion-Functions" class="heading-control"><a href="#Node-Type-Conversion-Functions" class="headerlink" title="Node Type Conversion Functions"></a>Node Type Conversion Functions<a class="heading-anchor" href="#Node-Type-Conversion-Functions" aria-hidden="true"></a></h4><ul><li>URI() function lets you convert values to URIs if possible</li><li>在将值传递给URI()或IRI()函数之前，使用ENCODE_FOR_URI()函数预处理是个推荐的做法，但要注意它只接受simple literals或xsd：string</li><li>str():返回传入资源的字符串形式，传入为空白节点时不返回值</li><li>一个例子：  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CONSTRUCT {?s ?p ?testURI.} </div><div class="line">WHERE</div><div class="line">{</div><div class="line">    ?s ?p ?o . </div><div class="line">    BIND( IF(isURI(?o), ?o, URI(ENCODE_FOR_URI(str(?o))) ) AS ?testURI)</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Datatype-Conversion" class="heading-control"><a href="#Datatype-Conversion" class="headerlink" title="Datatype Conversion"></a>Datatype Conversion<a class="heading-anchor" href="#Datatype-Conversion" aria-hidden="true"></a></h4><ul><li>conversion to boolean is pickier: xsd:boolean(?o)不能转换True，可以转换true</li><li>xsd:dateTime()不能转换“2011-11-12” ，可以转换“2011-11-12T14:30:00”</li><li>STRDT()接收两个参数，一个literal值和一个类型URI，创建一个typed literal（自定义类型）  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CONSTRUCT { ?s u:amount ?newAmount . } </div><div class="line">WHERE {</div><div class="line">    ?s im:product ?prodName ;</div><div class="line">       im:amount ?amount ; </div><div class="line">       im:units ?units .</div><div class="line">       BIND (STRDT(?amount, URI(CONCAT("http://learningsparql.com/ns/units#",?units))) AS ?newAmount)</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li></ul><h4 id="Checking-Adding-and-Removing-Spoken-Language-Tags" class="heading-control"><a href="#Checking-Adding-and-Removing-Spoken-Language-Tags" class="headerlink" title="Checking, Adding, and Removing Spoken Language Tags"></a>Checking, Adding, and Removing Spoken Language Tags<a class="heading-anchor" href="#Checking-Adding-and-Removing-Spoken-Language-Tags" aria-hidden="true"></a></h4><ul><li>FILTER ( lang(?label) = “en” ) #只返回英文标签</li><li>BIND (str(?label) AS ?strippedLabel) #去掉@en，只返回文字信息</li><li>STRLANG()函数可以为属性加标签，比如：STRLANG(?USTerm,”en-US”)</li></ul><h4 id="String-Functions" class="heading-control"><a href="#String-Functions" class="headerlink" title="String Functions"></a>String Functions<a class="heading-anchor" href="#String-Functions" aria-hidden="true"></a></h4><ul><li>STRLEN(), SUBSTR(), UCASE(), and LCASE()</li><li>STRSTARTS(), STRENDS(), CONTAINS(),regex() #返回布尔值</li><li>The regex() function expects its first argument to be either an xsd:string or a simple literal with no language tag。可以str()一下</li></ul><h4 id="Numeric-Functions" class="heading-control"><a href="#Numeric-Functions" class="headerlink" title="Numeric Functions"></a>Numeric Functions<a class="heading-anchor" href="#Numeric-Functions" aria-hidden="true"></a></h4><ul><li>abs(),round(),ceil(),flloor()</li><li>rand()+CONSTRUCT :生成样本数据</li></ul><h4 id="Date-and-Time-Functions" class="heading-control"><a href="#Date-and-Time-Functions" class="headerlink" title="Date and Time Functions"></a>Date and Time Functions<a class="heading-anchor" href="#Date-and-Time-Functions" aria-hidden="true"></a></h4><ul><li>now(),timezone(),tz()</li></ul><h4 id="Hash-Functions" class="heading-control"><a href="#Hash-Functions" class="headerlink" title="Hash Functions"></a>Hash Functions<a class="heading-anchor" href="#Hash-Functions" aria-hidden="true"></a></h4><ul><li>MD5(),SHA1(),SHA224(),SHA256(),SHA384(),SHA512()</li></ul><h4 id="Extension-Functions" class="heading-control"><a href="#Extension-Functions" class="headerlink" title="Extension Functions"></a>Extension Functions<a class="heading-anchor" href="#Extension-Functions" aria-hidden="true"></a></h4><ul><li>不同的SPARQL处理器支持的拓展函数不同</li><li>less portable</li></ul><h3 id="Updating-Data-With-SPARQL" class="heading-control"><a href="#Updating-Data-With-SPARQL" class="headerlink" title="Updating Data With SPARQL"></a>Updating Data With SPARQL<a class="heading-anchor" href="#Updating-Data-With-SPARQL" aria-hidden="true"></a></h3><p>query the data with the SPARQL query language and manage it with the update language.</p><h4 id="Getting-Started-with-Fuseki" class="heading-control"><a href="#Getting-Started-with-Fuseki" class="headerlink" title="Getting Started with Fuseki"></a>Getting Started with Fuseki<a class="heading-anchor" href="#Getting-Started-with-Fuseki" aria-hidden="true"></a></h4><ul><li>下载、安装</li></ul><h4 id="Adding-Data-to-a-Dataset" class="heading-control"><a href="#Adding-Data-to-a-Dataset" class="headerlink" title="Adding Data to a Dataset"></a>Adding Data to a Dataset<a class="heading-anchor" href="#Adding-Data-to-a-Dataset" aria-hidden="true"></a></h4><ul><li><p>更新文件后缀为.ru，意思是一个插入请求，not a query</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># INSERT DATA后面跟要插入的triples</div><div class="line"># 简单快速插入数据</div><div class="line">INSERT DATA </div><div class="line">{d:i8301 ab:homeTel "(718) 440-9821" . ab:Person a rdfs:Class .}</div></pre></td></tr></tbody></table></figure><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#where后面跟triple patterns，可以引用上面的变量</div><div class="line"># 灵活创造</div><div class="line">INSERT {d:i8301 ab:homeTel "(718) 440-9821" . ab:Person a rdfs:Class .}</div><div class="line">WHERE {}</div></pre></td></tr></tbody></table></figure></li><li><p>三元组模式就是任意位置都可以被变量替换的三元组</p></li></ul><h4 id="Deleting-Data" class="heading-control"><a href="#Deleting-Data" class="headerlink" title="Deleting Data"></a>Deleting Data<a class="heading-anchor" href="#Deleting-Data" aria-hidden="true"></a></h4><ul><li>DELETE DATA{}和DELETE{}WHERE{}</li><li>DELETE WHERE{} :删除匹配where条件的三元组</li><li>CLEAR  DEFAULT</li></ul><h4 id="Changing-Existing-Data" class="heading-control"><a href="#Changing-Existing-Data" class="headerlink" title="Changing Existing Data"></a>Changing Existing Data<a class="heading-anchor" href="#Changing-Existing-Data" aria-hidden="true"></a></h4><ul><li>在一次更新操作中，删除+插入</li><li>即使删除发生在插入之前，INSERT图形模式仍然具有WHERE子句存储的所有信息</li></ul><h4 id="Named-Graphs" class="heading-control"><a href="#Named-Graphs" class="headerlink" title="Named Graphs"></a>Named Graphs<a class="heading-anchor" href="#Named-Graphs" aria-hidden="true"></a></h4><ul><li>SPARQL更新允许使用分号连接多个操作</li><li>将三元组插入不存在的图时，SPARQL处理器会创建该图</li></ul><h4 id="Dropping-Graphs" class="heading-control"><a href="#Dropping-Graphs" class="headerlink" title="Dropping Graphs"></a>Dropping Graphs<a class="heading-anchor" href="#Dropping-Graphs" aria-hidden="true"></a></h4><ul><li>DROP GRAPH d:g1 #删除图g1</li><li>DROP DEFAULT #清除默认图，（因为默认图总是存在，即使为空</li><li>DROP NAMED：删除命名图</li><li>DROP ALL ：删除所有图</li><li>SPARQL Update没有UNDO操作，因此DROP ALL是个需要慎重的动作</li><li>这里的DROP换为CLEAR表示图中的清除三元组</li><li>CREATE GRAPH：创建一个空白图</li></ul><h4 id="Named-Graph-Syntax-Shortcuts-WITH-and-USING" class="heading-control"><a href="#Named-Graph-Syntax-Shortcuts-WITH-and-USING" class="headerlink" title="Named Graph Syntax Shortcuts: WITH and USING"></a>Named Graph Syntax Shortcuts: WITH and USING<a class="heading-anchor" href="#Named-Graph-Syntax-Shortcuts-WITH-and-USING" aria-hidden="true"></a></h4><ul><li>with语句指明要操作的图，比GRAPH节省</li><li>USING的作用类似于SELECT语句的FROM</li><li><p>USING NAMED === FROM NAMED</p>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">USING NAMED d:g2 </div><div class="line">WHERE</div><div class="line">{ </div><div class="line">    # 这里一定要声明GRAPH d:g2</div><div class="line">    GRAPH d:g2 {?s dm:tag "five" . ?s dm:tag "six" .}</div><div class="line">}</div></pre></td></tr></tbody></table></figure></li><li><p>使用USING就不要使用WITH</p></li></ul><h4 id="Deleting-and-Replacing-Triples-in-Named-Graphs" class="heading-control"><a href="#Deleting-and-Replacing-Triples-in-Named-Graphs" class="headerlink" title="Deleting and Replacing Triples in Named Graphs"></a>Deleting and Replacing Triples in Named Graphs<a class="heading-anchor" href="#Deleting-and-Replacing-Triples-in-Named-Graphs" aria-hidden="true"></a></h4>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DELETE</span> <span class="keyword">DATA</span> { GRAPH d:g2{ d:x dm:tag <span class="string">"six"</span> }}</div></pre></td></tr></tbody></table></figure>  <figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># GRAPH+图名或者变量名</div><div class="line">DELETE { GRAPH ?g { ?s ?p "three" } } </div><div class="line">WHERE { GRAPH ?g { ?s ?p "three" } }</div></pre></td></tr></tbody></table></figure>  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WITH d:g1 </div><div class="line"><span class="keyword">DELETE</span> { ?s ?p <span class="string">"four"</span>}</div><div class="line"><span class="keyword">WHERE</span> { ?s ?p <span class="string">"four"</span>}</div></pre></td></tr></tbody></table></figure><h3 id="Building-Applications-With-SPARQL" class="heading-control"><a href="#Building-Applications-With-SPARQL" class="headerlink" title="Building Applications With SPARQL"></a>Building Applications With SPARQL<a class="heading-anchor" href="#Building-Applications-With-SPARQL" aria-hidden="true"></a></h3><ul><li>将查询发送到端点的最常见方式是将查询的转义版本作为参数添加到端点的URI</li><li>D2RQ</li><li>SPARQLWrapper for python</li><li>ARQ source code for java</li></ul><h3 id="Glossary" class="heading-control"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary<a class="heading-anchor" href="#Glossary" aria-hidden="true"></a></h3><ul><li><strong>blank node</strong>: A subject or object in an RDF graph that has no identity. These are typically used to group together other values</li><li><strong>default graph</strong>: The triples in an RDF dataset that don’t belong to a named graph</li><li><strong>IRI</strong>: Internationalized Resource Identifier: a URI that allows a wider choice of characters,making it “internationalized.”</li><li><strong>literal</strong>: A value, as opposed to a URI, which is a name for something. A literal may have a datatype or a spoken language tag associated with it, but not both. A simple literal is a literal with no language tag or datatype</li><li><strong>N3</strong>: A non-XML RDF serialization format developed by Tim Berners-Lee. Turtle is a simplified version of N3</li><li><strong>N-Triples</strong>: A very simple RDF serialization format that shows complete URIs with no abbreviation and a triple on each line. Often used as a graph dump format</li><li><strong>named graph</strong>: A set of triples, typically within a larger collection of them, that can be referenced with a particular name. The name is a URI</li><li><strong>RDF/XML</strong>: RDF’s original serialization format, based on XML</li><li><strong>RDFS</strong>: the RDF Schema (RDFS) specification lets you specify classes, properties, and metadata about those classes and properties. These serve as metadata to let you infer new facts about your data, not as validation rules to indicate correct versus incorrect data</li><li><strong>triplestore</strong>: A specialized database manager designed for storing triples</li><li><strong>Turtle</strong>: An increasingly popular RDF serialization format based on N3</li><li><strong>URI</strong>: “URI” is used more often to refer to an identifier, and “URL” to refer to a locator, or address.We use URIs to identify resources and property names in RDF</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Jumping-Right-In&quot;&gt;&lt;a href=&quot;#Jumping-Right-In&quot; class=&quot;headerlink&quot; title=&quot;Jumping Right In&quot;&gt;&lt;/a&gt;Jumping Right In&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;FROM指定的数据集会被调用SPARQL处理器时指定的数据集覆盖（如果都指定了&lt;/li&gt;
&lt;li&gt;RDF不是数据格式，而是数据模型，它可以选择存储数据文件的语法&lt;/li&gt;
&lt;li&gt;如果我们将数据与其它数据结合起来，那么RDF三元组的主语和谓语都必须属于特定的名称空间，以防止类似名称之间的混淆，于是我们使用URI来表示它们&lt;/li&gt;
&lt;li&gt;当使用完整的URI时，将其放在尖括号中以向处理器显示它是一个URI&lt;/li&gt;
&lt;li&gt;在semantic web开发中，词汇表是一组使用标准格式存储的术语，供人们重复使用&lt;/li&gt;
&lt;li&gt;发现不同来源三元组之间联系的能力是SPARQL的最佳特性之一&lt;/li&gt;
&lt;li&gt;约定：主谓宾分别用?s,?p,?o表示&lt;/li&gt;
&lt;li&gt;只有满足图模式中所有三元组的数据才会被返回&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱小demo</title>
    <link href="https://yikayiyo.github.io/2018/03/10/kgdemo/"/>
    <id>https://yikayiyo.github.io/2018/03/10/kgdemo/</id>
    <published>2018-03-10T02:14:20.000Z</published>
    <updated>2019-03-15T01:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验环境" class="heading-control"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境<a class="heading-anchor" href="#实验环境" aria-hidden="true"></a></h2><p>系统：<br>ubuntu16.04</p><p>软件目录:</p><ul><li>项目目录/home/gao/software/kgdemo/</li><li>数据库/home/gao/software/mysql</li><li>应用框架/home/gao/software/apache-jena-3.6.0（这里使用了它的TDB组件</li><li>SPARQL服务器/home/gao/software/apache-jena-fuseki-3.6.0</li><li>数据转化工具/home/gao/software/d2rq-0.8.1</li><li>本体构建工具/home/gao/software/Protege-5.2.0<a id="more"></a></li></ul><h2 id="准备" class="heading-control"><a href="#准备" class="headerlink" title="准备"></a>准备<a class="heading-anchor" href="#准备" aria-hidden="true"></a></h2><h3 id="数据" class="heading-control"><a href="#数据" class="headerlink" title="数据"></a>数据<a class="heading-anchor" href="#数据" aria-hidden="true"></a></h3><p>与电影相关的.基本统计数据如下：</p><ol><li>演员数量：505人</li><li>电影数量：4518部</li><li>电影类型：19类</li><li>人物与电影的关系：14451</li><li>电影与类型的关系：7898</li></ol><p>演员的基本信息包括：姓名、英文名、出生日期、死亡日期、出生地、个人简介.<br>电影的基本信息包括：电影名称、电影简介、电影评分、电影发行日期、电影类型.</p><img src="/2018/03/10/kgdemo/ErGraph.png" alt="ErGraph.png" title=""><h3 id="本体建模" class="heading-control"><a href="#本体建模" class="headerlink" title="本体建模"></a>本体建模<a class="heading-anchor" href="#本体建模" aria-hidden="true"></a></h3><img src="/2018/03/10/kgdemo/OntoGraph.png" alt="OntoGraph.png" title=""><ul><li><p>打开protege,在Ontology IRI中填写新建本体资源的IRI为”<a href="http://www.kgmovie.demo.com" target="_blank" rel="external">http://www.kgmovie.demo.com</a>“</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 进入protege目录,执行下面的命令</div><div class="line">./run.sh</div></pre></td></tr></tbody></table></figure></li><li><p>点击“Entities”tab标签,选择“Classes”标签.在这个界面,我们创建电影知识图谱的类/概念.</p><p>在owl:Thing下创建三个子类,Person,Movie,Genre.三个类的默认关系是互斥的.</p></li></ul><ul><li><p>切换到”Object Properties”页面创建<strong>类之间的关系,即,对象属性</strong>。</p><p>创建了三个对象属性，”hasActedIn”表示某人参演了某电影,该属性的”domain”是人,”range”是电影。(<em>“domain”表示该属性是属于哪个类的，”range”表示该属性的取值范围</em>),设置该属性的逆属性(Inverse of)是”hasActor”,可用于推理.另外一个属性”hasGenre”表示电影属于什么类型.</p></li><li><p>切换到”Data properties”页面创建<strong>类的属性,即,数据属性</strong>.</p><p>其实区分数据属性和对象属性还有一个很直观的方法,我们观察其”range”取值范围即可.</p><p><strong>对象属性的取值范围是类,而数据属性的取值范围则是字面量.</strong></p></li><li><p>保存文件,命名为”kgdemo.owl”</p></li><li><p>注意到,<strong>mysql中有五个表,本体中只有三个类</strong></p></li></ul><h2 id="数据转换" class="heading-control"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换<a class="heading-anchor" href="#数据转换" aria-hidden="true"></a></h2><h3 id="mysql-gt-RDF" class="heading-control"><a href="#mysql-gt-RDF" class="headerlink" title="mysql -> RDF"></a>mysql -&gt; RDF<a class="heading-anchor" href="#mysql-gt-RDF" aria-hidden="true"></a></h3><ul><li><p>下载D2RQ，进入其目录，运行下面的命令生成<strong>默认的</strong>mapping文件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./generate-mapping -u &lt;username&gt; -p &lt;password&gt; -o ../kgdemo/kg_demo_movie_mapping.ttl jdbc:mysql:///kg_demo_movie</div></pre></td></tr></tbody></table></figure></li><li><p>根据我们定义的本体<strong>修改mapping文件</strong></p><p>ttl文件中添加前缀: @prefix : <a href="http://www.kgmovie.demo.com#" target="_blank" rel="external">http://www.kgmovie.demo.com#</a> .(包括最后的这个句号)</p><p>去除没用的genre__label和genre_genre_id信息</p><p>vocab:xxxx 换成了本体构建时候的类</p><p>d2rq:property属性修改为本体中定义的属性(对象属性或者数据属性)</p></li><li><p>数据转为RDF</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./dump-rdf -o ../kgdemo/kg_demo_movie.nt ../kgdemo/kg_demo_movie_mapping.ttl</div></pre></td></tr></tbody></table></figure></li><li><p>查询示例</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ?titles <span class="keyword">WHERE</span> {</div><div class="line">  ?p rdf:<span class="keyword">type</span> :Person.</div><div class="line">  ?p :personEnglishName <span class="string">'Stephen Chow'</span>.</div><div class="line">  ?p :hasActedIn ?movies.</div><div class="line">  ?movies :movieTitle ?titles</div><div class="line">}</div><div class="line"><span class="keyword">limit</span> <span class="number">10</span></div></pre></td></tr></tbody></table></figure></li><li><p>返回结果为:</p><p>| titles           |<br>| —————- |<br>| “功夫”             |<br>| “琉璃樽”            |<br>| “英雄本色”           |<br>| “少林足球”           |<br>| “西游记第壹佰零壹回之月光宝盒” |<br>| “长江七号”           |<br>| “西游记大结局之仙履奇缘”    |<br>| “建国大业”           |<br>| “审死官”            |<br>| “龙在天涯”           |</p></li></ul><h3 id="Bug-To-Fix" class="heading-control"><a href="#Bug-To-Fix" class="headerlink" title="Bug To Fix"></a>Bug To Fix<a class="heading-anchor" href="#Bug-To-Fix" aria-hidden="true"></a></h3><p>使用中文姓名查询不到person</p><h2 id="jena-SPARQL-endpoint及推理" class="heading-control"><a href="#jena-SPARQL-endpoint及推理" class="headerlink" title="jena SPARQL endpoint及推理"></a>jena SPARQL endpoint及推理<a class="heading-anchor" href="#jena-SPARQL-endpoint及推理" aria-hidden="true"></a></h2><h3 id="jena示例" class="heading-control"><a href="#jena示例" class="headerlink" title="jena示例"></a>jena示例<a class="heading-anchor" href="#jena示例" aria-hidden="true"></a></h3><ul><li>下载apache-jena和apache-jena-fuseki</li><li>在apache-jena目录下,使用“tdbloader”将之前我们的RDF数据以TDB的方式存储。命令如下：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">./tdbloader --loc="../../kgdemo/tdb" "../../kgdemo/kg_demo_movie.nt"</div><div class="line">16:15:50 INFO  loader               :: -- Start triples data phase</div><div class="line">16:15:50 INFO  loader               :: ** Load empty triples table</div><div class="line">16:15:50 INFO  loader               :: -- Start quads data phase</div><div class="line">16:15:50 INFO  loader               :: ** Load empty quads table</div><div class="line">16:15:50 INFO  loader               :: Load: ../../kgdemo/kg_demo_movie.nt -- 2018/03/19 16:15:50 CST</div><div class="line">16:15:52 INFO  loader               :: -- Finish triples data phase</div><div class="line">16:15:52 INFO  loader               :: ** Data: 47,144 triples loaded in 1.26 seconds [Rate: 37,327.00 per second]</div><div class="line">16:15:52 INFO  loader               :: -- Finish quads data phase</div><div class="line">16:15:52 INFO  loader               :: -- Start triples index phase</div><div class="line">16:15:52 INFO  loader               :: ** Index SPO-&gt;POS: 47,144 slots indexed in 0.14 seconds [Rate: 334,354.63 per second]</div><div class="line">16:15:52 INFO  loader               :: ** Index SPO-&gt;OSP: 47,144 slots indexed in 0.13 seconds [Rate: 374,158.72 per second]</div><div class="line">16:15:52 INFO  loader               :: -- Finish triples index phase</div><div class="line">16:15:52 INFO  loader               :: ** 47,144 triples indexed in 0.27 seconds [Rate: 172,688.64 per second]</div><div class="line">16:15:52 INFO  loader               :: -- Finish triples load</div><div class="line">16:15:52 INFO  loader               :: ** Completed: 47,144 triples loaded in 1.55 seconds [Rate: 30,356.73 per second]</div><div class="line">16:15:52 INFO  loader               :: -- Finish quads load</div></pre></td></tr></tbody></table></figure><ul><li>在fuseki-server目录下,运行 <em>./fuseki-server</em> 服务,会在当前目录生成run文件夹,将本体文件重命名为”kgdemo.ttl”放入run/database,然后在run/configuration里创建config.ttl文件,内容为:</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@prefix :      &lt;http://base/#&gt; .</div><div class="line">@prefix tdb:   &lt;http://jena.hpl.hp.com/2008/tdb#&gt; .</div><div class="line">@prefix rdf:   &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .</div><div class="line">@prefix ja:    &lt;http://jena.hpl.hp.com/2005/11/Assembler#&gt; .</div><div class="line">@prefix rdfs:  &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .</div><div class="line">@prefix fuseki: &lt;http://jena.apache.org/fuseki#&gt; .</div><div class="line"></div><div class="line"></div><div class="line">:service1        a                fuseki:Service ;</div><div class="line">fuseki:dataset                    &lt;#dataset&gt; ;</div><div class="line">fuseki:name                       "kg_demo_movie" ;</div><div class="line">fuseki:serviceQuery               "query" , "sparql" ;</div><div class="line">fuseki:serviceReadGraphStore      "get" ;</div><div class="line">fuseki:serviceReadWriteGraphStore "data" ;</div><div class="line">fuseki:serviceUpdate              "update" ;</div><div class="line">fuseki:serviceUpload              "upload" .</div><div class="line"></div><div class="line"></div><div class="line">&lt;#dataset&gt; rdf:type ja:RDFDataset ;</div><div class="line">    ja:defaultGraph &lt;#model_inf&gt; ;</div><div class="line">    .</div><div class="line"></div><div class="line">&lt;#model_inf&gt; a ja:InfModel ;</div><div class="line">    ja:baseModel &lt;#tdbGraph&gt; ;</div><div class="line"></div><div class="line">    #本体文件的路径</div><div class="line">    ja:content [ja:externalContent &lt;file:////home/gao/software/apache-jena-fuseki-3.6.0/run/databases/kgdemo.ttl&gt; ] ;</div><div class="line">    </div><div class="line">    #启用OWL推理机</div><div class="line">    ja:reasoner [ja:reasonerURL &lt;http://jena.hpl.hp.com/2003/OWLFBRuleReasoner&gt;] .</div><div class="line"></div><div class="line">&lt;#tdbGraph&gt; rdf:type tdb:GraphTDB ;</div><div class="line">    tdb:dataset &lt;#tdbDataset&gt; ;</div><div class="line">    .</div><div class="line"></div><div class="line">&lt;#tdbDataset&gt; rdf:type tdb:DatasetTDB ;</div><div class="line">    tdb:location "/home/gao/software/kgdemo/tdb" ;</div></pre></td></tr></tbody></table></figure><ul><li>重启运行 <em>./fuseki-server</em></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[2018-03-19 16:39:13] Server     INFO  Apache Jena Fuseki 3.6.0</div><div class="line">[2018-03-19 16:39:13] Config     INFO  FUSEKI_HOME=/home/gao/software/apache-jena-fuseki-3.6.0</div><div class="line">[2018-03-19 16:39:13] Config     INFO  FUSEKI_BASE=/home/gao/software/apache-jena-fuseki-3.6.0/run</div><div class="line">[2018-03-19 16:39:13] Config     INFO  Shiro file: file:///home/gao/software/apache-jena-fuseki-3.6.0/run/shiro.ini</div><div class="line">[2018-03-19 16:39:13] Config     INFO  Configuration file: /home/gao/software/apache-jena-fuseki-3.6.0/run/config.ttl</div><div class="line">[2018-03-19 16:39:13] Config     INFO  Load configuration: file:///home/gao/software/apache-jena-fuseki-3.6.0/run/configuration/conf.ttl</div><div class="line">[2018-03-19 16:39:13] Config     INFO  Register: /kg_demo_movie</div><div class="line">[2018-03-19 16:39:13] Server     INFO  Started 2018/03/19 16:39:13 CST on port 3030</div></pre></td></tr></tbody></table></figure><ul><li>打开页面localhost:3030,查询,这里使用中文ok</li></ul><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;</div><div class="line">prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;</div><div class="line">prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt;</div><div class="line">prefix : &lt;http://www.kgmovie.demo.com#&gt;</div><div class="line"></div><div class="line">SELECT ?titles WHERE {</div><div class="line">  ?p rdf:type :Person.</div><div class="line">  ?p :personName '周星驰'.</div><div class="line">  ?p :hasActedIn ?movies.</div><div class="line">  ?movies :movieTitle ?titles</div><div class="line">}</div><div class="line">limit 10</div></pre></td></tr></tbody></table></figure><table><thead><tr><th></th><th>titles</th></tr></thead><tbody><tr><td>1</td><td>“琉璃樽”</td></tr><tr><td>2</td><td>“西游记第壹佰零壹回之月光宝盒”</td></tr><tr><td>3</td><td>“大内密探零零发”</td></tr><tr><td>4</td><td>“功夫”</td></tr><tr><td>5</td><td>“长江七号”</td></tr><tr><td>6</td><td>“回魂夜”</td></tr><tr><td>7</td><td>“百变星君”</td></tr><tr><td>8</td><td>“英雄本色”</td></tr><tr><td>9</td><td>“建国大业”</td></tr><tr><td>10</td><td>“唐伯虎点秋香”</td></tr></tbody></table><h3 id="自定义推理规则" class="heading-control"><a href="#自定义推理规则" class="headerlink" title="自定义推理规则"></a>自定义推理规则<a class="heading-anchor" href="#自定义推理规则" aria-hidden="true"></a></h3><ul><li>在“databases”文件夹下新建一个文本文件“rules.ttl”，填入如下内容：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@prefix : &lt;http://www.kgmovie.demo.com#&gt; .</div><div class="line">@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .</div><div class="line">@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .</div><div class="line">@prefix xsd: &lt;XML Schema&gt; .</div><div class="line">@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .</div><div class="line"></div><div class="line">[ruleComedian: (?p :hasActedIn ?m) (?m :hasGenre ?g) (?g :genreName '喜剧') -&gt; (?p rdf:type :Comedian)]</div><div class="line">[ruleInverse: (?p :hasActedIn ?m) -&gt; (?m :hasActor ?p)]</div></pre></td></tr></tbody></table></figure><ul><li>修改juseki-server配置文件:</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">@prefix :      &lt;http://base/#&gt; .</div><div class="line">@prefix tdb:   &lt;http://jena.hpl.hp.com/2008/tdb#&gt; .</div><div class="line">@prefix rdf:   &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .</div><div class="line">@prefix ja:    &lt;http://jena.hpl.hp.com/2005/11/Assembler#&gt; .</div><div class="line">@prefix rdfs:  &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .</div><div class="line">@prefix fuseki: &lt;http://jena.apache.org/fuseki#&gt; .</div><div class="line"></div><div class="line"></div><div class="line">:service1        a                fuseki:Service ;</div><div class="line">fuseki:dataset                    &lt;#dataset&gt; ;</div><div class="line">fuseki:name                       "kg_demo_movie" ;</div><div class="line">fuseki:serviceQuery               "query" , "sparql" ;</div><div class="line">fuseki:serviceReadGraphStore      "get" ;</div><div class="line">fuseki:serviceReadWriteGraphStore "data" ;</div><div class="line">fuseki:serviceUpdate              "update" ;</div><div class="line">fuseki:serviceUpload              "upload" .</div><div class="line"></div><div class="line"></div><div class="line">&lt;#dataset&gt; rdf:type ja:RDFDataset ;</div><div class="line">    ja:defaultGraph &lt;#model_inf&gt; ;</div><div class="line">    .</div><div class="line"></div><div class="line">&lt;#model_inf&gt; a ja:InfModel ;</div><div class="line">    ja:baseModel &lt;#tdbGraph&gt; ;</div><div class="line"></div><div class="line">    #本体文件的路径</div><div class="line">    ja:content [ja:externalContent &lt;file:////home/gao/software/apache-jena-fuseki-3.6.0/run/databases/kgdemo.ttl&gt; ] ;</div><div class="line">    </div><div class="line">    #关闭OWL推理机</div><div class="line">    #ja:reasoner [ja:reasonerURL &lt;http://jena.hpl.hp.com/2003/OWLFBRuleReasoner&gt;] .</div><div class="line"></div><div class="line">#开启规则推理机，并指定规则文件路径</div><div class="line">    ja:reasoner [</div><div class="line">        ja:reasonerURL &lt;http://jena.hpl.hp.com/2003/GenericRuleReasoner&gt; ; </div><div class="line">        ja:rulesFrom &lt;file:////home/gao/software/apache-jena-fuseki-3.6.0/run/databases/rules.ttl&gt; ; ]</div><div class="line">    .</div><div class="line">&lt;#tdbGraph&gt; rdf:type tdb:GraphTDB ;</div><div class="line">    tdb:dataset &lt;#tdbDataset&gt; ;</div><div class="line">    .</div><div class="line"></div><div class="line">&lt;#tdbDataset&gt; rdf:type tdb:DatasetTDB ;</div><div class="line">    tdb:location "/home/gao/software/kgdemo/tdb" ;</div><div class="line">    .</div></pre></td></tr></tbody></table></figure><ul><li>查询:</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> n <span class="keyword">WHERE</span> {</div><div class="line">?x rdf:<span class="keyword">type</span> :Comedian.</div><div class="line">?x :personName ?n.</div><div class="line">}</div><div class="line"><span class="keyword">limit</span> <span class="number">10</span></div></pre></td></tr></tbody></table></figure><p>结果如下:</p><table><thead><tr><th></th><th>n</th></tr></thead><tbody><tr><td>1</td><td>“邓浩光”</td></tr><tr><td>2</td><td>“梁朝伟”</td></tr><tr><td>3</td><td>“杨恭如”</td></tr><tr><td>4</td><td>“梁韵蕊”</td></tr><tr><td>5</td><td>“吴宇森”</td></tr><tr><td>6</td><td>“徐锦江”</td></tr><tr><td>7</td><td>“黄家驹”</td></tr><tr><td>8</td><td>“叶进”</td></tr><tr><td>9</td><td>“午马”</td></tr><tr><td>10</td><td>“梁咏琪”</td></tr></tbody></table><h3 id="TODO" class="heading-control"><a href="#TODO" class="headerlink" title="TODO"></a>TODO<a class="heading-anchor" href="#TODO" aria-hidden="true"></a></h3><p>不用sparql，用natural language查询结果<br>query-answer</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h2&gt;&lt;p&gt;系统：&lt;br&gt;ubuntu16.04&lt;/p&gt;
&lt;p&gt;软件目录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目目录/home/gao/software/kgdemo/&lt;/li&gt;
&lt;li&gt;数据库/home/gao/software/mysql&lt;/li&gt;
&lt;li&gt;应用框架/home/gao/software/apache-jena-3.6.0（这里使用了它的TDB组件&lt;/li&gt;
&lt;li&gt;SPARQL服务器/home/gao/software/apache-jena-fuseki-3.6.0&lt;/li&gt;
&lt;li&gt;数据转化工具/home/gao/software/d2rq-0.8.1&lt;/li&gt;
&lt;li&gt;本体构建工具/home/gao/software/Protege-5.2.0&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="知识图谱" scheme="https://yikayiyo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>构建IT领域概念图谱</title>
    <link href="https://yikayiyo.github.io/2018/01/10/%E6%9E%84%E5%BB%BAIT%E9%A2%86%E5%9F%9F%E6%A6%82%E5%BF%B5%E5%9B%BE%E8%B0%B1/"/>
    <id>https://yikayiyo.github.io/2018/01/10/%E6%9E%84%E5%BB%BAIT%E9%A2%86%E5%9F%9F%E6%A6%82%E5%BF%B5%E5%9B%BE%E8%B0%B1/</id>
    <published>2018-01-10T09:17:14.000Z</published>
    <updated>2018-01-10T10:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.sciencedirect.com/science/article/pii/S0957417415005941" target="_blank" rel="external">原文地址</a></p><h3 id="摘要" class="heading-control"><a href="#摘要" class="headerlink" title="摘要"></a>摘要<a class="heading-anchor" href="#摘要" aria-hidden="true"></a></h3><p>​    <strong>关联开放数据</strong>（LOD）中包含丰富的知识和语义，它的发展促使了很多知识型应用的诞生和兴起。在这些应用中，实体间的相关性（不同于相似性）这一概念扮演了重要角色。</p><p>​    在给定一个查询后我们感兴趣的不只是确切的返回值（exact answers ），还有那些与查询紧密相关的东西。</p><p>​    利用DBpedia中IT领域数据构建概念图谱的方法，不仅利用字符串匹配，还可以利用LOD数据集中编码的显示或隐式语义。在此基础上构建的专家系统，可以帮助那些在IT领域进行<strong>实体搜索</strong>任务的用户。</p><p>​    为了对相关实体进行<strong>排序</strong>需要计算相关度，这就涉及到不同的<strong>相关性度量</strong>（relatedness measures）。</p><h3 id="导读" class="heading-control"><a href="#导读" class="headerlink" title="导读"></a>导读<a class="heading-anchor" href="#导读" aria-hidden="true"></a></h3><p>​    基于关键词匹配的搜索在同义、歧义发生时，表现得很挣扎（suffer）。哪怕查询语句、资源描述都结构化了，同样的问题依然存在。导致这一问题的主要原因是，它们都<strong>无法捕获</strong>查询、资源描述中的词语的<strong>词义(meaning of terms)以及语义关联(the semantic relation)</strong>。</p><p>​    相关性（relatedness）是语义上的，比相似性概念宽泛（wider）。举例来说，MySQL和PostgreSQL很相似的，PHP和MySQL则是很相关的。</p><p>​    构建图谱的关键在于，怎么衡量两个实体间的相关度。</p><p>​    本文提出了一种语义感知的度量来评估实体间相关度，并利用这个度量构建IT领域概念图谱，图上每个节点都是IT概念（编程语言、数据库、技术、框架，等等）。</p><p>​    构建图谱时，利用了来自web的数据的<strong>统计特征</strong>以及从LOD数据集中抽取的<strong>语义知识</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0957417415005941&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot; cla
      
    
    </summary>
    
    
    
      <category term="知识图谱" scheme="https://yikayiyo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
      <category term="关联数据" scheme="https://yikayiyo.github.io/tags/%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE/"/>
    
      <category term="DBpedia" scheme="https://yikayiyo.github.io/tags/DBpedia/"/>
    
  </entry>
  
  <entry>
    <title>线性模型</title>
    <link href="https://yikayiyo.github.io/2017/11/11/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://yikayiyo.github.io/2017/11/11/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2017-11-11T03:22:45.000Z</published>
    <updated>2018-04-10T08:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>能不能使用线性分类器得到形状为圆圈的决策边界？<br><a id="more"></a></p><ul><li>可以的！所谓的线性分类器，<strong>线性</strong>指的是权重向量<strong>w</strong>和标签y的关系，而决策边界指的是y如何随着x的变化而变化</li></ul><p><strong>the prediction is driven by the score w · φ(x)</strong>，其中x是原始输入，φ(x)是提取到的特征</p><p>机器学习问题：定义优化问题，求解得到<strong>w</strong>（在 φ(x)固定的情况下）</p><p>构造特征：</p><ul><li>先验知识</li><li>特征模板</li></ul><p>定义特征：</p><ul><li>数组：适用于特征稠密的情况，假定特征排序固定</li><li>字典：特征稀疏(few nonzeros)时用字典表示字段到double<br>的映射更有效</li></ul><p>定义特征时一定要明确特征的含义</p><p>模型的表达（表现）能力——Expressivity：</p><ul><li>hypothesis class：特征φ(x)固定而<strong>w</strong>不同的预测器的集合<br>$$<br>F = {f_w : w ∈ R^d}<br>$$</li><li>学习的目的：利用训练数据从F中找到一个特定的预测器</li><li>如果<strong>φ(x)定义的F</strong>中的预测器都很差劲，no amount of learning can help.</li><li>关键在于：φ(x)能不能把好的预测器表达出来</li><li>F是不是<strong>越大越好？</strong></li></ul><p><strong>non-linearities in the original measurements(原始度量中的非线性)</strong> :</p><ul><li>Non-monotonicity(非单调性)：<ul><li>体温和健康程度的关系就不是单调的，你不能说体温越高越健康，反之亦然</li><li>φ(x) = [1, temperature(x)]   bad</li><li>φ(x) = [1, (temperature(x) − 37)^2] 转换特征，利用了先验知识</li><li>φ(x) = [1, temperature(x), temperature(x)^2]   task to simple blocks</li></ul></li><li>Saturation(饱和)：<ul><li>产品推荐</li><li>φ(x) = N(x) 购买产品的人数（受欢迎程度）和相关性，不具有线性关系</li><li>φ(x) = logN(x) 转换特征，取对数（N with a large dynamic range）</li><li>φ(x) = [1[0 &lt; N(x) ≤ 10], 1[10 &lt; N(x) ≤ 100],…]离散化，范围足够精细的话，可以非常灵活地捕捉常规关系</li></ul></li><li>Interaction between features(特征组合)：<ul><li>根据身高、体重预测健康病人状况</li><li>φ(x) = [height(x), weight(x)] #没能捕获身高体重的关系</li><li>φ(x) = (52 + 1.9(height(x) − 60) − weight(x))^2 #组合输入得到新的特征，利用了外界知识</li><li>φ(x) = [1, height(x), weight(x), height(x)^2, weight(x)^2, height(x)weight(x)] #添加包含多个度量的特征</li></ul></li></ul><p>Linear in what？ </p><ul><li>Linear in w?  Yes</li><li>Linear in φ(x)?  Yes </li><li>Linear in x?  No! (x not necessarily even a vector，可以是图片、文字)</li></ul><p>小结：</p><ul><li>从特征提取的角度来看，我们可以定义<strong>任意</strong>特征，带来x的极度非线性的函数</li><li>从学习的角度来看，线性在有效优化权重方面起着重要作用（因为它会导致凸优化问题）</li><li><strong>线性模型很强大</strong>！</li><li>将手工定义特征自动化—&gt; 神经网络</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;能不能使用线性分类器得到形状为圆圈的决策边界？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="machine learning" scheme="https://yikayiyo.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>jupyter notebook添加kernel</title>
    <link href="https://yikayiyo.github.io/2017/08/03/jupyter%20notebook%E6%B7%BB%E5%8A%A0kernel/"/>
    <id>https://yikayiyo.github.io/2017/08/03/jupyter%20notebook%E6%B7%BB%E5%8A%A0kernel/</id>
    <published>2017-08-03T02:20:33.000Z</published>
    <updated>2017-08-03T09:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装jupyter时使用了推荐的Anaconda，python默认环境python3。<br>添加python2的方法如下，亲测有效 - 0-</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">conda create -n py27 python=<span class="number">2.7</span></div><div class="line">source activate py27</div><div class="line">conda install notebook ipykernel</div><div class="line">ipython kernel install --user</div></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装jupyter时使用了推荐的Anaconda，python默认环境python3。&lt;br&gt;添加python2的方法如下，亲测有效 - 0-&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
    
      <category term="python" scheme="https://yikayiyo.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>《编码》读后感</title>
    <link href="https://yikayiyo.github.io/2017/07/31/%E7%BC%96%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>https://yikayiyo.github.io/2017/07/31/%E7%BC%96%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/</id>
    <published>2017-07-31T14:33:33.000Z</published>
    <updated>2017-08-01T10:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>很有趣的书。</p><p>早点读到这本书的话，学习计算机基础知识的时候应该会一边学一边感叹“哇！有意思！”吧。</p><p>计算机在今天如此普及，现代人享受便利的时候如果想想这东西是怎么发明出来的，一定得惊叹“不可思议”。</p><p>盲文、摩斯码、灯泡、电池、继电器、十进制、bit、二进制、门电路等等，书中记录了这些探索是如何一步一步影响着现代科技的。</p><p><strong>每一种语言都可以看作是一套编码</strong>。</p><p>编码是为了满足人的某个需求出现的，而语言是为了交流。</p><p>规则不一样时，同一个物体在编码空间所处的位置就不一样了。</p><p>如果只有一门语言，一种编码，就不需要翻译了。</p><p>人类起初在不同的区域形成了不同的语言，如今交流如此频繁，回归一种语言是不是有一种宿命的感觉。</p><p>God is watching you.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很有趣的书。&lt;/p&gt;
&lt;p&gt;早点读到这本书的话，学习计算机基础知识的时候应该会一边学一边感叹“哇！有意思！”吧。&lt;/p&gt;
&lt;p&gt;计算机在今天如此普及，现代人享受便利的时候如果想想这东西是怎么发明出来的，一定得惊叹“不可思议”。&lt;/p&gt;
&lt;p&gt;盲文、摩斯码、灯泡、电池、继电器
      
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://yikayiyo.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="杂" scheme="https://yikayiyo.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>爬虫tips（2）</title>
    <link href="https://yikayiyo.github.io/2017/07/24/%E7%88%AC%E8%99%ABtips%EF%BC%882%EF%BC%89/"/>
    <id>https://yikayiyo.github.io/2017/07/24/%E7%88%AC%E8%99%ABtips%EF%BC%882%EF%BC%89/</id>
    <published>2017-07-24T07:55:00.000Z</published>
    <updated>2017-07-29T14:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态内容" class="heading-control"><a href="#动态内容" class="headerlink" title="动态内容"></a>动态内容<a class="heading-anchor" href="#动态内容" aria-hidden="true"></a></h3><p>依赖JavaScript的动态网站，不是在第一次加载时下载全部内容，网页中展示的内容并没有出现在HTML源码中</p><h4 id="AJAX" class="heading-control"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX<a class="heading-anchor" href="#AJAX" aria-hidden="true"></a></h4><blockquote><p>Asynchronous JavaScript and XML<br>综合了多项技术的浏览器端网页开发技术<br>允许JavaScript创建到服务器的HTTP请求并获得响应</p></blockquote><a id="more"></a><p>  传统的Web应用允许用户端填写表单（form），当提交表单时就向网页服务器发送一个请求。服务器接收并处理传来的表单，然后送回一个新的网页，但这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。<br>  与此不同，AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少（大约只有原来的5%）[来源请求],服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。</p><h3 id="抓取方式" class="heading-control"><a href="#抓取方式" class="headerlink" title="抓取方式"></a>抓取方式<a class="heading-anchor" href="#抓取方式" aria-hidden="true"></a></h3><ul><li>JavaScript逆向工程</li><li>渲染 JavaScript</li></ul><h4 id="JavaScript逆向工程" class="heading-control"><a href="#JavaScript逆向工程" class="headerlink" title="JavaScript逆向工程"></a>JavaScript逆向工程<a class="heading-anchor" href="#JavaScript逆向工程" aria-hidden="true"></a></h4><p>所谓逆向工程就是去了解数据的请求链接是什么形式<br>AJAX数据可以直接请求，我们要做的是构建请求，然后分析返回的结果（ 一般是JSON数据——python提供了json模块可以方便地解析response数据<br>与抽取html再分析相比，这种方式下数据的结构其实更容易抽取<br><strong>构建请求时利用边界情况进行简化</strong>：</p><ol><li>提高每个页面的显示数量可以减少下载次数</li><li>尝试利用正则减少请求，使用一次搜索查询就能匹配所有结果</li></ol><h4 id="渲染JavaScript" class="heading-control"><a href="#渲染JavaScript" class="headerlink" title="渲染JavaScript"></a>渲染JavaScript<a class="heading-anchor" href="#渲染JavaScript" aria-hidden="true"></a></h4><p>渲染引擎是浏览器在显示网页时解析HTML、应用css样式并执行JavaScript语句的部分<br>利用Selenium+PhantomJS可以模拟<strong>上述行为</strong>（Selenium也可以执行JavaScript脚本）没有关注<strong>链接构造</strong><br>轮询网页：判断特定内容有没有出现</p><h4 id="比较" class="heading-control"><a href="#比较" class="headerlink" title="比较"></a>比较<a class="heading-anchor" href="#比较" aria-hidden="true"></a></h4><p>前者从长期来看性能和可靠性更高<br>后者适合作为短期解决方案，不需要我们了解网站的后端工作原理<br>不足在于渲染网页增加了开销，轮询网页在网络较慢时经常失败</p><h4 id="TODO" class="heading-control"><a href="#TODO" class="headerlink" title="TODO"></a>TODO<a class="heading-anchor" href="#TODO" aria-hidden="true"></a></h4><p>表单交互</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;动态内容&quot;&gt;&lt;a href=&quot;#动态内容&quot; class=&quot;headerlink&quot; title=&quot;动态内容&quot;&gt;&lt;/a&gt;动态内容&lt;/h3&gt;&lt;p&gt;依赖JavaScript的动态网站，不是在第一次加载时下载全部内容，网页中展示的内容并没有出现在HTML源码中&lt;/p&gt;
&lt;h4 id=&quot;AJAX&quot;&gt;&lt;a href=&quot;#AJAX&quot; class=&quot;headerlink&quot; title=&quot;AJAX&quot;&gt;&lt;/a&gt;AJAX&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;Asynchronous JavaScript and XML&lt;br&gt;综合了多项技术的浏览器端网页开发技术&lt;br&gt;允许JavaScript创建到服务器的HTTP请求并获得响应&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="爬虫" scheme="https://yikayiyo.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>selenium + phantomJS 小Demo</title>
    <link href="https://yikayiyo.github.io/2017/07/23/selenium%20+%20phantomJS%20%E5%B0%8FDemo/"/>
    <id>https://yikayiyo.github.io/2017/07/23/selenium%20+%20phantomJS%20%E5%B0%8FDemo/</id>
    <published>2017-07-23T12:20:16.000Z</published>
    <updated>2017-07-26T13:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>借助selenium和phantomJS抓取淘宝美食信息.</p><h4 id="配置" class="heading-control"><a href="#配置" class="headerlink" title="配置"></a>配置<a class="heading-anchor" href="#配置" aria-hidden="true"></a></h4><p>数据库配置<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#样例</span></div><div class="line">MONGO_URL=<span class="string">'localhost'</span></div><div class="line">MONGO_DB=<span class="string">'taobao'</span></div><div class="line">MONGO_TABLE=<span class="string">'product'</span></div></pre></td></tr></tbody></table></figure><p></p><p>声明浏览器</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">browser=webdriver.PhantomJS(service_args=SERVICE_ARGS)</div></pre></td></tr></tbody></table></figure><p>浏览器配置<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#不加载图片、开启缓存</span></div><div class="line">SERVICE_ARGS=[<span class="string">'--load-images=false'</span>,<span class="string">'--disk-cache=true'</span>]</div></pre></td></tr></tbody></table></figure><p></p><h4 id="搜索" class="heading-control"><a href="#搜索" class="headerlink" title="搜索"></a>搜索<a class="heading-anchor" href="#搜索" aria-hidden="true"></a></h4><a id="more"></a><ol><li>给定url,请求页面</li><li>判断加载成功，定位搜索框input，搜索按钮submit</li><li>搜索框中输入信息，input.send_keys(‘美食’)；点击搜索按钮，submit.click()</li><li>等待加载，获取结果总页数（正则提取数字)</li></ol><h4 id="翻页" class="heading-control"><a href="#翻页" class="headerlink" title="翻页"></a>翻页<a class="heading-anchor" href="#翻页" aria-hidden="true"></a></h4><p>采用页面跳转，即输入到第X页然后点击确定。</p><ol><li>判断加载成功，定位跳转按钮，页码框</li><li>清除页码框中原始信息，输入页码，点击跳转按钮</li><li>判断翻页成功：高亮页码 == 页码框中的数 ==&gt; text_to_be_present_in_element()</li></ol><h4 id="页面解析" class="heading-control"><a href="#页面解析" class="headerlink" title="页面解析"></a>页面解析<a class="heading-anchor" href="#页面解析" aria-hidden="true"></a></h4><ol><li>判断加载是否成功</li><li>获取page_source</li><li>利用css解析器或者xpath，对于itemlist中的每一个item，提取相关信息</li><li>存入数据库</li></ol><h4 id="注意" class="heading-control"><a href="#注意" class="headerlink" title="注意"></a>注意<a class="heading-anchor" href="#注意" aria-hidden="true"></a></h4><p>抛出异常</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;借助selenium和phantomJS抓取淘宝美食信息.&lt;/p&gt;
&lt;h4 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h4&gt;&lt;p&gt;数据库配置&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#样例&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;MONGO_URL=&lt;span class=&quot;string&quot;&gt;&#39;localhost&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;MONGO_DB=&lt;span class=&quot;string&quot;&gt;&#39;taobao&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;MONGO_TABLE=&lt;span class=&quot;string&quot;&gt;&#39;product&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;声明浏览器&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;browser=webdriver.PhantomJS(service_args=SERVICE_ARGS)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;浏览器配置&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#不加载图片、开启缓存&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;SERVICE_ARGS=[&lt;span class=&quot;string&quot;&gt;&#39;--load-images=false&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;--disk-cache=true&#39;&lt;/span&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;h4 id=&quot;搜索&quot;&gt;&lt;a href=&quot;#搜索&quot; class=&quot;headerlink&quot; title=&quot;搜索&quot;&gt;&lt;/a&gt;搜索&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="爬虫" scheme="https://yikayiyo.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫tips</title>
    <link href="https://yikayiyo.github.io/2017/07/21/%E7%88%AC%E8%99%ABtips/"/>
    <id>https://yikayiyo.github.io/2017/07/21/%E7%88%AC%E8%99%ABtips/</id>
    <published>2017-07-21T07:16:19.000Z</published>
    <updated>2017-08-22T09:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接抓取" class="heading-control"><a href="#链接抓取" class="headerlink" title="链接抓取"></a>链接抓取<a class="heading-anchor" href="#链接抓取" aria-hidden="true"></a></h3><ul><li>根据首页链接抓取内容</li><li>页面包含的链接放入一个set,避免重复</li><li>解析robot.txt,避免下载禁止爬取的页面</li><li>已经抓取过的链接放在一个set</li><li><a id="more"></a></li><li>抽取深度达到限定值后停止,避免爬虫陷阱</li><li>同一域名的两次下载之间设置延迟,避免爬取过快</li><li>下载失败时重试下载(设置一个try_times参数,递归调用 </li></ul><p>得到一堆html页面</p><h3 id="数据抓取" class="heading-control"><a href="#数据抓取" class="headerlink" title="数据抓取"></a>数据抓取<a class="heading-anchor" href="#数据抓取" aria-hidden="true"></a></h3><table><thead><tr><th>方法</th><th>性能</th><th>使用难度</th><th>安装难度</th></tr></thead><tbody><tr><td>正则</td><td>快</td><td>困难</td><td>简单</td></tr><tr><td>Beautiful Soup</td><td>慢</td><td>简单</td><td>简单</td></tr><tr><td>Lxml</td><td>快</td><td>简单</td><td>相对困难</td></tr></tbody></table><p>如果爬虫的瓶颈在下载页面,不是数据抓取,那么可以使用BS<br>如果要抓的数据不多,使用正则更加高效率<br>lxml是最佳选择</p><h4 id="正则" class="heading-control"><a href="#正则" class="headerlink" title="正则"></a>正则<a class="heading-anchor" href="#正则" aria-hidden="true"></a></h4><p>如果要选取的东西,格式很常见,有很多相似项,可以尝试指明它的父元素或者祖先元素,最好是有id属性 (:_&lt; id是<strong>唯一</strong>的吧)  </p><h4 id="CSS选择器" class="heading-control"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器<a class="heading-anchor" href="#CSS选择器" aria-hidden="true"></a></h4><ul><li>选择所有标签: *.</li><li>选择a标签: a</li><li>选择class=”link”的元素: .link</li><li>选择class=”link”的a标签: a.link</li><li>选择id=”home”的a标签: a#home</li><li>选择父元素为a标签的所有span标签: a &gt; span</li><li>选择a标签内的所有span标签: a span</li><li>选择title属性为”home”的所有a标签: a[title=home]</li></ul><h4 id="给链接抽取添加数据处理回调" class="heading-control"><a href="#给链接抽取添加数据处理回调" class="headerlink" title="给链接抽取添加数据处理回调"></a>给链接抽取添加数据处理回调<a class="heading-anchor" href="#给链接抽取添加数据处理回调" aria-hidden="true"></a></h4><ul><li>构造回调<strong>函数</strong>或者回调<strong>类</strong>(定义<strong>__call__()</strong>方法)</li><li>数据写入文件</li></ul><h3 id="下载缓存" class="heading-control"><a href="#下载缓存" class="headerlink" title="下载缓存"></a>下载缓存<a class="heading-anchor" href="#下载缓存" aria-hidden="true"></a></h3><h4 id="磁盘缓存" class="heading-control"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存<a class="heading-anchor" href="#磁盘缓存" aria-hidden="true"></a></h4><ul><li>下载前检查缓存</li><li>没有时再请求网页下载,并存至缓存</li><li>设计URL到文件名的<strong>映射</strong> : 注意命名格式限制,例如长度,允许的字符</li><li>数据(html)可以压缩: zlib.compress|zlib.decompress</li><li><p>保存时间戳,过期缓存失效</p><p><strong>缺点</strong>: 受限于文件系统,数量有限</p></li></ul><h4 id="数据库缓存" class="heading-control"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存<a class="heading-anchor" href="#数据库缓存" aria-hidden="true"></a></h4><p>存储大量数据,没有复杂的连接操作,选择易拓展的NoSql<br>加载时间比文件系统多,但免于文件系统的限制</p><h3 id="并发下载" class="heading-control"><a href="#并发下载" class="headerlink" title="并发下载"></a>并发下载<a class="heading-anchor" href="#并发下载" aria-hidden="true"></a></h3><h4 id="多线程爬虫" class="heading-control"><a href="#多线程爬虫" class="headerlink" title="多线程爬虫"></a>多线程爬虫<a class="heading-anchor" href="#多线程爬虫" aria-hidden="true"></a></h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#处理url的函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_crawler</span>:</span></div><div class="line">    ...</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_url</span>:</span></div><div class="line"><span class="keyword">pass</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">#逻辑:设定一个线程池,最大线程数为max_threads.当有URL爬取时,检测是否有线程,有的话处理掉完成的线程,再判断是否创建新线程</span></div><div class="line">    threads=[]</div><div class="line">    <span class="keyword">while</span> threads <span class="keyword">or</span> crawl_queue:</div><div class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> thread.is_allive():</div><div class="line">                <span class="comment">#remove</span></div><div class="line">                threads.remove(thread)</div><div class="line">        <span class="comment">#在多个线程中启动process_url,条件是当前线程数小于设定值,并且待爬队列不为空</span></div><div class="line">        <span class="keyword">while</span> len(threads)&lt;max_threads <span class="keyword">and</span> crawl_queue:</div><div class="line">            thread = threading.Thread(target=process_url)</div><div class="line">            thread.start()</div><div class="line">            threads.append(thread)</div></pre></td></tr></tbody></table></figure><h4 id="多进程爬虫" class="heading-control"><a href="#多进程爬虫" class="headerlink" title="多进程爬虫"></a>多进程爬虫<a class="heading-anchor" href="#多进程爬虫" aria-hidden="true"></a></h4><p>有几个cpu创建几个进程</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">processes=[]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_cpus):</div><div class="line">    p=multiprocessing.Process(target=thread_crawler)</div><div class="line">    p.start()</div><div class="line">    processes.append(p)</div></pre></td></tr></tbody></table></figure><h3 id="动态内容" class="heading-control"><a href="#动态内容" class="headerlink" title="动态内容"></a>动态内容<a class="heading-anchor" href="#动态内容" aria-hidden="true"></a></h3><p>todo…</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接抓取&quot;&gt;&lt;a href=&quot;#链接抓取&quot; class=&quot;headerlink&quot; title=&quot;链接抓取&quot;&gt;&lt;/a&gt;链接抓取&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;根据首页链接抓取内容&lt;/li&gt;
&lt;li&gt;页面包含的链接放入一个set,避免重复&lt;/li&gt;
&lt;li&gt;解析robot.txt,避免下载禁止爬取的页面&lt;/li&gt;
&lt;li&gt;已经抓取过的链接放在一个set&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="爬虫" scheme="https://yikayiyo.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>selenium学习</title>
    <link href="https://yikayiyo.github.io/2017/07/19/selenium%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yikayiyo.github.io/2017/07/19/selenium%E5%AD%A6%E4%B9%A0/</id>
    <published>2017-07-19T12:59:19.000Z</published>
    <updated>2017-07-19T13:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="声明浏览器对象" class="heading-control"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象<a class="heading-anchor" href="#声明浏览器对象" aria-hidden="true"></a></h3><p>ubuntu下打不开chrome浏览器，重新安装了chromium-browser，并使用下面的声明语句<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">browser = webdriver.Chrome(<span class="string">"/usr/lib/chromium-browser/chromedriver"</span>)</div></pre></td></tr></tbody></table></figure><p></p><p>方案来源<a href="https://stackoverflow.com/questions/22476112/using-chromedriver-with-selenium-python-ubuntu" target="_blank" rel="external">https://stackoverflow.com/questions/22476112/using-chromedriver-with-selenium-python-ubuntu</a> </p><p>貌似添加chrome的path也能解决 </p><h3 id="获取元素" class="heading-control"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素<a class="heading-anchor" href="#获取元素" aria-hidden="true"></a></h3><p>可以通过id，name，classname，xpath，css_selector等获得<br>两种写法：<a id="more"></a><br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</div><div class="line">elem = browser.find_element(By.ID,<span class="string">"kw"</span>)</div></pre></td></tr></tbody></table></figure><p></p><p>或者<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">elem = browser.find_element_by_id(<span class="string">"kw"</span>)</div></pre></td></tr></tbody></table></figure><p></p><h3 id="获取多个元素" class="heading-control"><a href="#获取多个元素" class="headerlink" title="获取多个元素"></a>获取多个元素<a class="heading-anchor" href="#获取多个元素" aria-hidden="true"></a></h3><p>就是element和elements的小区别，返回一个列表 </p><h3 id="元素交互" class="heading-control"><a href="#元素交互" class="headerlink" title="元素交互"></a>元素交互<a class="heading-anchor" href="#元素交互" aria-hidden="true"></a></h3><p>先获取特定元素，再对其调用交互<br>input.send_keys(“xxx”) 为元素赋值”xxx“<br>button.click() 点击button元素</p><h3 id="交互动作" class="heading-control"><a href="#交互动作" class="headerlink" title="交互动作"></a>交互动作<a class="heading-anchor" href="#交互动作" aria-hidden="true"></a></h3><p>将动作附加到动作链中执行,比如可以实现元素拖拽、点击、双击等<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</div></pre></td></tr></tbody></table></figure><p></p><h3 id="执行JavaScript" class="heading-control"><a href="#执行JavaScript" class="headerlink" title="执行JavaScript"></a>执行JavaScript<a class="heading-anchor" href="#执行JavaScript" aria-hidden="true"></a></h3><p>browser.execute_script(script_name)  </p><h3 id="获取属性值" class="heading-control"><a href="#获取属性值" class="headerlink" title="获取属性值"></a>获取属性值<a class="heading-anchor" href="#获取属性值" aria-hidden="true"></a></h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">elem.get_attribute(<span class="string">'xxx'</span>) </div><div class="line">elem.get_property(<span class="string">'xxxx'</span>)</div></pre></td></tr></tbody></table></figure><h3 id="获取文本值" class="heading-control"><a href="#获取文本值" class="headerlink" title="获取文本值"></a>获取文本值<a class="heading-anchor" href="#获取文本值" aria-hidden="true"></a></h3><p>elem.text  </p><h3 id="获取ID、位置、标签名、大小" class="heading-control"><a href="#获取ID、位置、标签名、大小" class="headerlink" title="获取ID、位置、标签名、大小"></a>获取ID、位置、标签名、大小<a class="heading-anchor" href="#获取ID、位置、标签名、大小" aria-hidden="true"></a></h3><p>elem.id<br>elem.location<br>elem.tag_name<br>elem.size</p><h3 id="Frame" class="heading-control"><a href="#Frame" class="headerlink" title="Frame"></a>Frame<a class="heading-anchor" href="#Frame" aria-hidden="true"></a></h3><p>提取元素时，要注意frame的切换<br>位于子frame时，找不到父frame中的元素</p><h3 id="等待" class="heading-control"><a href="#等待" class="headerlink" title="等待"></a>等待<a class="heading-anchor" href="#等待" aria-hidden="true"></a></h3><p>隐式等待<br>显式等待</p><h3 id="前进后退" class="heading-control"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退<a class="heading-anchor" href="#前进后退" aria-hidden="true"></a></h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brower.back()</div><div class="line">brower.forward()</div></pre></td></tr></tbody></table></figure><h3 id="Cookies" class="heading-control"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies<a class="heading-anchor" href="#Cookies" aria-hidden="true"></a></h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">browser.get_cookies()</div><div class="line">browser.add_cookie({dict})</div></pre></td></tr></tbody></table></figure><h3 id="选项卡管理" class="heading-control"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理<a class="heading-anchor" href="#选项卡管理" aria-hidden="true"></a></h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#打开一个页面，新建一个选项卡，切换回页面</span></div><div class="line">url=<span class="string">"http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable"</span></div><div class="line">browser.get(url)</div><div class="line">browser.execute_script(<span class="string">'window.open()'</span>)</div><div class="line">browser.switch_to.window(browser.window_handles[<span class="number">0</span>])</div></pre></td></tr></tbody></table></figure><h3 id="异常" class="heading-control"><a href="#异常" class="headerlink" title="异常"></a>异常<a class="heading-anchor" href="#异常" aria-hidden="true"></a></h3><p>超时、元素不存在等</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;声明浏览器对象&quot;&gt;&lt;a href=&quot;#声明浏览器对象&quot; class=&quot;headerlink&quot; title=&quot;声明浏览器对象&quot;&gt;&lt;/a&gt;声明浏览器对象&lt;/h3&gt;&lt;p&gt;ubuntu下打不开chrome浏览器，重新安装了chromium-browser，并使用下面的声明语句&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;browser = webdriver.Chrome(&lt;span class=&quot;string&quot;&gt;&quot;/usr/lib/chromium-browser/chromedriver&quot;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;方案来源&lt;a href=&quot;https://stackoverflow.com/questions/22476112/using-chromedriver-with-selenium-python-ubuntu&quot;&gt;https://stackoverflow.com/questions/22476112/using-chromedriver-with-selenium-python-ubuntu&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;貌似添加chrome的path也能解决 &lt;/p&gt;
&lt;h3 id=&quot;获取元素&quot;&gt;&lt;a href=&quot;#获取元素&quot; class=&quot;headerlink&quot; title=&quot;获取元素&quot;&gt;&lt;/a&gt;获取元素&lt;/h3&gt;&lt;p&gt;可以通过id，name，classname，xpath，css_selector等获得&lt;br&gt;两种写法：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="爬虫" scheme="https://yikayiyo.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Integer Break</title>
    <link href="https://yikayiyo.github.io/2017/06/23/Integer%20Break/"/>
    <id>https://yikayiyo.github.io/2017/06/23/Integer%20Break/</id>
    <published>2017-06-23T02:59:19.000Z</published>
    <updated>2017-07-24T13:36:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.</p><p>For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).<br>Note: You may assume that n is not less than 2 and not larger than 58.</p><p><strong>思路:<a id="more"></a> 最值问题,求导.</strong><br>假设一个数N分成了N/x份,每份都是x,则有<br>$$<br>y=x^{N/x},\<br>\ln y=(N/x)\ln x,\<br>\frac{1}{y}*y^{‘}=\frac{n}{x^2}(1-\ln x),<br>$$<br>另y’=0,则有lnx=1,x=e.<br>题中规定x只能是正整数,e约为2.718,则取离e较近的数3,此时y较大.<br>于是有递推式: dp(i)=3dp(i-3) (i&gt;4 ),i&lt;=4时,dp[i]=[1,1,1,2,4].</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        bottom to up dp.</div><div class="line">        """</div><div class="line">        res=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</div><div class="line">        <span class="keyword">if</span> n&lt;=<span class="number">4</span>:<span class="keyword">return</span> res[n]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            ans=<span class="number">1</span></div><div class="line">            <span class="keyword">while</span> n&gt;<span class="number">4</span>:</div><div class="line">                ans*=<span class="number">3</span></div><div class="line">                n-=<span class="number">3</span></div><div class="line">            ans*=n</div><div class="line">        <span class="keyword">return</span> ans</div></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.&lt;/p&gt;
&lt;p&gt;For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).&lt;br&gt;Note: You may assume that n is not less than 2 and not larger than 58.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="动态规划" scheme="https://yikayiyo.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>深、浅拷贝</title>
    <link href="https://yikayiyo.github.io/2017/06/22/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://yikayiyo.github.io/2017/06/22/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2017-06-22T01:50:22.000Z</published>
    <updated>2017-08-01T10:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>拷贝是对于可变对象list而言的，非容器类型（如数字、字符串、和其他’原子’类型的对象）是没有拷贝这个说法的</strong></p><h3 id="赋值" class="heading-control"><a href="#赋值" class="headerlink" title="赋值"></a>赋值<a class="heading-anchor" href="#赋值" aria-hidden="true"></a></h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></tbody></table></figure><p>b是a的别名，指向一个地址<a id="more"></a></p><h3 id="浅拷贝" class="heading-control"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝<a class="heading-anchor" href="#浅拷贝" aria-hidden="true"></a></h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]              <span class="comment">#或者使用 b = list(a)</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] <span class="keyword">is</span> b[<span class="number">0</span>]</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.append([<span class="number">6</span>,<span class="number">7</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">3</span>].append(<span class="string">'x'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="string">'x'</span>], [<span class="number">6</span>, <span class="number">7</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="string">'x'</span>]]</div></pre></td></tr></tbody></table></figure><p>浅拷贝构造了一个新的list对象<br>b的内部元素<strong>是a元素的引用</strong> ( the new list represents a sequence of references to the same elements as in the first )<br>修改b中的可变对象会影响a ；</p><h3 id="深拷贝" class="heading-control"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝<a class="heading-anchor" href="#深拷贝" aria-hidden="true"></a></h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b=copy.deepcopy(a)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="string">'x'</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="string">'x'</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">3</span>].pop()</div><div class="line"><span class="string">'x'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="string">'x'</span>]]</div></pre></td></tr></tbody></table></figure><p>不仅list对象是新的，list里的元素也是新的；<br>这里a[3] is not b[3] .</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;拷贝是对于可变对象list而言的，非容器类型（如数字、字符串、和其他’原子’类型的对象）是没有拷贝这个说法的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;赋值&quot;&gt;&lt;a href=&quot;#赋值&quot; class=&quot;headerlink&quot; title=&quot;赋值&quot;&gt;&lt;/a&gt;赋值&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b = a&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; b&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;b是a的别名，指向一个地址&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="https://yikayiyo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="https://yikayiyo.github.io/tags/python/"/>
    
  </entry>
  
</feed>
